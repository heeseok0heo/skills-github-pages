import{g as vl,d as No,c as Re,f as pa,i as nr,t as se,m as ae,a as ct,b as X,e as mi,h as Rs,j as _o,k as yl,l as Pn,n as Hn,s as Cl,o as q,p as Sl,q as nn,r as je,u as Jn,v as xl,w as wl,x as Rl,y as oe,z as Ct,A as qa,B as Da,C as jn,D as Ml,E as Fe,F as Ei,G as Zr,H as Di,I as ge,J as Ol,K as ml,L as bn,M as El,N as Dl,O as Go,P as Vl,Q as Ll,R as Za,S as Fl,W as kl,T as Uo,U as Tr,V as Ms,X as Nl,Y as Os,Z as Pa,_ as _l,$ as Gl,a0 as Bo,a1 as Ja,a2 as Qa,a3 as Ul,a4 as Bl,a5 as ms,a6 as Wl,a7 as $l,a8 as zl,a9 as Hl,aa as Ia}from"./vendor-4f1ecac8.js";const qe=vl(),Wo={vtkObject:()=>null};function Ze(t){if(t==null||t.isA)return t;if(!t.vtkClass)return qe.console&&qe.console.error&&qe.console.error("Invalid VTK object"),null;const e=Wo[t.vtkClass];if(!e)return qe.console&&qe.console.error&&qe.console.error(`No vtk class found for Object of type ${t.vtkClass}`),null;const r={...t};Object.keys(r).forEach(a=>{r[a]&&typeof r[a]=="object"&&r[a].vtkClass&&(r[a]=Ze(r[a]))});const n=e(r);return n&&n.modified&&n.modified(),n}function jl(t,e){Wo[t]=e}Ze.register=jl;class Va extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let ei=0;const $o=Symbol("void");function bl(){return ei}const zo={};function At(){}const Kl=["log","debug","info","warn","error","time","timeEnd","group","groupEnd"];Kl.forEach(t=>{zo[t]=At});qe.console=console.hasOwnProperty("log")?console:zo;const Ut={debug:At,error:qe.console.error||At,info:qe.console.info||At,log:qe.console.log||At,warn:qe.console.warn||At};function Ho(t,e){Ut[t]&&(Ut[t]=e||At)}function jo(){Ut.log(...arguments)}function bo(){Ut.info(...arguments)}function Pr(){Ut.debug(...arguments)}function ne(){Ut.error(...arguments)}function rr(){Ut.warn(...arguments)}const Es={};function Ko(t){Es[t]||(Ut.error(t),Es[t]=!0)}const Ee=Object.create(null);Ee.Float32Array=Float32Array;Ee.Float64Array=Float64Array;Ee.Uint8Array=Uint8Array;Ee.Int8Array=Int8Array;Ee.Uint16Array=Uint16Array;Ee.Int16Array=Int16Array;Ee.Uint32Array=Uint32Array;Ee.Int32Array=Int32Array;Ee.Uint8ClampedArray=Uint8ClampedArray;try{Ee.BigInt64Array=BigInt64Array,Ee.BigUint64Array=BigUint64Array}catch{}function ar(t){for(var e=arguments.length,r=new Array(e>1?e-1:0),n=1;n<e;n++)r[n-1]=arguments[n];return new(Ee[t]||Float64Array)(...r)}function ha(t){for(var e=arguments.length,r=new Array(e>1?e-1:0),n=1;n<e;n++)r[n-1]=arguments[n];return(Ee[t]||Float64Array).from(...r)}function da(t){return t.charAt(0).toUpperCase()+t.slice(1)}function de(t){return da(t[0]==="_"?t.slice(1):t)}function Xo(t){return t.charAt(0).toLowerCase()+t.slice(1)}function Ao(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:2,r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:1e3;const n=["TB","GB","MB","KB"];let a=Number(t),i="B";for(;a>r;)a/=r,i=n.pop();return`${a.toFixed(e)} ${i}`}function Yo(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:" ";const r=[];let n=t;for(;n>1e3;)r.push(`000${n%1e3}`.slice(-3)),n=Math.floor(n/1e3);return n>0&&r.push(n),r.reverse(),r.join(e)}function qo(t){Object.keys(t).forEach(e=>{Array.isArray(t[e])&&(t[e]=[].concat(t[e]))})}function Xl(t){return Object.values(Ee).some(e=>t instanceof e)}function Al(t,e){if(t===e)return!0;if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;for(let r=0;r<t.length;r++)if(t[r]!==e[r])return!1;return!0}return!1}function Yl(t,e){return Object.keys(t).find(r=>t[r]===e)}function Zo(t){return t&&t.isA?t.getState():t}function Vi(t){setTimeout(t,0)}function Po(t,e){const r=performance.now();t.finally(()=>{const n=performance.now()-r;e(n)})}function xe(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};qo(e);const r=[];if(Number.isInteger(e.mtime)||(e.mtime=++ei),!("classHierarchy"in e))e.classHierarchy=new Va("vtkObject");else if(!(e.classHierarchy instanceof Va)){const i=new Va;for(let s=0;s<e.classHierarchy.length;s++)i.push(e.classHierarchy[s]);e.classHierarchy=i}function n(i){r[i]=null}function a(i){function s(){n(i)}return Object.freeze({unsubscribe:s})}return t.isDeleted=()=>!!e.deleted,t.modified=i=>{if(e.deleted){ne("instance deleted - cannot call any method");return}i&&i<t.getMTime()||(e.mtime=++ei,r.forEach(s=>s&&s(t)))},t.onModified=i=>{if(e.deleted)return ne("instance deleted - cannot call any method"),null;const s=r.length;return r.push(i),a(s)},t.getMTime=()=>e.mtime,t.isA=i=>{let s=e.classHierarchy.length;for(;s--;)if(e.classHierarchy[s]===i)return!0;return!1},t.getClassName=function(){let i=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;return e.classHierarchy[e.classHierarchy.length-1-i]},t.set=function(){let i=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},s=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1,o=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1,c=!1;return Object.keys(i).forEach(u=>{const g=o?null:t[`set${da(u)}`];g&&Array.isArray(i[u])&&g.length>1?c=g(...i[u])||c:g?c=g(i[u])||c:(["mtime"].indexOf(u)===-1&&!s&&rr(`Warning: Set value to model directly ${u}, ${i[u]}`),c=e[u]!==i[u]||c,e[u]=i[u])}),c},t.get=function(){for(var i=arguments.length,s=new Array(i),o=0;o<i;o++)s[o]=arguments[o];if(!s.length)return e;const c={};return s.forEach(u=>{c[u]=e[u]}),c},t.getReferenceByName=i=>e[i],t.delete=()=>{Object.keys(e).forEach(i=>delete e[i]),r.forEach((i,s)=>n(s)),e.deleted=!0},t.getState=()=>{if(e.deleted)return null;const i={...e,vtkClass:t.getClassName()};Object.keys(i).forEach(o=>{i[o]===null||i[o]===void 0||o[0]==="_"?delete i[o]:i[o].isA?i[o]=i[o].getState():Array.isArray(i[o])?i[o]=i[o].map(Zo):Xl(i[o])&&(i[o]=Array.from(i[o]))});const s={};return Object.keys(i).sort().forEach(o=>{s[o]=i[o]}),s.mtime&&delete s.mtime,s},t.shallowCopy=function(i){let s=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;if(i.getClassName()!==t.getClassName())throw new Error(`Cannot ShallowCopy ${i.getClassName()} into ${t.getClassName()}`);const o=i.get(),c=Object.keys(e).sort();Object.keys(o).sort().forEach(g=>{const f=c.indexOf(g);f===-1?s&&Pr(`add ${g} in shallowCopy`):c.splice(f,1),e[g]=o[g]}),c.length&&s&&Pr(`Untouched keys: ${c.join(", ")}`),t.modified()},t.toJSON=function(){return t.getState()},t}const ql={object(t,e,r){return function(){return{...e[r.name]}}}};function Ke(t,e,r){r.forEach(n=>{if(typeof n=="object"){const a=ql[n.type];a?t[`get${de(n.name)}`]=a(t,e,n):t[`get${de(n.name)}`]=()=>e[n.name]}else t[`get${de(n)}`]=()=>e[n]})}const Jo={enum(t,e,r){const n=`_on${de(r.name)}Changed`;return a=>{var i;if(typeof a=="string"){if(r.enum[a]!==void 0)return e[r.name]!==r.enum[a]?(e[r.name]=r.enum[a],t.modified(),!0):!1;throw ne(`Set Enum with invalid argument ${r}, ${a}`),new RangeError("Set Enum with invalid string argument")}if(typeof a=="number"){if(e[r.name]!==a){if(Object.keys(r.enum).map(s=>r.enum[s]).indexOf(a)!==-1){const s=e[r.name];return e[r.name]=a,(i=e[n])==null||i.call(e,t,e,a,s),t.modified(),!0}throw ne(`Set Enum outside numeric range ${r}, ${a}`),new RangeError("Set Enum outside numeric range")}return!1}throw ne(`Set Enum with invalid argument (String/Number) ${r}, ${a}`),new TypeError("Set Enum with invalid argument (String/Number)")}},object(t,e,r){var a;((a=r.params)==null?void 0:a.length)===1&&rr('Setter of type "object" with a single "param" field is not supported');const n=`_on${de(r.name)}Changed`;return function(){var u,g;for(var i=arguments.length,s=new Array(i),o=0;o<i;o++)s[o]=arguments[o];let c;if(s.length>1&&((u=r.params)!=null&&u.length)?c=r.params.reduce((f,l,p)=>Object.assign(f,{[l]:s[p]}),{}):c=s[0],!No(e[r.name],c)){const f=e[r.name];return e[r.name]=c,(g=e[n])==null||g.call(e,t,e,c,f),t.modified(),!0}return!1}}};function Ds(t){if(typeof t=="object"){const e=Jo[t.type];if(e)return(r,n)=>e(r,n,t);throw ne(`No setter for field ${t}`),new TypeError("No setter for field")}return function(r,n){const a=`_on${de(t)}Changed`;return function(s){var o;if(n.deleted)return ne("instance deleted - cannot call any method"),!1;if(n[t]!==s){const c=n[t.name];return n[t]=s,(o=n[a])==null||o.call(n,r,n,s,c),r.modified(),!0}return!1}}}function ir(t,e,r){r.forEach(n=>{typeof n=="object"?t[`set${de(n.name)}`]=Ds(n)(t,e):t[`set${de(n)}`]=Ds(n)(t,e)})}function Me(t,e,r){Ke(t,e,r),ir(t,e,r)}function sr(t,e,r){r.forEach(n=>{t[`get${de(n)}`]=()=>e[n]?Array.from(e[n]):e[n],t[`get${de(n)}ByReference`]=()=>e[n]})}function Li(t,e,r,n){let a=arguments.length>4&&arguments[4]!==void 0?arguments[4]:void 0;r.forEach(i=>{if(e[i]&&n&&e[i].length!==n)throw new RangeError(`Invalid initial number of values for array (${i})`);const s=`_on${de(i)}Changed`;t[`set${de(i)}`]=function(){var p;if(e.deleted)return ne("instance deleted - cannot call any method"),!1;for(var o=arguments.length,c=new Array(o),u=0;u<o;u++)c[u]=arguments[u];let g=c,f,l=!1;if(g.length===1&&(g[0]==null||g[0].length>=0)&&(g=g[0],l=!0),g==null)f=e[i]!==g;else{if(n&&g.length!==n)if(g.length<n&&a!==void 0)for(g=Array.from(g),l=!1;g.length<n;)g.push(a);else throw new RangeError(`Invalid number of values for array setter (${i})`);f=e[i]==null||e[i].length!==g.length;for(let d=0;!f&&d<g.length;++d)f=e[i][d]!==g[d];f&&l&&(g=Array.from(g))}if(f){const d=e[i.name];e[i]=g,(p=e[s])==null||p.call(e,t,e,g,d),t.modified()}return f},t[`set${de(i)}From`]=o=>{const c=e[i];o.forEach((u,g)=>{c[g]=u})}})}function Fi(t,e,r,n){let a=arguments.length>4&&arguments[4]!==void 0?arguments[4]:void 0;sr(t,e,r),Li(t,e,r,n,a)}function or(t,e,r){for(let n=0;n<r.length;n++){const a=r[n];e[a]!==void 0&&(e[`_${a}`]=e[a],delete e[a])}}function ki(t,e,r,n){e.inputData?e.inputData=e.inputData.map(Ze):e.inputData=[],e.inputConnection?e.inputConnection=e.inputConnection.map(Ze):e.inputConnection=[],e.output?e.output=e.output.map(Ze):e.output=[],e.inputArrayToProcess?e.inputArrayToProcess=e.inputArrayToProcess.map(Ze):e.inputArrayToProcess=[],e.numberOfInputs=r;function a(p){let d=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0;if(e.deleted){ne("instance deleted - cannot call any method");return}if(d>=e.numberOfInputs){ne(`algorithm ${t.getClassName()} only has ${e.numberOfInputs} input ports. To add more input ports, use addInputData()`);return}(e.inputData[d]!==p||e.inputConnection[d])&&(e.inputData[d]=p,e.inputConnection[d]=null,t.modified&&t.modified())}function i(){let p=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;return e.inputConnection[p]&&(e.inputData[p]=e.inputConnection[p]()),e.inputData[p]}function s(p){let d=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0;if(e.deleted){ne("instance deleted - cannot call any method");return}if(d>=e.numberOfInputs){let h=`algorithm ${t.getClassName()} only has `;h+=`${e.numberOfInputs}`,h+=" input ports. To add more input ports, use addInputConnection()",ne(h);return}e.inputData[d]=null,e.inputConnection[d]=p}function o(){let p=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;return e.inputConnection[p]}function c(){let p=e.numberOfInputs;for(;p&&!e.inputData[p-1]&&!e.inputConnection[p-1];)p--;return p===e.numberOfInputs&&e.numberOfInputs++,p}function u(p){if(e.deleted){ne("instance deleted - cannot call any method");return}s(p,c())}function g(p){if(e.deleted){ne("instance deleted - cannot call any method");return}a(p,c())}function f(){let p=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;return e.deleted?(ne("instance deleted - cannot call any method"),null):(t.shouldUpdate()&&t.update(),e.output[p])}t.shouldUpdate=()=>{var T,v;const p=t.getMTime();let d=1/0,h=n;for(;h--;){if(!e.output[h]||e.output[h].isDeleted())return!0;const C=e.output[h].getMTime();if(C<p)return!0;C<d&&(d=C)}for(h=e.numberOfInputs;h--;)if((T=e.inputConnection[h])!=null&&T.filter.shouldUpdate()||((v=t.getInputData(h))==null?void 0:v.getMTime())>d)return!0;return!1};function l(){let p=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;const d=()=>f(p);return d.filter=t,d}if(e.numberOfInputs){let p=e.numberOfInputs;for(;p--;)e.inputData.push(null),e.inputConnection.push(null);t.setInputData=a,t.setInputConnection=s,t.addInputData=g,t.addInputConnection=u,t.getInputData=i,t.getInputConnection=o}n&&(t.getOutputData=f,t.getOutputPort=l),t.update=()=>{const p=[];if(e.numberOfInputs){let d=0;for(;d<e.numberOfInputs;)p[d]=t.getInputData(d),d++}t.shouldUpdate()&&t.requestData&&t.requestData(p,e.output)},t.getNumberOfInputPorts=()=>e.numberOfInputs,t.getNumberOfOutputPorts=()=>n||e.output.length,t.getInputArrayToProcess=p=>{const d=e.inputArrayToProcess[p],h=e.inputData[p];return d&&h?h[`get${d.fieldAssociation}`]().getArray(d.arrayName):null},t.setInputArrayToProcess=function(p,d,h){let T=arguments.length>3&&arguments[3]!==void 0?arguments[3]:"Scalars";for(;e.inputArrayToProcess.length<p;)e.inputArrayToProcess.push(null);e.inputArrayToProcess[p]={arrayName:d,fieldAssociation:h,attributeType:T}}}const Ni=Symbol("Event abort");function Qo(t,e,r){const n=[],a=t.delete;let i=1;function s(u){for(let g=0;g<n.length;++g){const[f]=n[g];if(f===u){n.splice(g,1);return}}}function o(u){function g(){s(u)}return Object.freeze({unsubscribe:g})}function c(){if(e.deleted){ne("instance deleted - cannot call any method");return}const u=n.slice();for(let g=0;g<u.length;++g){const[,f,l]=u[g];if(f){if(l<0)setTimeout(()=>f.apply(t,arguments),1-l);else if(f.apply(t,arguments)===Ni)break}}}t[`invoke${de(r)}`]=c,t[`on${de(r)}`]=function(u){let g=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0;if(!u.apply)return console.error(`Invalid callback for event ${r}`),null;if(e.deleted)return ne("instance deleted - cannot call any method"),null;const f=i++;return n.push([f,u,g]),n.sort((l,p)=>p[2]-l[2]),o(f)},t.delete=()=>{a(),n.forEach(u=>{let[g]=u;return s(g)})}}function ye(t,e){const r=function(){let n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};const a={},i={};return t(i,a,n),Object.freeze(i)};return e&&Ze.register(e,r),r}function cr(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];return function(){for(var n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];return e.filter(s=>!!s).map(s=>s(...a))}}function _i(t){return t&&t.isA&&t.isA("vtkObject")}function Jr(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:[],n=arguments.length>3&&arguments[3]!==void 0?arguments[3]:[];if(_i(t)){if(n.indexOf(t)>=0)return r;n.push(t);const a=e(t);a!==void 0&&r.push(a);const i=t.get();Object.keys(i).forEach(s=>{const o=i[s];Array.isArray(o)?o.forEach(c=>{Jr(c,e,r,n)}):Jr(o,e,r,n)})}return r}function Io(t,e,r){var n=this;let a;const i=function(){for(var s=arguments.length,o=new Array(s),c=0;c<s;c++)o[c]=arguments[c];const u=n,g=()=>{a=null,r||t.apply(u,o)},f=r&&!a;clearTimeout(a),a=setTimeout(g,e),f&&t.apply(u,o)};return i.cancel=()=>clearTimeout(a),i}function ec(t,e){let r=!1,n=null;function a(){r=!1,n!==null&&(i(...n),n=null)}function i(){for(var s=arguments.length,o=new Array(s),c=0;c<s;c++)o[c]=arguments[c];if(r){n=o;return}r=!0,t(...o),setTimeout(a,e)}return i}function Gi(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};e.keystore=Object.assign(e.keystore||{},r),t.setKey=(n,a)=>{e.keystore[n]=a},t.getKey=n=>e.keystore[n],t.getAllKeys=()=>Object.keys(e.keystore),t.deleteKey=n=>delete e.keystore[n],t.clearKeystore=()=>t.getAllKeys().forEach(n=>delete e.keystore[n])}let Zl=1;const vr="__root__";function tc(t,e){Gi(t,e);const r=t.delete;e.proxyId=`${Zl++}`,e.ui=JSON.parse(JSON.stringify(e.ui||[])),Ke(t,e,["proxyId","proxyGroup","proxyName"]),Me(t,e,["proxyManager"]);const n={},a={};function i(u,g){a[g]||(a[g]=[]);const f=a[g];for(let l=0;l<u.length;l++)f.push(u[l].name),n[u[l].name]=u[l],u[l].children&&u[l].children.length&&i(u[l].children,u[l].name)}i(e.ui,vr),t.updateUI=u=>{e.ui=JSON.parse(JSON.stringify(u||[])),Object.keys(n).forEach(g=>delete n[g]),Object.keys(a).forEach(g=>delete a[g]),i(e.ui,vr),t.modified()};function s(){let u=arguments.length>0&&arguments[0]!==void 0?arguments[0]:vr;return a[u]}t.updateProxyProperty=(u,g)=>{const f=n[u];f?Object.assign(f,g):n[u]={...g}},t.activate=()=>{if(e.proxyManager){const u=`setActive${de(t.getProxyGroup().slice(0,-1))}`;e.proxyManager[u]&&e.proxyManager[u](t)}},e.propertyLinkSubscribers={},t.registerPropertyLinkForGC=(u,g)=>{g in e.propertyLinkSubscribers||(e.propertyLinkSubscribers[g]=[]),e.propertyLinkSubscribers[g].push(u)},t.gcPropertyLinks=u=>{const g=e.propertyLinkSubscribers[u]||[];for(;g.length;)g.pop().unbind(t)},e.propertyLinkMap={},t.getPropertyLink=function(u){let g=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;if(e.propertyLinkMap[u])return e.propertyLinkMap[u];let f=null;const l=[];let p=0,d=!1;function h(x){let R=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;if(d)return null;const O=[];let w=null;for(p=l.length;p--;){const E=l[p];E.instance===x?w=E:O.push(E)}if(!w)return null;const m=w.instance[`get${de(w.propertyName)}`]();if(!Al(m,f)||R){for(f=m,d=!0;O.length;){const E=O.pop();E.instance.set({[E.propertyName]:f})}d=!1}return e.propertyLinkMap[u].persistent&&(e.propertyLinkMap[u].value=m),m}function T(x,R){const O=[];for(p=l.length;p--;){const w=l[p];w.instance===x&&(w.propertyName===R||R===void 0)&&(w.subscription.unsubscribe(),O.push(p))}for(;O.length;)l.splice(O.pop(),1)}function v(x,R){let O=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1;const w=x.onModified(h),m=l[0];return l.push({instance:x,propertyName:R,subscription:w}),O&&(e.propertyLinkMap[u].persistent&&e.propertyLinkMap[u].value!==void 0?x.set({[R]:e.propertyLinkMap[u].value}):m&&h(m.instance,!0)),{unsubscribe:()=>T(x,R)}}function C(){for(;l.length;)l.pop().subscription.unsubscribe()}const S={bind:v,unbind:T,unsubscribe:C,persistent:g};return e.propertyLinkMap[u]=S,S};function o(){let u=arguments.length>0&&arguments[0]!==void 0?arguments[0]:vr;const g=[],f=e.proxyId,l=s(u)||[];for(let p=0;p<l.length;p++){const d=l[p],h=t[`get${de(d)}`],T=h?h():void 0,v={id:f,name:d,value:T},C=o(d);C.length&&(v.children=C),g.push(v)}return g}t.listPropertyNames=()=>o().map(u=>u.name),t.getPropertyByName=u=>o().find(g=>g.name===u),t.getPropertyDomainByName=u=>(n[u]||{}).domain,t.getProxySection=()=>({id:e.proxyId,name:e.proxyGroup,ui:e.ui,properties:o()}),t.delete=()=>{const u=Object.keys(e.propertyLinkMap);let g=u.length;for(;g--;)e.propertyLinkMap[u[g]].unsubscribe();Object.keys(e.propertyLinkSubscribers).forEach(t.gcPropertyLinks),r()},t.getState=()=>null;function c(){if(e.links)for(let u=0;u<e.links.length;u++){const{link:g,property:f,persistent:l,updateOnBind:p,type:d}=e.links[u];if(d==="application"){const h=e.proxyManager.getPropertyLink(g,l);t.registerPropertyLinkForGC(h,"application"),h.bind(t,f,p)}}}Vi(c)}function nc(t,e,r){const n=t.delete,a=[],i=Object.keys(r);let s=i.length;for(;s--;){const o=i[s],{modelKey:c,property:u,modified:g=!0}=r[o],f=de(u),l=de(o);t[`get${l}`]=e[c][`get${f}`],t[`set${l}`]=e[c][`set${f}`],g&&a.push(e[c].onModified(t.modified))}t.delete=()=>{for(;a.length;)a.pop().unsubscribe();n()}}function rc(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},n=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{};e.this=t;function a(o){const c=Object.keys(o);let u=c.length;for(;u--;){const g=c[u];e[g].set(o[g])}}const i=Object.keys(n);let s=i.length;for(;s--;){const o=i[s];e[o]=n[o];const c=r[o];t[`set${de(o)}`]=u=>{if(u!==e[o]){e[o]=u;const g=c[u];a(g),t.modified()}}}i.length&&Ke(t,e,i)}const Vs=10,Ls=40,Fs=800;function ac(t){let e=0,r=0,n=0,a=0;return"detail"in t&&(r=t.detail),"wheelDelta"in t&&(r=-t.wheelDelta/120),"wheelDeltaY"in t&&(r=-t.wheelDeltaY/120),"wheelDeltaX"in t&&(e=-t.wheelDeltaX/120),"axis"in t&&t.axis===t.HORIZONTAL_AXIS&&(e=r,r=0),n=e*Vs,a=r*Vs,"deltaY"in t&&(a=t.deltaY),"deltaX"in t&&(n=t.deltaX),(n||a)&&t.deltaMode&&(t.deltaMode===1?(n*=Ls,a*=Ls):(n*=Fs,a*=Fs)),n&&!e&&(e=n<1?-1:1),a&&!r&&(r=a<1?-1:1),{spinX:e,spinY:r||e,pixelX:n,pixelY:a||n}}var y={algo:ki,capitalize:da,chain:cr,debounce:Io,enumToString:Yl,event:Qo,EVENT_ABORT:Ni,formatBytesToProperUnit:Ao,formatNumbersWithThousandSeparator:Yo,get:Ke,getArray:sr,getCurrentGlobalMTime:bl,getStateArrayMapFunc:Zo,isVtkObject:_i,keystore:Gi,measurePromiseExecution:Po,moveToProtected:or,newInstance:ye,newTypedArray:ar,newTypedArrayFrom:ha,normalizeWheel:ac,obj:xe,proxy:tc,proxyPropertyMapping:nc,proxyPropertyState:rc,safeArrays:qo,set:ir,setArray:Li,setGet:Me,setGetArray:Fi,setImmediate:Vi,setLoggerFunction:Ho,throttle:ec,traverseInstanceTree:Jr,TYPED_ARRAYS:Ee,uncapitalize:Xo,VOID:$o,vtkDebugMacro:Pr,vtkErrorMacro:ne,vtkInfoMacro:bo,vtkLogMacro:jo,vtkOnceErrorMacro:Ko,vtkWarningMacro:rr,objectSetterMap:Jo},We=Object.freeze({__proto__:null,VOID:$o,setLoggerFunction:Ho,vtkLogMacro:jo,vtkInfoMacro:bo,vtkDebugMacro:Pr,vtkErrorMacro:ne,vtkWarningMacro:rr,vtkOnceErrorMacro:Ko,TYPED_ARRAYS:Ee,newTypedArray:ar,newTypedArrayFrom:ha,capitalize:da,_capitalize:de,uncapitalize:Xo,formatBytesToProperUnit:Ao,formatNumbersWithThousandSeparator:Yo,setImmediateVTK:Vi,measurePromiseExecution:Po,obj:xe,get:Ke,set:ir,setGet:Me,getArray:sr,setArray:Li,setGetArray:Fi,moveToProtected:or,algo:ki,EVENT_ABORT:Ni,event:Qo,newInstance:ye,chain:cr,isVtkObject:_i,traverseInstanceTree:Jr,debounce:Io,throttle:ec,keystore:Gi,proxy:tc,proxyPropertyMapping:nc,proxyPropertyState:rc,normalizeWheel:ac,default:y});const{vtkErrorMacro:Pl}=y,Jl=["Build","Render"];function Ql(t,e){e.classHierarchy.push("vtkViewNode"),t.build=n=>{},t.render=n=>{},t.traverse=n=>{const a=n.getTraverseOperation(),i=t[a];if(i){i(n);return}t.apply(n,!0);for(let s=0;s<e.children.length;s++)e.children[s].traverse(n);t.apply(n,!1)},t.apply=(n,a)=>{const i=t[n.getOperation()];i&&i(a,n)},t.getViewNodeFor=n=>{if(e.renderable===n)return t;for(let a=0;a<e.children.length;++a){const s=e.children[a].getViewNodeFor(n);if(s)return s}},t.getFirstAncestorOfType=n=>e._parent?e._parent.isA(n)?e._parent:e._parent.getFirstAncestorOfType(n):null,t.getLastAncestorOfType=n=>{if(!e._parent)return null;const a=e._parent.getLastAncestorOfType(n);return a||(e._parent.isA(n)?e._parent:null)},t.addMissingNode=n=>{if(!n)return;const a=e._renderableChildMap.get(n);if(a!==void 0)return a.setVisited(!0),a;const i=t.createViewNode(n);if(i)return i.setParent(t),i.setVisited(!0),e._renderableChildMap.set(n,i),e.children.push(i),i},t.addMissingNodes=n=>{if(!(!n||!n.length))for(let a=0;a<n.length;++a){const i=n[a];t.addMissingNode(i)}},t.addMissingChildren=n=>{if(!(!n||!n.length))for(let a=0;a<n.length;++a){const i=n[a];if(e.children.indexOf(i)===-1){i.setParent(t),e.children.push(i);const o=i.getRenderable();o&&e._renderableChildMap.set(o,i)}i.setVisited(!0)}},t.removeNode=n=>{const a=e.children.findIndex(s=>s===n);if(a<0)return!1;const i=n.getRenderable();return i&&e._renderableChildMap.delete(i),n.delete(),e.children.splice(a,1),!0},t.prepareNodes=()=>{for(let n=0;n<e.children.length;++n)e.children[n].setVisited(!1)},t.setVisited=n=>{e.visited=n},t.removeUnusedNodes=()=>{let n=0;for(let a=0;a<e.children.length;++a){const i=e.children[a];if(i.getVisited())e.children[n++]=i,i.setVisited(!1);else{const o=i.getRenderable();o&&e._renderableChildMap.delete(o),i.delete()}}e.children.length=n},t.createViewNode=n=>{if(!e.myFactory)return Pl("Cannot create view nodes without my own factory"),null;const a=e.myFactory.createNode(n);return a&&a.setRenderable(n),a};const r=t.delete;t.delete=()=>{for(let n=0;n<e.children.length;n++)e.children[n].delete();r()}}const Il={renderable:null,myFactory:null,children:[],visited:!1};function ic(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Il,r),y.obj(t,e),y.event(t,e,"event"),e._renderableChildMap=new Map,y.get(t,e,["visited"]),y.setGet(t,e,["_parent","renderable","myFactory"]),y.getArray(t,e,["children"]),y.moveToProtected(t,e,["parent"]),Ql(t,e)}const ep=y.newInstance(ic,"vtkViewNode");var De={newInstance:ep,extend:ic,PASS_TYPES:Jl};function tp(t,e){e.overrides||(e.overrides={}),e.classHierarchy.push("vtkViewNodeFactory"),t.createNode=r=>{if(r.isDeleted())return null;let n=0,a=r.getClassName(n++),i=!1;const s=Object.keys(e.overrides);for(;a&&!i;)s.indexOf(a)!==-1?i=!0:a=r.getClassName(n++);if(!i)return null;const o=e.overrides[a]();return o.setMyFactory(t),o}}const np={};function sc(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,np,r),y.obj(t,e),tp(t,e)}const rp=y.newInstance(sc,"vtkViewNodeFactory");var ap={newInstance:rp,extend:sc};const oc=Object.create(null);function Oe(t,e){oc[t]=e}function ip(t,e){e.classHierarchy.push("vtkOpenGLViewNodeFactory")}const sp={};function cc(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,sp,r),e.overrides=oc,ap.extend(t,e,r),ip(t,e)}const op=y.newInstance(cc,"vtkOpenGLViewNodeFactory");var cp={newInstance:op,extend:cc};function up(t,e){e.classHierarchy.push("vtkOpenGLCamera"),t.buildPass=r=>{r&&(e._openGLRenderer=t.getFirstAncestorOfType("vtkOpenGLRenderer"),e._openGLRenderWindow=e._openGLRenderer.getParent(),e.context=e._openGLRenderWindow.getContext())},t.opaquePass=r=>{if(r){const n=e._openGLRenderer.getTiledSizeAndOrigin();e.context.viewport(n.lowerLeftU,n.lowerLeftV,n.usize,n.vsize),e.context.scissor(n.lowerLeftU,n.lowerLeftV,n.usize,n.vsize)}},t.translucentPass=t.opaquePass,t.zBufferPass=t.opaquePass,t.opaqueZBufferPass=t.opaquePass,t.volumePass=t.opaquePass,t.getKeyMatrices=r=>{if(r!==e.lastRenderer||e._openGLRenderWindow.getMTime()>e.keyMatrixTime.getMTime()||t.getMTime()>e.keyMatrixTime.getMTime()||r.getMTime()>e.keyMatrixTime.getMTime()||e.renderable.getMTime()>e.keyMatrixTime.getMTime()){Re(e.keyMatrices.wcvc,e.renderable.getViewMatrix()),pa(e.keyMatrices.normalMatrix,e.keyMatrices.wcvc),nr(e.keyMatrices.normalMatrix,e.keyMatrices.normalMatrix),se(e.keyMatrices.wcvc,e.keyMatrices.wcvc);const n=e._openGLRenderer.getAspectRatio();Re(e.keyMatrices.vcpc,e.renderable.getProjectionMatrix(n,-1,1)),se(e.keyMatrices.vcpc,e.keyMatrices.vcpc),ae(e.keyMatrices.wcpc,e.keyMatrices.vcpc,e.keyMatrices.wcvc),e.keyMatrixTime.modified(),e.lastRenderer=r}return e.keyMatrices}}const fp={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};function gp(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,fp,r),De.extend(t,e,r),e.keyMatrixTime={},xe(e.keyMatrixTime),e.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},Me(t,e,["context","keyMatrixTime"]),up(t,e)}const lp=ye(gp);Oe("vtkCamera",lp);const{vtkDebugMacro:pp}=We;function hp(t,e){e.classHierarchy.push("vtkOpenGLRenderer"),t.buildPass=r=>{if(r){if(!e.renderable)return;t.updateLights(),t.prepareNodes(),t.addMissingNode(e.renderable.getActiveCamera()),t.addMissingNodes(e.renderable.getViewPropsWithNestedProps()),t.removeUnusedNodes()}},t.updateLights=()=>{let r=0;const n=e.renderable.getLightsByReference();for(let a=0;a<n.length;++a)n[a].getSwitch()>0&&r++;return r||(pp("No lights are on, creating one."),e.renderable.createLight()),r},t.zBufferPass=r=>{if(r){let n=0;const a=e.context;e.renderable.getTransparent()||(e.context.clearColor(1,0,0,1),n|=a.COLOR_BUFFER_BIT),e.renderable.getPreserveDepthBuffer()||(a.clearDepth(1),n|=a.DEPTH_BUFFER_BIT,e.context.depthMask(!0));const i=t.getTiledSizeAndOrigin();a.enable(a.SCISSOR_TEST),a.scissor(i.lowerLeftU,i.lowerLeftV,i.usize,i.vsize),a.viewport(i.lowerLeftU,i.lowerLeftV,i.usize,i.vsize),a.colorMask(!0,!0,!0,!0),n&&a.clear(n),a.enable(a.DEPTH_TEST)}},t.opaqueZBufferPass=r=>t.zBufferPass(r),t.cameraPass=r=>{r&&t.clear()},t.getAspectRatio=()=>{const r=e._parent.getSizeByReference(),n=e.renderable.getViewportByReference();return r[0]*(n[2]-n[0])/((n[3]-n[1])*r[1])},t.getTiledSizeAndOrigin=()=>{const r=e.renderable.getViewportByReference(),n=[0,0,1,1],a=r[0]-n[0],i=r[1]-n[1],s=e._parent.normalizedDisplayToDisplay(a,i),o=Math.round(s[0]),c=Math.round(s[1]),u=r[2]-n[0],g=r[3]-n[1],f=e._parent.normalizedDisplayToDisplay(u,g);let l=Math.round(f[0])-o,p=Math.round(f[1])-c;return l<0&&(l=0),p<0&&(p=0),{usize:l,vsize:p,lowerLeftU:o,lowerLeftV:c}},t.clear=()=>{let r=0;const n=e.context;if(!e.renderable.getTransparent()){const i=e.renderable.getBackgroundByReference();n.clearColor(i[0],i[1],i[2],i[3]),r|=n.COLOR_BUFFER_BIT}e.renderable.getPreserveDepthBuffer()||(n.clearDepth(1),r|=n.DEPTH_BUFFER_BIT,n.depthMask(!0)),n.colorMask(!0,!0,!0,!0);const a=t.getTiledSizeAndOrigin();n.enable(n.SCISSOR_TEST),n.scissor(a.lowerLeftU,a.lowerLeftV,a.usize,a.vsize),n.viewport(a.lowerLeftU,a.lowerLeftV,a.usize,a.vsize),r&&n.clear(r),n.enable(n.DEPTH_TEST)},t.releaseGraphicsResources=()=>{e.selector!==null&&e.selector.releaseGraphicsResources(),e.renderable&&e.renderable.getViewProps().forEach(r=>{r.modified()})},t.setOpenGLRenderWindow=r=>{e._openGLRenderWindow!==r&&(t.releaseGraphicsResources(),e._openGLRenderWindow=r,e.context=null,r&&(e.context=e._openGLRenderWindow.getContext()))}}const dp={context:null,_openGLRenderWindow:null,selector:null};function Tp(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,dp,r),De.extend(t,e,r),Ke(t,e,["shaderCache"]),Me(t,e,["selector"]),or(t,e,["openGLRenderWindow"]),hp(t,e)}const vp=ye(Tp,"vtkOpenGLRenderer");Oe("vtkRenderer",vp);function yp(t,e){e.classHierarchy.push("vtkOpenGLActor"),t.buildPass=r=>{if(r){e._openGLRenderWindow=t.getLastAncestorOfType("vtkOpenGLRenderWindow"),e._openGLRenderer=t.getFirstAncestorOfType("vtkOpenGLRenderer"),e.context=e._openGLRenderWindow.getContext(),t.prepareNodes(),t.addMissingNodes(e.renderable.getTextures()),t.addMissingNode(e.renderable.getMapper()),t.removeUnusedNodes(),e.ogltextures=null,e.activeTextures=null;for(let n=0;n<e.children.length;n++){const a=e.children[n];a.isA("vtkOpenGLTexture")?(e.ogltextures||(e.ogltextures=[]),e.ogltextures.push(a)):e.oglmapper=a}}},t.traverseZBufferPass=r=>{!e.renderable||!e.renderable.getNestedVisibility()||e._openGLRenderer.getSelector()&&!e.renderable.getNestedPickable()||(t.apply(r,!0),e.oglmapper.traverse(r),t.apply(r,!1))},t.traverseOpaqueZBufferPass=r=>t.traverseOpaquePass(r),t.traverseOpaquePass=r=>{!e.renderable||!e.renderable.getNestedVisibility()||!e.renderable.getIsOpaque()||e._openGLRenderer.getSelector()&&!e.renderable.getNestedPickable()||(t.apply(r,!0),e.oglmapper.traverse(r),t.apply(r,!1))},t.traverseTranslucentPass=r=>{!e.renderable||!e.renderable.getNestedVisibility()||e.renderable.getIsOpaque()||e._openGLRenderer.getSelector()&&!e.renderable.getNestedPickable()||(t.apply(r,!0),e.oglmapper.traverse(r),t.apply(r,!1))},t.activateTextures=()=>{if(e.ogltextures){e.activeTextures=[];for(let r=0;r<e.ogltextures.length;r++){const n=e.ogltextures[r];n.render(),n.getHandle()&&e.activeTextures.push(n)}}},t.queryPass=(r,n)=>{if(r){if(!e.renderable||!e.renderable.getVisibility())return;e.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},t.zBufferPass=(r,n)=>t.opaquePass(r,n),t.opaqueZBufferPass=(r,n)=>t.opaquePass(r,n),t.opaquePass=(r,n)=>{if(r)e.context.depthMask(!0),t.activateTextures();else if(e.activeTextures)for(let a=0;a<e.activeTextures.length;a++)e.activeTextures[a].deactivate()},t.translucentPass=(r,n)=>{if(r)e.context.depthMask(e._openGLRenderer.getSelector()&&e.renderable.getNestedPickable()),t.activateTextures();else if(e.activeTextures)for(let a=0;a<e.activeTextures.length;a++)e.activeTextures[a].deactivate()},t.getKeyMatrices=()=>(e.renderable.getMTime()>e.keyMatrixTime.getMTime()&&(e.renderable.computeMatrix(),Re(e.keyMatrices.mcwc,e.renderable.getMatrix()),se(e.keyMatrices.mcwc,e.keyMatrices.mcwc),e.renderable.getIsIdentity()?ct(e.keyMatrices.normalMatrix):(pa(e.keyMatrices.normalMatrix,e.keyMatrices.mcwc),nr(e.keyMatrices.normalMatrix,e.keyMatrices.normalMatrix),mi(e.keyMatrices.normalMatrix,e.keyMatrices.normalMatrix)),e.keyMatrixTime.modified()),e.keyMatrices)}const Cp={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};function Sp(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Cp,r),De.extend(t,e,r),e.keyMatrixTime={},xe(e.keyMatrixTime,{mtime:0}),e.keyMatrices={normalMatrix:ct(new Float64Array(9)),mcwc:X(new Float64Array(16))},Me(t,e,["context"]),Ke(t,e,["activeTextures"]),yp(t,e)}const xp=ye(Sp);Oe("vtkActor",xp);function wp(t,e){e.classHierarchy.push("vtkOpenGLActor2D"),t.buildPass=r=>{if(r){if(!e.renderable)return;e._openGLRenderWindow=t.getLastAncestorOfType("vtkOpenGLRenderWindow"),e._openGLRenderer=t.getFirstAncestorOfType("vtkOpenGLRenderer"),e.context=e._openGLRenderWindow.getContext(),t.prepareNodes(),t.addMissingNodes(e.renderable.getTextures()),t.addMissingNode(e.renderable.getMapper()),t.removeUnusedNodes(),e.ogltextures=null,e.activeTextures=null;for(let n=0;n<e.children.length;n++){const a=e.children[n];a.isA("vtkOpenGLTexture")?(e.ogltextures||(e.ogltextures=[]),e.ogltextures.push(a)):e.oglmapper=a}}},t.queryPass=(r,n)=>{if(r){if(!e.renderable||!e.renderable.getVisibility())return;n.incrementOverlayActorCount()}},t.traverseOpaquePass=r=>{!e.oglmapper||!e.renderable||!e.renderable.getNestedVisibility()||!e.renderable.getIsOpaque()||e._openGLRenderer.getSelector()&&!e.renderable.getNestedPickable()||(t.apply(r,!0),e.oglmapper.traverse(r),t.apply(r,!1))},t.traverseTranslucentPass=r=>{!e.oglmapper||!e.renderable||!e.renderable.getNestedVisibility()||e.renderable.getIsOpaque()||e._openGLRenderer.getSelector()&&!e.renderable.getNestedPickable()||(t.apply(r,!0),e.oglmapper.traverse(r),t.apply(r,!1))},t.traverseOverlayPass=r=>{!e.oglmapper||!e.renderable||!e.renderable.getNestedVisibility()||e._openGLRenderer.getSelector()&&!e.renderable.getNestedPickable||(t.apply(r,!0),e.oglmapper.traverse(r),t.apply(r,!1))},t.activateTextures=()=>{if(e.ogltextures){e.activeTextures=[];for(let r=0;r<e.ogltextures.length;r++){const n=e.ogltextures[r];n.render(),n.getHandle()&&e.activeTextures.push(n)}}},t.opaquePass=(r,n)=>{if(r)e.context.depthMask(!0),t.activateTextures();else if(e.activeTextures)for(let a=0;a<e.activeTextures.length;a++)e.activeTextures[a].deactivate()},t.translucentPass=(r,n)=>{if(r)e.context.depthMask(!1),t.activateTextures();else if(e.activeTextures)for(let a=0;a<e.activeTextures.length;a++)e.activeTextures[a].deactivate()},t.overlayPass=(r,n)=>{if(r)e.context.depthMask(!0),t.activateTextures();else if(e.activeTextures)for(let a=0;a<e.activeTextures.length;a++)e.activeTextures[a].deactivate()}}const Rp={context:null,activeTextures:null};function Mp(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Rp,r),De.extend(t,e,r),Me(t,e,["context"]),Ke(t,e,["activeTextures"]),wp(t,e)}const Op=ye(Mp);Oe("vtkActor2D",Op);const Kn={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var uc={ObjectType:Kn};const{ObjectType:Wr}=uc,mp={};function Ep(t,e){e.classHierarchy.push("vtkOpenGLBufferObject");function r(o){switch(o){case Wr.ELEMENT_ARRAY_BUFFER:return e.context.ELEMENT_ARRAY_BUFFER;case Wr.TEXTURE_BUFFER:if("TEXTURE_BUFFER"in e.context)return e.context.TEXTURE_BUFFER;case Wr.ARRAY_BUFFER:default:return e.context.ARRAY_BUFFER}}let n=null,a=null,i=!0,s="";t.getType=()=>n,t.setType=o=>{n=o},t.getHandle=()=>a,t.isReady=()=>i===!1,t.generateBuffer=o=>{const c=r(o);return a===null&&(a=e.context.createBuffer(),n=o),r(n)===c},t.upload=(o,c)=>t.generateBuffer(c)?(e.context.bindBuffer(r(n),a),e.context.bufferData(r(n),o,e.context.STATIC_DRAW),e.allocatedGPUMemoryInBytes=o.length*o.BYTES_PER_ELEMENT,i=!1,!0):(s="Trying to upload array buffer to incompatible buffer.",!1),t.bind=()=>a?(e.context.bindBuffer(r(n),a),!0):!1,t.release=()=>a?(e.context.bindBuffer(r(n),null),!0):!1,t.releaseGraphicsResources=()=>{a!==null&&(e.context.bindBuffer(r(n),null),e.context.deleteBuffer(a),a=null,e.allocatedGPUMemoryInBytes=0)},t.setOpenGLRenderWindow=o=>{e._openGLRenderWindow!==o&&(t.releaseGraphicsResources(),e._openGLRenderWindow=o,e.context=null,o&&(e.context=e._openGLRenderWindow.getContext()))},t.getError=()=>s}const Dp={objectType:Wr.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function fc(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Dp,r),y.obj(t,e),y.get(t,e,["_openGLRenderWindow","allocatedGPUMemoryInBytes"]),y.moveToProtected(t,e,["openGLRenderWindow"]),Ep(t,e)}const Vp=y.newInstance(fc);var Qt={newInstance:Vp,extend:fc,...mp,...uc};const gc={FLAT:0,GOURAUD:1,PHONG:2},me={POINTS:0,WIREFRAME:1,SURFACE:2},Lp=gc;var lc={Shading:gc,Representation:me,Interpolation:Lp};const{vtkErrorMacro:ks}=y;function Fp(t,e){const r=new Float64Array(3);_o(r,e);const n=new Float64Array(16);return yl(n,Pn(),t,r),n}function kp(t,e){return t===null||e===null?!1:!(Hn(t,[0,0,0])&&Hn(e,[1,1,1]))}function Np(t,e){e.classHierarchy.push("vtkOpenGLCellArrayBufferObject"),t.setType(Kn.ARRAY_BUFFER),t.createVBO=function(r,n,a,i){let s=arguments.length>4&&arguments[4]!==void 0?arguments[4]:null;if(!r.getData()||!r.getData().length)return e.elementCount=0,0;e.blockSize=3,e.vertexOffset=0,e.normalOffset=0,e.tCoordOffset=0,e.tCoordComponents=0,e.colorComponents=0,e.colorOffset=0,e.customData=[];const o=i.points.getData();let c=null,u=null,g=null;const f=i.colors?i.colors.getNumberOfComponents():0,l=i.tcoords?i.tcoords.getNumberOfComponents():0;i.normals&&(e.normalOffset=4*e.blockSize,e.blockSize+=3,c=i.normals.getData()),i.customAttributes&&i.customAttributes.forEach(k=>{k&&(e.customData.push({data:k.getData(),offset:4*e.blockSize,components:k.getNumberOfComponents(),name:k.getName()}),e.blockSize+=k.getNumberOfComponents())}),i.tcoords&&(e.tCoordOffset=4*e.blockSize,e.tCoordComponents=l,e.blockSize+=l,u=i.tcoords.getData()),i.colors?(e.colorComponents=i.colors.getNumberOfComponents(),e.colorOffset=0,g=i.colors.getData(),e.colorBO||(e.colorBO=Qt.newInstance()),e.colorBO.setOpenGLRenderWindow(e._openGLRenderWindow)):e.colorBO=null,e.stride=4*e.blockSize;let p=0,d=0,h=0,T=0,v=0,C=0,S;const x={anythingToPoints(k,L,W,H){for(let $=0;$<k;++$)S(L[W+$],H)},linesToWireframe(k,L,W,H){for(let $=0;$<k-1;++$)S(L[W+$],H),S(L[W+$+1],H)},polysToWireframe(k,L,W,H){if(k>2)for(let $=0;$<k;++$)S(L[W+$],H),S(L[W+($+1)%k],H)},stripsToWireframe(k,L,W,H){if(k>2){for(let $=0;$<k-1;++$)S(L[W+$],H),S(L[W+$+1],H);for(let $=0;$<k-2;$++)S(L[W+$],H),S(L[W+$+2],H)}},polysToSurface(k,L,W,H){for(let $=0;$<k-2;$++)S(L[W+0],H),S(L[W+$+1],H),S(L[W+$+2],H)},stripsToSurface(k,L,W,H){for(let $=0;$<k-2;$++)S(L[W+$],H),S(L[W+$+1+$%2],H),S(L[W+$+1+($+1)%2],H)}},R={anythingToPoints(k,L){return k},linesToWireframe(k,L){return k>1?(k-1)*2:0},polysToWireframe(k,L){return k>2?k*2:0},stripsToWireframe(k,L){return k>2?k*4-6:0},polysToSurface(k,L){return k>2?(k-2)*3:0},stripsToSurface(k,L,W){return k>2?(k-2)*3:0}};let O=null,w=null;a===me.POINTS||n==="verts"?(O=x.anythingToPoints,w=R.anythingToPoints):a===me.WIREFRAME||n==="lines"?(O=x[`${n}ToWireframe`],w=R[`${n}ToWireframe`]):(O=x[`${n}ToSurface`],w=R[`${n}ToSurface`]);const m=r.getData(),E=m.length;let M=0;for(let k=0;k<E;)M+=w(m[k],m),k+=m[k]+1;let D=null;const N=new Float32Array(M*e.blockSize);g&&(D=new Uint8Array(M*4));let G=0,_=0,B=0,F=0;for(let k=0;k<3;++k){const L=i.points.getRange(k),W=L[1]-L[0];B+=W*W;const H=.5*(L[1]+L[0]);F+=H*H}if(B>0&&(Math.abs(F)/B>1e6||Math.abs(Math.log10(B))>3||B===0&&F>1e6)){const k=new Float64Array(3),L=new Float64Array(3);for(let W=0;W<3;++W){const H=i.points.getRange(W),$=H[1]-H[0];k[W]=.5*(H[1]+H[0]),L[W]=$>0?1/$:1}t.setCoordShiftAndScale(k,L)}else e.coordShiftAndScaleEnabled===!0&&t.setCoordShiftAndScale(null,null);if(s)if(!s.points&&!s.cells)s.points=new Int32Array(M),s.cells=new Int32Array(M);else{const k=new Int32Array(M+s.points.length);k.set(s.points),s.points=k;const L=new Int32Array(M+s.cells.length);L.set(s.cells),s.cells=L}let U=i.vertexOffset;S=function(L,W){if(s&&(s.points[U]=L,s.cells[U]=C+i.cellOffset),++U,p=L*3,e.coordShiftAndScaleEnabled?(N[G++]=(o[p++]-e.coordShift[0])*e.coordScale[0],N[G++]=(o[p++]-e.coordShift[1])*e.coordScale[1],N[G++]=(o[p++]-e.coordShift[2])*e.coordScale[2]):(N[G++]=o[p++],N[G++]=o[p++],N[G++]=o[p++]),c!==null&&(i.haveCellNormals?d=(C+i.cellOffset)*3:d=L*3,N[G++]=c[d++],N[G++]=c[d++],N[G++]=c[d++]),e.customData.forEach(H=>{v=L*H.components;for(let $=0;$<H.components;++$)N[G++]=H.data[v++]}),u!==null){i.useTCoordsPerCell?h=W*l:h=L*l;for(let H=0;H<l;++H)N[G++]=u[h++]}g!==null&&(i.haveCellScalars?T=(C+i.cellOffset)*f:T=L*f,D[_++]=g[T++],D[_++]=g[T++],D[_++]=g[T++],D[_++]=f===4?g[T++]:255)};for(let k=0;k<E;k+=m[k]+1,C++)O(m[k],m,k+1,C+i.cellOffset);return e.elementCount=M,t.upload(N,Kn.ARRAY_BUFFER),e.colorBO&&(e.colorBOStride=4,e.colorBO.upload(D,Kn.ARRAY_BUFFER)),C},t.setCoordShiftAndScale=(r,n)=>{if(r!==null&&(r.constructor!==Float64Array||r.length!==3)){ks("Wrong type for coordShift, expected vec3 or null");return}if(n!==null&&(n.constructor!==Float64Array||n.length!==3)){ks("Wrong type for coordScale, expected vec3 or null");return}(e.coordShift===null||r===null||!Rs(r,e.coordShift))&&(e.coordShift=r),(e.coordScale===null||n===null||!Rs(n,e.coordScale))&&(e.coordScale=n),e.coordShiftAndScaleEnabled=kp(e.coordShift,e.coordScale),e.coordShiftAndScaleEnabled?e.inverseShiftAndScaleMatrix=Fp(e.coordShift,e.coordScale):e.inverseShiftAndScaleMatrix=null}}const _p={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function pc(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,_p,r),Qt.extend(t,e,r),y.setGet(t,e,["colorBO","elementCount","stride","colorBOStride","vertexOffset","normalOffset","tCoordOffset","tCoordComponents","colorOffset","colorComponents","customData"]),y.get(t,e,["coordShift","coordScale","coordShiftAndScaleEnabled","inverseShiftAndScaleMatrix"]),Np(t,e)}const Gp=y.newInstance(pc);var Up={newInstance:Gp,extend:pc};const{vtkErrorMacro:Bp}=y;function Wp(t,e){e.classHierarchy.push("vtkShader"),t.compile=()=>{let r=e.context.VERTEX_SHADER;if(!e.source||!e.source.length||e.shaderType==="Unknown")return!1;switch(e.handle!==0&&(e.context.deleteShader(e.handle),e.handle=0),e.shaderType){case"Fragment":r=e.context.FRAGMENT_SHADER;break;case"Vertex":default:r=e.context.VERTEX_SHADER;break}if(e.handle=e.context.createShader(r),e.context.shaderSource(e.handle,e.source),e.context.compileShader(e.handle),!e.context.getShaderParameter(e.handle,e.context.COMPILE_STATUS)){const a=e.context.getShaderInfoLog(e.handle);return Bp(`Error compiling shader '${e.source}': ${a}`),e.context.deleteShader(e.handle),e.handle=0,!1}return!0},t.cleanup=()=>{e.shaderType==="Unknown"||e.handle===0||(e.context.deleteShader(e.handle),e.handle=0,e.dirty=!0)}}const $p={shaderType:"Unknown",source:"",error:"",handle:0,dirty:!1,context:null};function hc(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,$p,r),y.obj(t,e),y.setGet(t,e,["shaderType","source","error","handle","context"]),Wp(t,e)}const zp=y.newInstance(hc,"vtkShader");var La={newInstance:zp,extend:hc};const{vtkErrorMacro:tt}=y;function Hp(t,e,r,n){const a=typeof r=="string"?r:r.join(`
`),i=n===!1?e:new RegExp(e,"g"),s=t.replace(i,a);return{replace:s!==a,result:s}}function jp(t,e){e.classHierarchy.push("vtkShaderProgram"),t.compileShader=()=>e.vertexShader.compile()?e.fragmentShader.compile()?!t.attachShader(e.vertexShader)||!t.attachShader(e.fragmentShader)?(tt(e.error),0):t.link()?(t.setCompiled(!0),1):(tt(`Links failed: ${e.error}`),0):(tt(e.fragmentShader.getSource().split(`
`).map((r,n)=>`${n}: ${r}`).join(`
`)),tt(e.fragmentShader.getError()),0):(tt(e.vertexShader.getSource().split(`
`).map((r,n)=>`${n}: ${r}`).join(`
`)),tt(e.vertexShader.getError()),0),t.cleanup=()=>{e.shaderType==="Unknown"||e.handle===0||(t.release(),e.vertexShaderHandle!==0&&(e.context.detachShader(e.handle,e.vertexShaderHandle),e.vertexShaderHandle=0),e.fragmentShaderHandle!==0&&(e.context.detachShader(e.handle,e.fragmentShaderHandle),e.fragmentShaderHandle=0),e.context.deleteProgram(e.handle),e.handle=0,t.setCompiled(!1))},t.bind=()=>!e.linked&&!t.link()?!1:(e.context.useProgram(e.handle),t.setBound(!0),!0),t.isBound=()=>!!e.bound,t.release=()=>{e.context.useProgram(null),t.setBound(!1)},t.setContext=r=>{e.vertexShader.setContext(r),e.fragmentShader.setContext(r),e.geometryShader.setContext(r)},t.link=()=>{if(e.linked)return!0;if(e.handle===0)return e.error="Program has not been initialized, and/or does not have shaders.",!1;if(e.uniformLocs={},e.context.linkProgram(e.handle),!e.context.getProgramParameter(e.handle,e.context.LINK_STATUS)){const n=e.context.getProgramInfoLog(e.handle);return tt(`Error linking shader ${n}`),e.handle=0,!1}return t.setLinked(!0),e.attributeLocs={},!0},t.setUniformMatrix=(r,n)=>{const a=t.findUniform(r);if(a===-1)return e.error=`Could not set uniform ${r} . No such uniform.`,!1;const i=new Float32Array(n);return e.context.uniformMatrix4fv(a,!1,i),!0},t.setUniformMatrix3x3=(r,n)=>{const a=t.findUniform(r);if(a===-1)return e.error=`Could not set uniform ${r} . No such uniform.`,!1;const i=new Float32Array(n);return e.context.uniformMatrix3fv(a,!1,i),!0},t.setUniformf=(r,n)=>{const a=t.findUniform(r);return a===-1?(e.error=`Could not set uniform ${r} . No such uniform.`,!1):(e.context.uniform1f(a,n),!0)},t.setUniformfv=(r,n)=>{const a=t.findUniform(r);return a===-1?(e.error=`Could not set uniform ${r} . No such uniform.`,!1):(e.context.uniform1fv(a,n),!0)},t.setUniformi=(r,n)=>{const a=t.findUniform(r);return a===-1?(e.error=`Could not set uniform ${r} . No such uniform.`,!1):(e.context.uniform1i(a,n),!0)},t.setUniformiv=(r,n)=>{const a=t.findUniform(r);return a===-1?(e.error=`Could not set uniform ${r} . No such uniform.`,!1):(e.context.uniform1iv(a,n),!0)},t.setUniform2f=(r,n,a)=>{const i=t.findUniform(r);if(i===-1)return e.error=`Could not set uniform ${r} . No such uniform.`,!1;if(a===void 0)throw new RangeError("Invalid number of values for array");return e.context.uniform2f(i,n,a),!0},t.setUniform2fv=(r,n)=>{const a=t.findUniform(r);return a===-1?(e.error=`Could not set uniform ${r} . No such uniform.`,!1):(e.context.uniform2fv(a,n),!0)},t.setUniform2i=(r,n,a)=>{const i=t.findUniform(r);if(i===-1)return e.error=`Could not set uniform ${r} . No such uniform.`,!1;if(a===void 0)throw new RangeError("Invalid number of values for array");return e.context.uniform2i(i,n,a),!0},t.setUniform2iv=(r,n)=>{const a=t.findUniform(r);return a===-1?(e.error=`Could not set uniform ${r} . No such uniform.`,!1):(e.context.uniform2iv(a,n),!0)},t.setUniform3f=(r,n,a,i)=>{const s=t.findUniform(r);if(s===-1)return e.error=`Could not set uniform ${r} . No such uniform.`,!1;if(i===void 0)throw new RangeError("Invalid number of values for array");return e.context.uniform3f(s,n,a,i),!0},t.setUniform3fArray=(r,n)=>{const a=t.findUniform(r);if(a===-1)return e.error=`Could not set uniform ${r} . No such uniform.`,!1;if(!Array.isArray(n)||n.length!==3)throw new RangeError("Invalid number of values for array");return e.context.uniform3f(a,n[0],n[1],n[2]),!0},t.setUniform3fv=(r,n)=>{const a=t.findUniform(r);return a===-1?(e.error=`Could not set uniform ${r} . No such uniform.`,!1):(e.context.uniform3fv(a,n),!0)},t.setUniform3i=function(r){const n=t.findUniform(r);if(n===-1)return e.error=`Could not set uniform ${r} . No such uniform.`,!1;for(var a=arguments.length,i=new Array(a>1?a-1:0),s=1;s<a;s++)i[s-1]=arguments[s];let o=i;if(o.length===1&&Array.isArray(o[0])&&(o=o[0]),o.length!==3)throw new RangeError("Invalid number of values for array");return e.context.uniform3i(n,o[0],o[1],o[2]),!0},t.setUniform3iv=(r,n)=>{const a=t.findUniform(r);return a===-1?(e.error=`Could not set uniform ${r} . No such uniform.`,!1):(e.context.uniform3iv(a,n),!0)},t.setUniform4f=function(r){const n=t.findUniform(r);if(n===-1)return e.error=`Could not set uniform ${r} . No such uniform.`,!1;for(var a=arguments.length,i=new Array(a>1?a-1:0),s=1;s<a;s++)i[s-1]=arguments[s];let o=i;if(o.length===1&&Array.isArray(o[0])&&(o=o[0]),o.length!==4)throw new RangeError("Invalid number of values for array");return e.context.uniform4f(n,o[0],o[1],o[2],o[3]),!0},t.setUniform4fv=(r,n)=>{const a=t.findUniform(r);return a===-1?(e.error=`Could not set uniform ${r} . No such uniform.`,!1):(e.context.uniform4fv(a,n),!0)},t.setUniform4i=function(r){const n=t.findUniform(r);if(n===-1)return e.error=`Could not set uniform ${r} . No such uniform.`,!1;for(var a=arguments.length,i=new Array(a>1?a-1:0),s=1;s<a;s++)i[s-1]=arguments[s];let o=i;if(o.length===1&&Array.isArray(o[0])&&(o=o[0]),o.length!==4)throw new RangeError("Invalid number of values for array");return e.context.uniform4i(n,o[0],o[1],o[2],o[3]),!0},t.setUniform4iv=(r,n)=>{const a=t.findUniform(r);return a===-1?(e.error=`Could not set uniform ${r} . No such uniform.`,!1):(e.context.uniform4iv(a,n),!0)},t.findUniform=r=>{if(!r||!e.linked)return-1;let n=e.uniformLocs[r];return n!==void 0?n:(n=e.context.getUniformLocation(e.handle,r),n===null?(e.error=`Uniform ${r} not found in current shader program.`,e.uniformLocs[r]=-1,-1):(e.uniformLocs[r]=n,n))},t.isUniformUsed=r=>{if(!r)return!1;let n=e.uniformLocs[r];return n!==void 0?n!==null:e.linked?(n=e.context.getUniformLocation(e.handle,r),e.uniformLocs[r]=n,n!==null):(tt("attempt to find uniform when the shader program is not linked"),!1)},t.isAttributeUsed=r=>{if(!r)return!1;if(r in e.attributeLocs)return!0;if(!e.linked)return tt("attempt to find uniform when the shader program is not linked"),!1;const n=e.context.getAttribLocation(e.handle,r);return n===-1?!1:(e.attributeLocs[r]=n,!0)},t.attachShader=r=>{if(r.getHandle()===0)return e.error="Shader object was not initialized, cannot attach it.",!1;if(r.getShaderType()==="Unknown")return e.error="Shader object is of type Unknown and cannot be used.",!1;if(e.handle===0){const n=e.context.createProgram();if(n===0)return e.error="Could not create shader program.",!1;e.handle=n,e.linked=!1}return r.getShaderType()==="Vertex"&&(e.vertexShaderHandle!==0&&e.context.detachShader(e.handle,e.vertexShaderHandle),e.vertexShaderHandle=r.getHandle()),r.getShaderType()==="Fragment"&&(e.fragmentShaderHandle!==0&&e.context.detachShader(e.handle,e.fragmentShaderHandle),e.fragmentShaderHandle=r.getHandle()),e.context.attachShader(e.handle,r.getHandle()),t.setLinked(!1),!0},t.detachShader=r=>{if(r.getHandle()===0)return e.error="shader object was not initialized, cannot attach it.",!1;if(r.getShaderType()==="Unknown")return e.error="Shader object is of type Unknown and cannot be used.",!1;switch(e.handle===0&&(e.error="This shader program has not been initialized yet."),r.getShaderType()){case"Vertex":return e.vertexShaderHandle!==r.getHandle()?(e.error="The supplied shader was not attached to this program.",!1):(e.context.detachShader(e.handle,r.getHandle()),e.vertexShaderHandle=0,e.linked=!1,!0);case"Fragment":return e.fragmentShaderHandle!==r.getHandle()?(e.error="The supplied shader was not attached to this program.",!1):(e.context.detachShader(e.handle,r.getHandle()),e.fragmentShaderHandle=0,e.linked=!1,!0);default:return!1}},t.setContext=r=>{e.context=r,e.vertexShader.setContext(r),e.fragmentShader.setContext(r),e.geometryShader.setContext(r)},t.setLastCameraMTime=r=>{e.lastCameraMTime=r}}const bp={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:"",handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function dc(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,bp,r),e.attributesLocs={},e.uniformLocs={},e.vertexShader=La.newInstance(),e.vertexShader.setShaderType("Vertex"),e.fragmentShader=La.newInstance(),e.fragmentShader.setShaderType("Fragment"),e.geometryShader=La.newInstance(),e.geometryShader.setShaderType("Geometry"),y.obj(t,e),y.get(t,e,["lastCameraMTime"]),y.setGet(t,e,["error","handle","compiled","bound","md5Hash","vertexShader","fragmentShader","geometryShader","linked"]),jp(t,e)}const Kp=y.newInstance(dc,"vtkShaderProgram");var V={newInstance:Kp,extend:dc,substitute:Hp};function Xp(t,e){e.classHierarchy.push("vtkOpenGLVertexArrayObject"),t.exposedMethod=()=>{},t.initialize=()=>{e.instancingExtension=null,e._openGLRenderWindow.getWebgl2()||(e.instancingExtension=e.context.getExtension("ANGLE_instanced_arrays")),!e.forceEmulation&&e._openGLRenderWindow&&e._openGLRenderWindow.getWebgl2()?(e.extension=null,e.supported=!0,e.handleVAO=e.context.createVertexArray()):(e.extension=e.context.getExtension("OES_vertex_array_object"),!e.forceEmulation&&e.extension?(e.supported=!0,e.handleVAO=e.extension.createVertexArrayOES()):e.supported=!1)},t.isReady=()=>e.handleVAO!==0||e.supported===!1,t.bind=()=>{if(t.isReady()||t.initialize(),t.isReady()&&e.supported)e.extension?e.extension.bindVertexArrayOES(e.handleVAO):e.context.bindVertexArray(e.handleVAO);else if(t.isReady()){const r=e.context;for(let n=0;n<e.buffers.length;++n){const a=e.buffers[n];e.context.bindBuffer(r.ARRAY_BUFFER,a.buffer);for(let i=0;i<a.attributes.length;++i){const s=a.attributes[i],o=s.isMatrix?s.size:1;for(let c=0;c<o;++c)r.enableVertexAttribArray(s.index+c),r.vertexAttribPointer(s.index+c,s.size,s.type,s.normalize,s.stride,s.offset+s.stride*c/s.size),s.divisor>0&&(e.instancingExtension?e.instancingExtension.vertexAttribDivisorANGLE(s.index+c,1):r.vertexAttribDivisor(s.index+c,1))}}}},t.release=()=>{if(t.isReady()&&e.supported)e.extension?e.extension.bindVertexArrayOES(null):e.context.bindVertexArray(null);else if(t.isReady()){const r=e.context;for(let n=0;n<e.buffers.length;++n){const a=e.buffers[n];e.context.bindBuffer(r.ARRAY_BUFFER,a.buffer);for(let i=0;i<a.attributes.length;++i){const s=a.attributes[i],o=s.isMatrix?s.size:1;for(let c=0;c<o;++c)r.enableVertexAttribArray(s.index+c),r.vertexAttribPointer(s.index+c,s.size,s.type,s.normalize,s.stride,s.offset+s.stride*c/s.size),s.divisor>0&&(e.instancingExtension?e.instancingExtension.vertexAttribDivisorANGLE(s.index+c,0):r.vertexAttribDivisor(s.index+c,0)),r.disableVertexAttribArray(s.index+c)}}}},t.shaderProgramChanged=()=>{t.release(),e.handleVAO&&(e.extension?e.extension.deleteVertexArrayOES(e.handleVAO):e.context.deleteVertexArray(e.handleVAO)),e.handleVAO=0,e.handleProgram=0},t.releaseGraphicsResources=()=>{t.shaderProgramChanged(),e.handleVAO&&(e.extension?e.extension.deleteVertexArrayOES(e.handleVAO):e.context.deleteVertexArray(e.handleVAO)),e.handleVAO=0,e.supported=!0,e.handleProgram=0},t.addAttributeArray=(r,n,a,i,s,o,c,u)=>t.addAttributeArrayWithDivisor(r,n,a,i,s,o,c,u,0,!1),t.addAttributeArrayWithDivisor=(r,n,a,i,s,o,c,u,g,f)=>{if(!r||!r.isBound()||n.getHandle()===0||n.getType()!==Kn.ARRAY_BUFFER||(e.handleProgram===0&&(e.handleProgram=r.getHandle()),t.isReady()||t.initialize(),!t.isReady()||e.handleProgram!==r.getHandle()))return!1;const l=e.context,p={};if(p.name=a,p.index=l.getAttribLocation(e.handleProgram,a),p.offset=i,p.stride=s,p.type=o,p.size=c,p.normalize=u,p.isMatrix=f,p.divisor=g,p.Index===-1)return!1;if(n.bind(),l.enableVertexAttribArray(p.index),l.vertexAttribPointer(p.index,p.size,p.type,p.normalize,p.stride,p.offset),g>0&&(e.instancingExtension?e.instancingExtension.vertexAttribDivisorANGLE(p.index,1):l.vertexAttribDivisor(p.index,1)),p.buffer=n.getHandle(),!e.supported){let d=!1;for(let h=0;h<e.buffers.length;++h){const T=e.buffers[h];if(T.buffer===p.buffer){d=!0;let v=!1;for(let C=0;C<T.attributes.length;++C)T.attributes[C].name===a&&(v=!0,T.attributes[C]=p);v||T.attributes.push(p)}}d||e.buffers.push({buffer:p.buffer,attributes:[p]})}return!0},t.addAttributeMatrixWithDivisor=(r,n,a,i,s,o,c,u,g)=>{const f=t.addAttributeArrayWithDivisor(r,n,a,i,s,o,c,u,g,!0);if(!f)return f;const l=e.context,p=l.getAttribLocation(e.handleProgram,a);for(let d=1;d<c;d++)l.enableVertexAttribArray(p+d),l.vertexAttribPointer(p+d,c,o,u,s,i+s*d/c),g>0&&(e.instancingExtension?e.instancingExtension.vertexAttribDivisorANGLE(p+d,1):l.vertexAttribDivisor(p+d,1));return!0},t.removeAttributeArray=r=>{if(!t.isReady()||e.handleProgram===0)return!1;if(!e.supported)for(let n=0;n<e.buffers.length;++n){const a=e.buffers[n];for(let i=0;i<a.attributes.length;++i)if(a.attributes[i].name===r)return a.attributes.splice(i,1),a.attributes.length||e.buffers.splice(n,1),!0}return!0},t.setOpenGLRenderWindow=r=>{e._openGLRenderWindow!==r&&(t.releaseGraphicsResources(),e._openGLRenderWindow=r,e.context=null,r&&(e.context=e._openGLRenderWindow.getContext()))}}const Ap={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function Tc(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Ap,r),e.buffers=[],y.obj(t,e),y.get(t,e,["supported"]),y.setGet(t,e,["forceEmulation"]),Xp(t,e)}const Yp=y.newInstance(Tc,"vtkOpenGLVertexArrayObject");var Ui={newInstance:Yp,extend:Tc};const Dt={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6};function qp(t,e){e.classHierarchy.push("vtkOpenGLHelper"),t.setOpenGLRenderWindow=r=>{e.context=r.getContext(),e.program.setContext(e.context),e.VAO.setOpenGLRenderWindow(r),e.CABO.setOpenGLRenderWindow(r)},t.releaseGraphicsResources=r=>{e.VAO.releaseGraphicsResources(),e.CABO.releaseGraphicsResources(),e.CABO.setElementCount(0)},t.drawArrays=(r,n,a,i)=>{if(e.CABO.getElementCount()){const s=t.getOpenGLMode(a),o=t.haveWideLines(r,n),c=e.context,u=c.getParameter(c.DEPTH_WRITEMASK);e.pointPicking&&c.depthMask(!1),s===c.LINES&&o?(t.updateShaders(r,n,i),c.drawArraysInstanced(s,0,e.CABO.getElementCount(),2*Math.ceil(n.getProperty().getLineWidth()))):(c.lineWidth(n.getProperty().getLineWidth()),t.updateShaders(r,n,i),c.drawArrays(s,0,e.CABO.getElementCount()),c.lineWidth(1));const f=(s===c.POINTS?1:0)||(s===c.LINES?2:3);return e.pointPicking&&c.depthMask(u),e.CABO.getElementCount()/f}return 0},t.getOpenGLMode=r=>{if(e.pointPicking)return e.context.POINTS;const n=e.primitiveType;return r===me.POINTS||n===Dt.Points?e.context.POINTS:r===me.WIREFRAME||n===Dt.Lines||n===Dt.TrisEdges||n===Dt.TriStripsEdges?e.context.LINES:e.context.TRIANGLES},t.haveWideLines=(r,n)=>n.getProperty().getLineWidth()>1?!(e.CABO.getOpenGLRenderWindow()&&e.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()):!1,t.getNeedToRebuildShaders=(r,n,a)=>!!(a.getNeedToRebuildShaders(t,r,n)||t.getProgram()===0||t.getShaderSourceTime().getMTime()<a.getMTime()||t.getShaderSourceTime().getMTime()<n.getMTime()),t.updateShaders=(r,n,a)=>{if(t.getNeedToRebuildShaders(r,n,a)){const i={Vertex:null,Fragment:null,Geometry:null};a.buildShaders(i,r,n);const s=e.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(i.Vertex,i.Fragment,i.Geometry);s!==t.getProgram()&&(t.setProgram(s),t.getVAO().releaseGraphicsResources()),t.getShaderSourceTime().modified()}else e.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(t.getProgram());t.getVAO().bind(),a.setMapperShaderParameters(t,r,n),a.setPropertyShaderParameters(t,r,n),a.setCameraShaderParameters(t,r,n),a.setLightingShaderParameters(t,r,n),a.invokeShaderCallbacks(t,r,n)},t.setMapperShaderParameters=(r,n,a)=>{if(t.haveWideLines(r,n)){t.getProgram().setUniform2f("viewportSize",a.usize,a.vsize);const i=parseFloat(n.getProperty().getLineWidth()),s=i/2;t.getProgram().setUniformf("lineWidthStepSize",i/Math.ceil(i)),t.getProgram().setUniformf("halfLineWidth",s)}e.primitiveType===Dt.Points||n.getProperty().getRepresentation()===me.POINTS?t.getProgram().setUniformf("pointSize",n.getProperty().getPointSize()):e.pointPicking&&t.getProgram().setUniformf("pointSize",t.getPointPickingPrimitiveSize())},t.replaceShaderPositionVC=(r,n,a)=>{let i=r.Vertex;i=V.substitute(i,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform float pointSize;"]).result,i=V.substitute(i,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl","  gl_PointSize = pointSize;"],!1).result,t.getOpenGLMode(a.getProperty().getRepresentation())===e.context.LINES&&t.haveWideLines(n,a)&&(i=V.substitute(i,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform vec2 viewportSize;","uniform float lineWidthStepSize;","uniform float halfLineWidth;"]).result,i=V.substitute(i,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl"," if (halfLineWidth > 0.0)","   {","   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;","   vec4 tmpPos = gl_Position;","   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;","   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];","   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];","   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);","   }"]).result),r.Vertex=i},t.getPointPickingPrimitiveSize=()=>e.primitiveType===Dt.Points?2:e.primitiveType===Dt.Lines?4:6,t.getAllocatedGPUMemoryInBytes=()=>t.getCABO().getAllocatedGPUMemoryInBytes()}const Zp={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function vc(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Zp,r),y.obj(t,e),e.shaderSourceTime={},y.obj(e.shaderSourceTime),e.attributeUpdateTime={},y.obj(e.attributeUpdateTime),y.setGet(t,e,["program","shaderSourceTime","VAO","attributeUpdateTime","CABO","primitiveType","pointPicking"]),e.program=V.newInstance(),e.VAO=Ui.newInstance(),e.CABO=Up.newInstance(),qp(t,e)}const Pp=y.newInstance(vc);var ft={newInstance:Pp,extend:vc,primTypes:Dt};function Jp(t,e){e.classHierarchy.push("vtkAbstractMapper"),t.update=()=>{t.getInputData()},t.addClippingPlane=r=>r.isA("vtkPlane")?e.clippingPlanes.includes(r)?!1:(e.clippingPlanes.push(r),t.modified(),!0):!1,t.getNumberOfClippingPlanes=()=>e.clippingPlanes.length,t.removeAllClippingPlanes=()=>e.clippingPlanes.length===0?!1:(e.clippingPlanes.length=0,t.modified(),!0),t.removeClippingPlane=r=>{const n=e.clippingPlanes.indexOf(r);return n===-1?!1:(e.clippingPlanes.splice(n,1),t.modified(),!0)},t.getClippingPlanes=()=>e.clippingPlanes,t.setClippingPlanes=r=>{if(r)if(!Array.isArray(r))t.addClippingPlane(r);else{const n=r.length;for(let a=0;a<n&&a<6;a++)t.addClippingPlane(r[a])}},t.getClippingPlaneInDataCoords=(r,n,a)=>{const i=e.clippingPlanes,s=r;if(i){const o=i.length;if(n>=0&&n<o){const c=i[n],u=c.getNormal(),g=c.getOrigin(),f=u[0],l=u[1],p=u[2],d=-(f*g[0]+l*g[1]+p*g[2]);a[0]=f*s[0]+l*s[4]+p*s[8]+d*s[12],a[1]=f*s[1]+l*s[5]+p*s[9]+d*s[13],a[2]=f*s[2]+l*s[6]+p*s[10]+d*s[14],a[3]=f*s[3]+l*s[7]+p*s[11]+d*s[15];return}}y.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}const Qp={clippingPlanes:[]};function Ip(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Qp,r),y.obj(t,e),y.algo(t,e,1,0),e.clippingPlanes||(e.clippingPlanes=[]),Jp(t,e)}var yc={extend:Ip};const Bi=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e0=[1,0,0,0,1,0,0,0,1],Ta=1e-6,Wi=1e-12,{vtkErrorMacro:Cc,vtkWarningMacro:rn}=y;let Sc=0;const Ns=20;function ur(t){return()=>Cc(`vtkMath::${t} - NOT IMPLEMENTED`)}function Xn(t,e,r,n){let a;for(let i=0;i<e;i++)a=t[r*e+i],t[r*e+i]=t[n*e+i],t[n*e+i]=a}function kn(t,e,r,n){let a;for(let i=0;i<e;i++)a=t[i*e+r],t[i*e+r]=t[i*e+n],t[i*e+n]=a}function ue(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:3;const e=Array(t);for(let r=0;r<t;++r)e[r]=0;return e}const t0=()=>Math.PI;function n0(t,e){return e>1023?t*2**1023*2**(e-1023):e<-1074?t*2**-1074*2**(e+1074):t*2**e}function fe(t){return t/180*Math.PI}function Tn(t){return t*180/Math.PI}const{round:yt,floor:Qn,ceil:r0,min:a0,max:i0}=Math;function s0(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:1,n=1/0;for(let a=e,i=t.length;a<i;a+=r)t[a]<n&&(n=t[a]);return n}function o0(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:1,n=-1/0;for(let a=e,i=t.length;a<i;a+=r)n<t[a]&&(n=t[a]);return n}function xc(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:1,n=1/0,a=-1/0;for(let i=e,s=t.length;i<s;i+=r)t[i]<n&&(n=t[i]),a<t[i]&&(a=t[i]);return[n,a]}const c0=ur("ceilLog2"),u0=ur("factorial");function Nt(t){let e=1;for(;e<t;)e*=2;return e}function Nn(t){return t===Nt(t)}function f0(t,e){let r=1;for(let n=1;n<=e;++n)r*=(t-n+1)/n;return Math.floor(r)}function g0(t,e){if(t<e)return 0;const r=ue(e);for(let n=0;n<e;++n)r[n]=n;return r}function l0(t,e,r){let n=0;for(let a=e-1;a>=0;--a)if(r[a]<t-e+a){let i=r[a]+1;for(;a<e;)r[a++]=i++;n=1;break}return n}function p0(t){Cl(`${t}`,{global:!0}),Sc=t}function h0(){return Sc}function d0(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;const r=(arguments.length>1&&arguments[1]!==void 0?arguments[1]:1)-t;return t+r*Math.random()}const T0=ur("gaussian");function Qe(t,e,r){return r[0]=t[0]+e[0],r[1]=t[1]+e[1],r[2]=t[2]+e[2],r}function re(t,e,r){return r[0]=t[0]-e[0],r[1]=t[1]-e[1],r[2]=t[2]-e[2],r}function St(t,e){return t[0]*=e,t[1]*=e,t[2]*=e,t}function wc(t,e){return t[0]*=e,t[1]*=e,t}function Tt(t,e,r,n){return n[0]=t[0]+e[0]*r,n[1]=t[1]+e[1]*r,n[2]=t[2]+e[2]*r,n}function v0(t,e,r,n){return n[0]=t[0]+e[0]*r,n[1]=t[1]+e[1]*r,n}function b(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function y0(t,e,r){r[0]=t[0]*e[0],r[1]=t[0]*e[1],r[2]=t[0]*e[2],r[3]=t[1]*e[0],r[4]=t[1]*e[1],r[5]=t[1]*e[2],r[6]=t[2]*e[0],r[7]=t[2]*e[1],r[8]=t[2]*e[2]}function Te(t,e,r){const n=t[1]*e[2]-t[2]*e[1],a=t[2]*e[0]-t[0]*e[2],i=t[0]*e[1]-t[1]*e[0];return r[0]=n,r[1]=a,r[2]=i,r}function Pe(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:3;switch(e){case 1:return Math.abs(t);case 2:return Math.sqrt(t[0]*t[0]+t[1]*t[1]);case 3:return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);default:{let r=0;for(let n=0;n<e;n++)r+=t[n]*t[n];return Math.sqrt(r)}}}function pe(t){const e=Pe(t);return e!==0&&(t[0]/=e,t[1]/=e,t[2]/=e),e}function C0(t,e,r,n){const a=t[0]*t[0],i=t[1]*t[1],s=t[2]*t[2],o=Math.sqrt(a+i+s);let c,u,g;a>i&&a>s?(c=0,u=1,g=2):i>s?(c=1,u=2,g=0):(c=2,u=0,g=1);const f=t[c]/o,l=t[u]/o,p=t[g]/o,d=Math.sqrt(f*f+p*p);if(n!==0){const h=Math.sin(n),T=Math.cos(n);e&&(e[c]=(p*T-f*l*h)/d,e[u]=h*d,e[g]=(-(f*T)-l*p*h)/d),r&&(r[c]=(-(p*h)-f*l*T)/d,r[u]=T*d,r[g]=(f*h-l*p*T)/d)}else e&&(e[c]=p/d,e[u]=0,e[g]=-f/d),r&&(r[c]=-f*l/d,r[u]=d,r[g]=-l*p/d)}function S0(t,e,r){const n=b(e,e);if(n===0)return r[0]=0,r[1]=0,r[2]=0,!1;const a=b(t,e)/n;for(let i=0;i<3;i++)r[i]=e[i];return St(r,a),!0}function ti(t,e){return t[0]*e[0]+t[1]*e[1]}function x0(t,e,r){const n=ti(e,e);if(n===0)return r[0]=0,r[1]=0,!1;const a=ti(t,e)/n;for(let i=0;i<2;i++)r[i]=e[i];return wc(r,a),!0}function Ye(t,e){return(t[0]-e[0])*(t[0]-e[0])+(t[1]-e[1])*(t[1]-e[1])+(t[2]-e[2])*(t[2]-e[2])}function w0(t,e){const r=[0,0,0];return Te(t,e,r),Math.atan2(Pe(r),b(t,e))}function Rc(t,e,r){const n=[0,0,0];Te(t,e,n);const a=Math.atan2(Pe(n),b(t,e));return b(n,r)>=0?a:-a}function R0(t,e,r){const n=Math.abs(t-r);return 1/Math.sqrt(2*Math.PI*e)*Math.exp(-(n**2)/(2*e))}function M0(t,e,r){const n=Math.abs(t-r);return Math.exp(-(n**2)/(2*e))}function O0(t,e,r){r[0]=t[0]*e[0],r[1]=t[0]*e[1],r[2]=t[1]*e[0],r[3]=t[1]*e[1]}function Mc(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1])}function m0(t){const e=Mc(t);return e!==0&&(t[0]/=e,t[1]/=e),e}function le(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];return e.length===2?e[0][0]*e[1][1]-e[1][0]*e[0][1]:e.length===4?e[0]*e[3]-e[1]*e[2]:Number.NaN}function E0(t,e){let r,n,a;const i=[0,0,0];for(let s=0;s<3;s++)a=Math.abs(t[s*3]),(n=Math.abs(t[s*3+1]))>a&&(a=n),(n=Math.abs(t[s*3+2]))>a&&(a=n),i[s]=1/a;a=i[0]*Math.abs(t[0]),r=0,(n=i[1]*Math.abs(t[3]))>=a&&(a=n,r=1),(n=i[2]*Math.abs(t[6]))>=a&&(r=2),r!==0&&(Xn(t,3,r,0),i[r]=i[0]),e[0]=r,t[3]/=t[0],t[6]/=t[0],t[4]-=t[3]*t[1],t[7]-=t[6]*t[1],a=i[1]*Math.abs(t[4]),r=1,(n=i[2]*Math.abs(t[7]))>=a&&(r=2,Xn(t,3,1,2),i[2]=i[1]),e[1]=r,t[7]/=t[4],t[5]-=t[3]*t[2],t[8]-=t[6]*t[2]+t[7]*t[5],e[2]=2}function D0(t,e,r){let n=r[e[0]];r[e[0]]=r[0],r[0]=n,n=r[e[1]],r[e[1]]=r[1],r[1]=n-t[3]*r[0],n=r[e[2]],r[e[2]]=r[2],r[2]=n-t[6]*r[0]-t[7]*r[1],r[2]/=t[8],r[1]=(r[1]-t[5]*r[2])/t[4],r[0]=(r[0]-t[1]*r[1]-t[2]*r[2])/t[0]}function V0(t,e,r){const n=t[0],a=t[1],i=t[2],s=t[3],o=t[4],c=t[5],u=t[6],g=t[7],f=t[8],l=+le(o,g,c,f),p=-le(s,u,c,f),d=+le(s,u,o,g),h=-le(a,g,i,f),T=+le(n,u,i,f),v=-le(n,u,a,g),C=+le(a,o,i,c),S=-le(n,s,i,c),x=+le(n,s,a,o),R=n*l+a*p+i*d,O=l*e[0]+h*e[1]+C*e[2],w=p*e[0]+T*e[1]+S*e[2],m=d*e[0]+v*e[1]+x*e[2];r[0]=O/R,r[1]=w/R,r[2]=m/R}function $r(t,e,r){const n=t[0]*e[0]+t[1]*e[1]+t[2]*e[2],a=t[3]*e[0]+t[4]*e[1]+t[5]*e[2],i=t[6]*e[0]+t[7]*e[1]+t[8]*e[2];r[0]=n,r[1]=a,r[2]=i}function ni(t,e,r){const n=[...t],a=[...e];for(let i=0;i<3;i++)r[i]=n[0]*a[i]+n[1]*a[i+3]+n[2]*a[i+6],r[i+3]=n[3]*a[i]+n[4]*a[i+3]+n[5]*a[i+6],r[i+6]=n[6]*a[i]+n[7]*a[i+3]+n[8]*a[i+6]}function L0(t,e,r,n,a,i,s){n!==a&&Cc("Number of columns of A must match number of rows of B.");const o=[...t],c=[...e];for(let u=0;u<r;u++)for(let g=0;g<i;g++){s[u*i+g]=0;for(let f=0;f<n;f++)s[u*i+g]+=o[u*n+f]*c[g+i*f]}}function hn(t,e){let r;r=t[3],e[3]=t[1],e[1]=r,r=t[6],e[6]=t[2],e[2]=r,r=t[7],e[7]=t[5],e[5]=r,e[0]=t[0],e[4]=t[4],e[8]=t[8]}function F0(t,e){const r=t[0],n=t[1],a=t[2],i=t[3],s=t[4],o=t[5],c=t[6],u=t[7],g=t[8],f=+le(s,u,o,g),l=-le(i,c,o,g),p=+le(i,c,s,u),d=-le(n,u,a,g),h=+le(r,c,a,g),T=-le(r,c,n,u),v=+le(n,s,a,o),C=-le(r,i,a,o),S=+le(r,i,n,s),x=r*f+n*l+a*p;x===0&&rn("Matrix has 0 determinant"),e[0]=f/x,e[3]=l/x,e[6]=p/x,e[1]=d/x,e[4]=h/x,e[7]=T/x,e[2]=v/x,e[5]=C/x,e[8]=S/x}function va(t){return t[0]*t[4]*t[8]+t[3]*t[7]*t[2]+t[6]*t[1]*t[5]-t[0]*t[7]*t[5]-t[3]*t[1]*t[8]-t[6]*t[4]*t[2]}function Oc(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:Ta;if(t.length!==e.length)return!1;function n(a,i){return Math.abs(a-e[i])<=r}return t.every(n)}const fr=Oc;function mc(t){for(let e=0;e<3;e++)t[e*3]=t[e*3+1]=t[e*3+2]=0,t[e*3+e]=1}function Ec(t,e){for(let r=0;r<t;r++){for(let n=0;n<t;n++)e[r*t+n]=0;e[r*t+r]=1}return e}function k0(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Ta;return fr(t,Bi,e)}function N0(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Ta;return fr(t,e0,e)}function Dc(t,e){const r=t[0]*t[0],n=t[0]*t[1],a=t[0]*t[2],i=t[0]*t[3],s=t[1]*t[1],o=t[2]*t[2],c=t[3]*t[3],u=t[1]*t[2],g=t[1]*t[3],f=t[2]*t[3],l=s+o+c;let p=1/(r+l);const d=(r-l)*p;p*=2,e[0]=s*p+d,e[3]=(u+i)*p,e[6]=(g-a)*p,e[1]=(u-i)*p,e[4]=o*p+d,e[7]=(f+n)*p,e[2]=(g+a)*p,e[5]=(f-n)*p,e[8]=c*p+d}function zr(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0;if(!`${t}`.includes("e"))return+`${Math.round(`${t}e+${e}`)}e-${e}`;const r=`${t}`.split("e");let n="";return+r[1]+e>0&&(n="+"),+`${Math.round(`${+r[0]}e${n}${+r[1]+e}`)}e-${e}`}function ri(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[0,0,0],r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:0;return e[0]=zr(t[0],r),e[1]=zr(t[1],r),e[2]=zr(t[2],r),e}function gr(t,e,r,n){let a,i,s,o,c,u,g,f,l,p,d,h,T,v,C,S;const x=ue(e),R=ue(e),O=(m,E,M)=>{v=m[E],T=m[M],m[E]=v-h*(T+v*p),m[M]=T+h*(v-T*p)};for(Ec(e,n),c=0;c<e;c++)x[c]=r[c]=t[c+c*e],R[c]=0;for(a=0;a<Ns;a++){for(d=0,c=0;c<e-1;c++)for(o=c+1;o<e;o++)d+=Math.abs(t[c*e+o]);if(d===0)break;for(a<3?g=.2*d/(e*e):g=0,c=0;c<e-1;c++)for(o=c+1;o<e;o++)if(v=100*Math.abs(t[c*e+o]),a>3&&Math.abs(r[c])+v===Math.abs(r[c])&&Math.abs(r[o])+v===Math.abs(r[o]))t[c*e+o]=0;else if(Math.abs(t[c*e+o])>g){for(T=r[o]-r[c],Math.abs(T)+v===Math.abs(T)?l=t[c*e+o]/T:(f=.5*T/t[c*e+o],l=1/(Math.abs(f)+Math.sqrt(1+f*f)),f<0&&(l=-l)),C=1/Math.sqrt(1+l*l),h=l*C,p=h/(1+C),T=l*t[c*e+o],R[c]-=T,R[o]+=T,r[c]-=T,r[o]+=T,t[c*e+o]=0,i=0;i<=c-1;i++)O(t,i*e+c,i*e+o);for(i=c+1;i<=o-1;i++)O(t,c*e+i,i*e+o);for(i=o+1;i<e;i++)O(t,c*e+i,o*e+i);for(i=0;i<e;i++)O(n,i*e+c,i*e+o)}for(c=0;c<e;c++)x[c]+=R[c],r[c]=x[c],R[c]=0}if(a>=Ns)return rn("vtkMath::Jacobi: Error extracting eigenfunctions"),0;for(i=0;i<e-1;i++){for(s=i,S=r[s],a=i+1;a<e;a++)(r[a]>=S||Math.abs(r[a]-S)<Wi)&&(s=a,S=r[s]);s!==i&&(r[s]=r[i],r[i]=S,kn(n,e,i,s))}const w=(e>>1)+(e&1);for(u=0,a=0;a<e*e;a++)n[a]>=0&&u++;if(u<w)for(a=0;a<e;a++)n[a*e+i]*=-1;return 1}function Vc(t,e){const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];r[0]=t[0]+t[4]+t[8],r[5]=t[0]-t[4]-t[8],r[10]=-t[0]+t[4]-t[8],r[15]=-t[0]-t[4]+t[8],r[1]=r[4]=t[7]-t[5],r[2]=r[8]=t[2]-t[6],r[3]=r[12]=t[3]-t[1],r[6]=r[9]=t[3]+t[1],r[7]=r[13]=t[2]+t[6],r[11]=r[14]=t[7]+t[5];const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],a=[0,0,0,0],i=[...r];gr(i,4,a,n),e[0]=n[0],e[1]=n[4],e[2]=n[8],e[3]=n[12]}function _0(t,e,r){const n=t[0]*e[0],a=t[0]*e[1],i=t[0]*e[2],s=t[0]*e[3],o=t[1]*e[0],c=t[1]*e[1],u=t[1]*e[2],g=t[1]*e[3],f=t[2]*e[0],l=t[2]*e[1],p=t[2]*e[2],d=t[2]*e[3],h=t[3]*e[0],T=t[3]*e[1],v=t[3]*e[2],C=t[3]*e[3];r[0]=n-c-p-C,r[1]=a+o+d-v,r[2]=i-g+f+T,r[3]=s+u-l+h}function Lc(t,e){for(let l=0;l<9;l++)e[l]=t[l];const r=ue(3),n=ue(3);let a;for(let l=0;l<3;l++){const p=Math.abs(e[l*3]),d=Math.abs(e[l*3+1]),h=Math.abs(e[l*3+2]);a=d>p?d:p,a=h>a?h:a,r[l]=1,a!==0&&(r[l]/=a)}const i=Math.abs(e[0])*r[0],s=Math.abs(e[3])*r[1],o=Math.abs(e[6])*r[2];n[0]=0,a=i,s>=a&&(a=s,n[0]=1),o>=a&&(n[0]=2),n[0]!==0&&(kn(e,3,n[0],0),r[n[0]]=r[0]);const c=Math.abs(e[4])*r[1],u=Math.abs(e[7])*r[2];n[1]=1,a=c,u>=a&&(n[1]=2,kn(e,3,1,2)),n[2]=2;let g=0;if(va(e)<0){g=1;for(let l=0;l<9;l++)e[l]=-e[l]}const f=ue(4);if(Vc(e,f),Dc(f,e),g)for(let l=0;l<9;l++)e[l]=-e[l];n[1]!==1&&kn(e,3,n[1],1),n[0]!==0&&kn(e,3,n[0],0)}function Fc(t,e,r){let n,a,i,s,o,c;const u=[...t];if(gr(u,3,e,r),e[0]===e[1]&&e[0]===e[2]){mc(r);return}for(hn(r,r),n=0;n<3;n++)if(e[(n+1)%3]===e[(n+2)%3]){for(c=Math.abs(r[n*3]),s=0,a=1;a<3;a++)c<(o=Math.abs(r[n*3+a]))&&(c=o,s=a);s!==n&&(o=e[s],e[s]=e[n],e[n]=o,Xn(r,3,n,s)),r[s*3+s]<0&&(r[s*3]=-r[s*3],r[s*3+1]=-r[s*3+1],r[s*3+2]=-r[s*3+2]),a=(s+1)%3,i=(s+2)%3,r[a*3]=0,r[a*3+1]=0,r[a*3+2]=0,r[a*3+a]=1;const g=Te([r[s*3],r[s*3+1],r[s*3+2]],[r[a*3],r[a*3+1],r[a*3+2]],[]);pe(g);const f=Te(g,[r[s*3],r[s*3+1],r[s*3+2]],[]);for(let l=0;l<3;l++)r[i*3+l]=g[l],r[a*3+l]=f[l];hn(r,r);return}for(c=Math.abs(r[0]),s=0,n=1;n<3;n++)c<(o=Math.abs(r[n*3]))&&(c=o,s=n);if(s!==0){const g=e[s];e[s]=e[0],e[0]=g,Xn(r,3,s,0)}if(Math.abs(r[4])<Math.abs(r[7])){const g=e[2];e[2]=e[1],e[1]=g,Xn(r,3,1,2)}for(n=0;n<2;n++)r[n*3+n]<0&&(r[n*3]=-r[n*3],r[n*3+1]=-r[n*3+1],r[n*3+2]=-r[n*3+2]);va(r)<0&&(r[6]=-r[6],r[7]=-r[7],r[8]=-r[8]),hn(r,r)}function G0(t,e,r,n){let a;const i=[...t],s=va(i);if(s<0)for(a=0;a<9;a++)i[a]=-i[a];Lc(i,e),hn(i,i),ni(i,e,n),Fc(n,r,n),ni(e,n,e),hn(n,n),s<0&&(r[0]=-r[0],r[1]=-r[1],r[2]=-r[2])}function $i(t,e,r){let n,a,i,s,o=0,c,u,g;const f=ue(r);for(n=0;n<r;n++){for(s=0,a=0;a<r;a++)(g=Math.abs(t[n*r+a]))>s&&(s=g);if(s===0)return rn("Unable to factor linear system"),0;f[n]=1/s}for(a=0;a<r;a++){for(n=0;n<a;n++){for(c=t[n*r+a],i=0;i<n;i++)c-=t[n*r+i]*t[i*r+a];t[n*r+a]=c}for(s=0,n=a;n<r;n++){for(c=t[n*r+a],i=0;i<a;i++)c-=t[n*r+i]*t[i*r+a];t[n*r+a]=c,(u=f[n]*Math.abs(c))>=s&&(s=u,o=n)}if(a!==o){for(i=0;i<r;i++)u=t[o*r+i],t[o*r+i]=t[a*r+i],t[a*r+i]=u;f[o]=f[a]}if(e[a]=o,Math.abs(t[a*r+a])<=Wi)return rn("Unable to factor linear system"),0;if(a!==r-1)for(u=1/t[a*r+a],n=a+1;n<r;n++)t[n*r+a]*=u}return 1}function zi(t,e,r,n){let a,i,s,o,c;for(s=-1,a=0;a<n;a++){if(o=e[a],c=r[o],r[o]=r[a],s>=0)for(i=s;i<=a-1;i++)c-=t[a*n+i]*r[i];else c!==0&&(s=a);r[a]=c}for(a=n-1;a>=0;a--){for(c=r[a],i=a+1;i<n;i++)c-=t[a*n+i]*r[i];r[a]=c/t[a*n+a]}}function kc(t,e,r){if(r===2){const a=ue(2),i=le(t[0],t[1],t[2],t[3]);return i===0?0:(a[0]=(t[3]*e[0]-t[1]*e[1])/i,a[1]=(-(t[2]*e[0])+t[0]*e[1])/i,e[0]=a[0],e[1]=a[1],1)}if(r===1)return t[0]===0?0:(e[0]/=t[0],1);const n=ue(r);return $i(t,n,r)===0?0:(zi(t,n,e,r),1)}function Nc(t,e,r){let n=arguments.length>3&&arguments[3]!==void 0?arguments[3]:null,a=arguments.length>4&&arguments[4]!==void 0?arguments[4]:null;const i=n||ue(r),s=a||ue(r);if($i(t,i,r)===0)return null;for(let o=0;o<r;o++){for(let c=0;c<r;c++)s[c]=0;s[o]=1,zi(t,i,s,r);for(let c=0;c<r;c++)e[c*r+o]=s[c]}return e}function U0(t,e){let r=+Number.MAX_VALUE,n=-Number.MAX_VALUE;for(let a=0;a<e;a++)for(let i=a;i<e;i++)Math.abs(t[a*e+i])>n&&(n=Math.abs(t[a*e+i]));for(let a=0;a<e;a++)Math.abs(t[a*e+a])<r&&(r=Math.abs(t[a*e+a]));return r===0?Number.MAX_VALUE:n/r}function B0(t,e,r){return gr(t,3,e,r)}function ai(t,e,r,n){if(t<r)return rn("Insufficient number of samples. Underdetermined."),0;let a,i,s;const o=ue(r*r),c=ue(r),u=ue(r*r);for(s=0;s<t;s++)for(a=0;a<r;a++)for(i=a;i<r;i++)o[a*r+i]+=e[s*r+a]*e[s*r+i];for(a=0;a<r;a++)for(i=0;i<a;i++)o[a*r+i]=o[i*r+a];for(gr(o,r,c,u),a=0;a<r;a++)n[a]=u[a*r+r-1];return 1}function W0(t,e,r,n,a,i){let s=arguments.length>6&&arguments[6]!==void 0?arguments[6]:!0;if(t<r||t<a)return rn("Insufficient number of samples. Underdetermined."),0;const o=ue(a);let c=1,u,g=0,f,l,p,d=0;if(s){for(l=0;l<a;l++)o[l]=1;for(f=0;f<t;f++)for(l=0;l<a;l++)Math.abs(n[f*a+l])>Wi&&(c=0,o[l]=0);if(c&&a===1)return rn("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()"),ai(t,e,r,i);if(c)d=1;else for(l=0;l<a;l++)o[l]&&(d=1)}d&&(u=ue(r),g=ai(t,e,r,u));const h=ue(r*r),T=ue(r*r),v=ue(r*a);for(p=0;p<t;p++)for(f=0;f<r;f++){for(l=f;l<r;l++)h[f*r+l]+=e[p*r+f]*e[p*r+l];for(l=0;l<a;l++)v[f*a+l]+=e[p*r+f]*n[p*a+l]}for(f=0;f<r;f++)for(l=0;l<f;l++)h[f*r+l]=h[l*r+f];const C=Nc(h,T,r);if(C)for(f=0;f<r;f++)for(l=0;l<a;l++)for(i[f*a+l]=0,p=0;p<r;p++)i[f*a+l]+=T[f*r+p]*v[p*a+l];if(d){for(l=0;l<a;l++)if(o[l])for(f=0;f<r;f++)i[f*a+l]=u[f*a]}return d?g&&C:C}function $0(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[0,.5,1];switch(t.length){case 3:return e[0]=parseInt(t[0],16)*17/255,e[1]=parseInt(t[1],16)*17/255,e[2]=parseInt(t[2],16)*17/255,e;case 4:return e[0]=parseInt(t[1],16)*17/255,e[1]=parseInt(t[2],16)*17/255,e[2]=parseInt(t[3],16)*17/255,e;case 6:return e[0]=parseInt(t.substr(0,2),16)/255,e[1]=parseInt(t.substr(2,2),16)/255,e[2]=parseInt(t.substr(4,2),16)/255,e;case 7:return e[0]=parseInt(t.substr(1,2),16)/255,e[1]=parseInt(t.substr(3,2),16)/255,e[2]=parseInt(t.substr(5,2),16)/255,e;case 9:return e[0]=parseInt(t.substr(1,2),16)/255,e[1]=parseInt(t.substr(3,2),16)/255,e[2]=parseInt(t.substr(5,2),16)/255,e[3]=parseInt(t.substr(7,2),16)/255,e;default:return e}}function _n(t,e){let r,n;const[a,i,s]=t,o=1/3,c=1/6,u=2/3;let g=a,f=a;i>g?g=i:i<f&&(f=i),s>g?g=s:s<f&&(f=s);const l=g;l>0?n=(g-f)/g:n=0,n>0?(a===g?r=c*(i-s)/(g-f):i===g?r=o+c*(s-a)/(g-f):r=u+c*(a-i)/(g-f),r<0&&(r+=1)):r=0,e[0]=r,e[1]=n,e[2]=l}function Yt(t,e){const[r,n,a]=t,i=1/3,s=1/6,o=2/3,c=5/6;let u,g,f;r>s&&r<=i?(g=1,u=(i-r)/s,f=0):r>i&&r<=.5?(g=1,f=(r-i)/s,u=0):r>.5&&r<=o?(f=1,g=(o-r)/s,u=0):r>o&&r<=c?(f=1,u=(r-o)/s,g=0):r>c&&r<=1?(u=1,f=(1-r)/s,g=0):(u=1,g=r/s,f=0),u=n*u+(1-n),g=n*g+(1-n),f=n*f+(1-n),u*=a,g*=a,f*=a,e[0]=u,e[1]=g,e[2]=f}function _c(t,e){const[r,n,a]=t;let i=(r+16)/116,s=n/500+i,o=i-a/200;i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,o**3>.008856?o**=3:o=(o-16/116)/7.787;const c=.9505,u=1,g=1.089;e[0]=c*s,e[1]=u*i,e[2]=g*o}function Gc(t,e){const[r,n,a]=t,i=.9505,s=1,o=1.089;let c=r/i,u=n/s,g=a/o;c>.008856?c**=1/3:c=7.787*c+16/116,u>.008856?u**=1/3:u=7.787*u+16/116,g>.008856?g**=1/3:g=7.787*g+16/116,e[0]=116*u-16,e[1]=500*(c-u),e[2]=200*(u-g)}function Uc(t,e){const[r,n,a]=t;let i=r*3.2406+n*-1.5372+a*-.4986,s=r*-.9689+n*1.8758+a*.0415,o=r*.0557+n*-.204+a*1.057;i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92,o>.0031308?o=1.055*o**(1/2.4)-.055:o*=12.92;let c=i;c<s&&(c=s),c<o&&(c=o),c>1&&(i/=c,s/=c,o/=c),i<0&&(i=0),s<0&&(s=0),o<0&&(o=0),e[0]=i,e[1]=s,e[2]=o}function Bc(t,e){let[r,n,a]=t;r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,a>.04045?a=((a+.055)/1.055)**2.4:a/=12.92,e[0]=r*.4124+n*.3576+a*.1805,e[1]=r*.2126+n*.7152+a*.0722,e[2]=r*.0193+n*.1192+a*.9505}function It(t,e){const r=[0,0,0];Bc(t,r),Gc(r,e)}function Qr(t,e){const r=[0,0,0];_c(t,r),Uc(r,e)}function xn(t){return t[0]=1,t[1]=-1,t[2]=1,t[3]=-1,t[4]=1,t[5]=-1,t}function Hr(t){return!(t[1]-t[0]<0)}function z0(t,e,r){return r[0]=Math.min(t[0],e[0]),r[1]=Math.max(t[0],e[0]),r[2]=Math.min(t[1],e[1]),r[3]=Math.max(t[1],e[1]),r[4]=Math.min(t[2],e[2]),r[5]=Math.max(t[2],e[2]),r}function Je(t,e,r){return t<e?e:t>r?r:t}function ii(t,e,r){let n=arguments.length>3&&arguments[3]!==void 0?arguments[3]:[0,0,0];return n[0]=Je(t[0],e[0],r[0]),n[1]=Je(t[1],e[1],r[1]),n[2]=Je(t[2],e[2],r[2]),n}function H0(t,e){let r=0;return e[0]!==e[1]&&(t<e[0]?r=e[0]:t>e[1]?r=e[1]:r=t,r=(r-e[0])/(e[1]-e[0])),r}const j0=ur("GetScalarTypeFittingRange"),b0=ur("GetAdjustedScalarRange");function K0(t,e){if(!t||!e)return 0;for(let r=0;r<6;r+=2)if(t[r]<e[r]||t[r]>e[r+1]||t[r+1]<e[r]||t[r+1]>e[r+1])return 0;return 1}function X0(t,e,r){if(!t||!e)return 0;for(let n=0;n<6;n+=2)if(t[n]+r[n/2]<e[n]||t[n]-r[n/2]>e[n+1]||t[n+1]+r[n/2]<e[n]||t[n+1]-r[n/2]>e[n+1])return 0;return 1}function A0(t,e,r){if(!t||!e||!r)return 0;for(let n=0;n<3;n++)if(t[n]+r[n]<e[2*n]||t[n]-r[n]>e[2*n+1])return 0;return 1}function Y0(t,e,r,n){const a=ue(3),i=ue(3),s=ue(3),o=ue(3),c=ue(3),u=ue(3);for(let x=0;x<3;++x)a[x]=t[x]-e[x],i[x]=e[x]-r[x],s[x]=r[x]-t[x],o[x]=-a[x],c[x]=-i[x],u[x]=-s[x];const g=Pe(o),f=Pe(c),l=Pe(s),p=ue(3);Te(a,i,p);const d=Pe(p),h=g*f*l/(2*d),T=2*d*d,v=f*f*b(a,u)/T,C=l*l*b(o,i)/T,S=g*g*b(s,c)/T;for(let x=0;x<3;++x)n[x]=v*t[x]+C*e[x]+S*r[x];return h}const q0=1/0,Z0=-1/0,Wc=t=>!Number.isFinite(t),{isFinite:P0,isNaN:si}=Number,Ir=si;function xt(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function J0(t){let e=-1,r=-1;for(let n=0;n<t.length;n++){const a=Math.abs(t[n]);a>e&&(r=n,e=a)}return r}function $c(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:3;const r=new Array(e),n=new Array(e);for(let i=0;i<e;++i)r[i]=i,n[i]=i;for(let i=e-1;i>0;i--){let s=-1/0,o=0,c=0;for(let u=0;u<=i;++u){const g=r[u];for(let f=0;f<=i;++f){const l=n[f],p=Math.abs(t[g+e*l]);p>s&&(s=p,o=u,c=f)}}[r[i],r[o]]=[r[o],r[i]],[n[i],n[c]]=[n[c],n[i]]}const a=new Array(e*e).fill(0);for(let i=0;i<e;++i){const s=r[i]+e*n[i];a[s]=t[s]<0?-1:1}return a}function zc(t){const e=Math.floor(t*255);return e>15?e.toString(16):`0${e.toString(16)}`}function Q0(t){return`${arguments.length>1&&arguments[1]!==void 0?arguments[1]:"#"}${t.map(zc).join("")}`}function yr(t){return Math.round(t*255)}function I0(t){return t.length===3?`rgb(${t.map(yr).join(", ")})`:`rgba(${yr(t[0]||0)}, ${yr(t[1]||0)}, ${yr(t[2]||0)}, ${t[3]||0})`}var st={Pi:t0,ldexp:n0,radiansFromDegrees:fe,degreesFromRadians:Tn,round:yt,floor:Qn,ceil:r0,ceilLog2:c0,min:a0,max:i0,arrayMin:s0,arrayMax:o0,arrayRange:xc,isPowerOfTwo:Nn,nearestPowerOfTwo:Nt,factorial:u0,binomial:f0,beginCombination:g0,nextCombination:l0,randomSeed:p0,getSeed:h0,random:d0,gaussian:T0,add:Qe,subtract:re,multiplyScalar:St,multiplyScalar2D:wc,multiplyAccumulate:Tt,multiplyAccumulate2D:v0,dot:b,outer:y0,cross:Te,norm:Pe,normalize:pe,perpendiculars:C0,projectVector:S0,projectVector2D:x0,distance2BetweenPoints:Ye,angleBetweenVectors:w0,gaussianAmplitude:R0,gaussianWeight:M0,dot2D:ti,outer2D:O0,norm2D:Mc,normalize2D:m0,determinant2x2:le,LUFactor3x3:E0,LUSolve3x3:D0,linearSolve3x3:V0,multiply3x3_vect3:$r,multiply3x3_mat3:ni,multiplyMatrix:L0,transpose3x3:hn,invert3x3:F0,identity3x3:mc,identity:Ec,isIdentity:k0,isIdentity3x3:N0,determinant3x3:va,quaternionToMatrix3x3:Dc,areEquals:Oc,areMatricesEqual:fr,roundNumber:zr,roundVector:ri,matrix3x3ToQuaternion:Vc,multiplyQuaternion:_0,orthogonalize3x3:Lc,diagonalize3x3:Fc,singularValueDecomposition3x3:G0,solveLinearSystem:kc,invertMatrix:Nc,luFactorLinearSystem:$i,luSolveLinearSystem:zi,estimateMatrixCondition:U0,jacobi:B0,jacobiN:gr,solveHomogeneousLeastSquares:ai,solveLeastSquares:W0,hex2float:$0,rgb2hsv:_n,hsv2rgb:Yt,lab2xyz:_c,xyz2lab:Gc,xyz2rgb:Uc,rgb2xyz:Bc,rgb2lab:It,lab2rgb:Qr,uninitializeBounds:xn,areBoundsInitialized:Hr,computeBoundsFromPoints:z0,clampValue:Je,clampVector:ii,clampAndNormalizeValue:H0,getScalarTypeFittingRange:j0,getAdjustedScalarRange:b0,extentIsWithinOtherExtent:K0,boundsIsWithinOtherBounds:X0,pointIsWithinBounds:A0,solve3PointCircle:Y0,inf:q0,negInf:Z0,isInf:Wc,isNan:si,isNaN:si,isFinite:P0,createUninitializedBounds:xt,getMajorAxisIndex:J0,getSparseOrthogonalMatrix:$c,floatToHex2:zc,floatRGB2HexCode:Q0,float2CssRGBA:I0};function eh(t,e){e.classHierarchy.push("vtkImplicitFunction"),t.functionValue=r=>{if(!e.transform)return t.evaluateFunction(r);const n=[];return e.transform.transformPoint(r,n),t.evaluateFunction(n)},t.evaluateFunction=r=>{y.vtkErrorMacro("not implemented")}}const th={};function Hc(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,th,r),y.obj(t,e),y.setGet(t,e,["transform"]),eh(t,e)}const nh=y.newInstance(Hc,"vtkImplicitFunction");var jc={newInstance:nh,extend:Hc};const oi=1e-6,bc="coincide",Kc="disjoint";function rh(t,e,r){return t[0]*(r[0]-e[0])+t[1]*(r[1]-e[1])+t[2]*(r[2]-e[2])}function Xc(t,e,r){const n=r[0]*(t[0]-e[0])+r[1]*(t[1]-e[1])+r[2]*(t[2]-e[2]);return Math.abs(n)}function Ac(t,e,r,n){const a=[];re(t,e,a);const i=b(r,a);n[0]=t[0]-i*r[0],n[1]=t[1]-i*r[1],n[2]=t[2]-i*r[2]}function Yc(t,e,r){const n=b(t,e);let a=b(e,e);return a===0&&(a=1),r[0]=t[0]-n*e[0]/a,r[1]=t[1]-n*e[1]/a,r[2]=t[2]-n*e[2]/a,r}function qc(t,e,r,n){const a=[];re(t,e,a);const i=b(r,a),s=b(r,r);s!==0?(n[0]=t[0]-i*r[0]/s,n[1]=t[1]-i*r[1]/s,n[2]=t[2]-i*r[2]/s):(n[0]=t[0],n[1]=t[1],n[2]=t[2])}function Zc(t,e,r,n){const a={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},i=[],s=[];re(e,t,i),re(r,t,s);const o=b(n,s),c=b(n,i);let u,g;return c<0?u=-c:u=c,o<0?g=-o*oi:g=o*oi,u<=g||(a.t=o/c,a.x[0]=t[0]+a.t*i[0],a.x[1]=t[1]+a.t*i[1],a.x[2]=t[2]+a.t*i[2],a.intersection=!0,a.betweenPoints=a.t>=0&&a.t<=1),a}function Pc(t,e,r,n){const a={intersection:!1,l0:[],l1:[],error:null},i=[];Te(e,n,i);const s=i.map(f=>Math.abs(f));if(s[0]+s[1]+s[2]<oi){const f=[];return re(t,r,f),b(e,f)===0?a.error=bc:a.error=Kc,a}let o;s[0]>s[1]&&s[0]>s[2]?o="x":s[1]>s[2]?o="y":o="z";const c=[],u=-b(e,t),g=-b(n,r);switch(o){case"x":c[0]=0,c[1]=(g*e[2]-u*n[2])/i[0],c[2]=(u*n[1]-g*e[1])/i[0];break;case"y":c[0]=(u*n[2]-g*e[2])/i[1],c[1]=0,c[2]=(g*e[0]-u*n[0])/i[1];break;case"z":c[0]=(g*e[1]-u*n[1])/i[2],c[1]=(u*n[0]-g*e[0])/i[2],c[2]=0;break}return a.l0=c,Qe(c,i,a.l1),a.intersection=!0,a}const ah={evaluate:rh,distanceToPlane:Xc,projectPoint:Ac,projectVector:Yc,generalizedProjectPoint:qc,intersectWithLine:Zc,intersectWithPlane:Pc,DISJOINT:Kc,COINCIDE:bc};function ih(t,e){e.classHierarchy.push("vtkPlane"),t.distanceToPlane=r=>Xc(r,e.origin,e.normal),t.projectPoint=(r,n)=>{Ac(r,e.origin,e.normal,n)},t.projectVector=(r,n)=>Yc(r,e.normal,n),t.push=r=>{if(r!==0)for(let n=0;n<3;n++)e.origin[n]+=r*e.normal[n]},t.generalizedProjectPoint=(r,n)=>{qc(r,e.origin,e.normal,n)},t.evaluateFunction=(r,n,a)=>Array.isArray(r)?e.normal[0]*(r[0]-e.origin[0])+e.normal[1]*(r[1]-e.origin[1])+e.normal[2]*(r[2]-e.origin[2]):e.normal[0]*(r-e.origin[0])+e.normal[1]*(n-e.origin[1])+e.normal[2]*(a-e.origin[2]),t.evaluateGradient=r=>[e.normal[0],e.normal[1],e.normal[2]],t.intersectWithLine=(r,n)=>Zc(r,n,e.origin,e.normal),t.intersectWithPlane=(r,n)=>Pc(r,n,e.origin,e.normal)}const sh={normal:[0,0,1],origin:[0,0,0]};function Jc(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,sh,r),jc.extend(t,e,r),y.setGetArray(t,e,["normal","origin"],3),ih(t,e)}const oh=y.newInstance(Jc,"vtkPlane");var be={newInstance:oh,extend:Jc,...ah};const ya=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function Qc(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]&&t[4]===e[4]&&t[5]===e[5]}function wt(t){return(t==null?void 0:t.length)>=6&&t[0]<=t[1]&&t[2]<=t[3]&&t[4]<=t[5]}function Hi(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t}function ji(t){return Hi(t,ya)}function ea(t,e,r,n){const[a,i,s,o,c,u]=t;return t[0]=a<e?a:e,t[1]=i>e?i:e,t[2]=s<r?s:r,t[3]=o>r?o:r,t[4]=c<n?c:n,t[5]=u>n?u:n,t}function bi(t,e){if(e.length===0)return t;if(Array.isArray(e[0]))for(let r=0;r<e.length;++r)ea(t,...e[r]);else for(let r=0;r<e.length;r+=3)ea(t,...e.slice(r,r+3));return t}function Ic(t,e,r,n,a,i,s){const[o,c,u,g,f,l]=t;return s===void 0?(t[0]=Math.min(e[0],o),t[1]=Math.max(e[1],c),t[2]=Math.min(e[2],u),t[3]=Math.max(e[3],g),t[4]=Math.min(e[4],f),t[5]=Math.max(e[5],l)):(t[0]=Math.min(e,o),t[1]=Math.max(r,c),t[2]=Math.min(n,u),t[3]=Math.max(a,g),t[4]=Math.min(i,f),t[5]=Math.max(s,l)),t}function eu(t,e,r,n){const[a,i,s,o,c,u]=t;return t[0]=e,t[1]=e>i?e:i,t[2]=r,t[3]=r>o?r:o,t[4]=n,t[5]=n>u?n:u,a!==e||s!==r||c!==n}function tu(t,e,r,n){const[a,i,s,o,c,u]=t;return t[0]=e<a?e:a,t[1]=e,t[2]=r<s?r:s,t[3]=r,t[4]=n<c?n:c,t[5]=n,i!==e||o!==r||u!==n}function nu(t,e){return t[0]-=e,t[1]+=e,t[2]-=e,t[3]+=e,t[4]-=e,t[5]+=e,t}function Ki(t,e,r,n){return wt(t)?(e>=0?(t[0]*=e,t[1]*=e):(t[0]=e*t[1],t[1]=e*t[0]),r>=0?(t[2]*=r,t[3]*=r):(t[2]=r*t[3],t[3]=r*t[2]),n>=0?(t[4]*=n,t[5]*=n):(t[4]=n*t[5],t[5]=n*t[4]),!0):!1}function Xi(t){return[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])]}function ch(t,e,r,n){if(!wt(t))return!1;const a=Xi(t);return t[0]-=a[0],t[1]-=a[0],t[2]-=a[1],t[3]-=a[1],t[4]-=a[2],t[5]-=a[2],Ki(t,e,r,n),t[0]+=a[0],t[1]+=a[0],t[2]+=a[1],t[3]+=a[1],t[4]+=a[2],t[5]+=a[2],!0}function An(t,e){return t[e*2+1]-t[e*2]}function Ca(t){return[An(t,0),An(t,1),An(t,2)]}function ru(t){return t.slice(0,2)}function au(t){return t.slice(2,4)}function iu(t){return t.slice(4,6)}function su(t){const e=Ca(t);return e[0]>e[1]?e[0]>e[2]?e[0]:e[2]:e[1]>e[2]?e[1]:e[2]}function ou(t){if(wt(t)){const e=Ca(t);return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2])}return null}function Ai(t){return[t[0],t[2],t[4]]}function Yi(t){return[t[1],t[3],t[5]]}function Cr(t,e){return t<=0&&e>=0||t>=0&&e<=0}function qi(t,e){let r=0;for(let n=0;n<2;n++)for(let a=2;a<4;a++)for(let i=4;i<6;i++)e[r++]=[t[n],t[a],t[i]];return e}function cu(t,e,r){return e[0]=t[0],e[1]=t[2],e[2]=t[4],r[0]=t[1],r[1]=t[3],r[2]=t[5],e}function uu(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:[];const n=qi(t,[]);for(let a=0;a<n.length;++a)q(n[a],n[a],e);return ji(r),bi(r,n)}function fu(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[];return e[0]=.5*(t[1]-t[0]),e[1]=.5*(t[3]-t[2]),e[2]=.5*(t[5]-t[4]),e}function gu(t,e,r,n){const a=[].concat(ya),i=t.getData();for(let s=0;s<i.length;s+=3){const o=[i[s],i[s+1],i[s+2]],c=b(o,e);a[0]=Math.min(c,a[0]),a[1]=Math.max(c,a[1]);const u=b(o,r);a[2]=Math.min(u,a[2]),a[3]=Math.max(u,a[3]);const g=b(o,n);a[4]=Math.min(g,a[4]),a[5]=Math.max(g,a[5])}return a}function lu(t,e,r,n,a){let i=!0;const s=[];let o=0;const c=[],u=[0,0,0],g=0,f=1,l=2;for(let p=0;p<3;p++)e[p]<t[2*p]?(s[p]=f,u[p]=t[2*p],i=!1):e[p]>t[2*p+1]?(s[p]=g,u[p]=t[2*p+1],i=!1):s[p]=l;if(i)return n[0]=e[0],n[1]=e[1],n[2]=e[2],a[0]=0,1;for(let p=0;p<3;p++)s[p]!==l&&r[p]!==0?c[p]=(u[p]-e[p])/r[p]:c[p]=-1;for(let p=0;p<3;p++)c[o]<c[p]&&(o=p);if(c[o]>1||c[o]<0)return 0;a[0]=c[o];for(let p=0;p<3;p++)if(o!==p){if(n[p]=e[p]+c[o]*r[p],n[p]<t[2*p]||n[p]>t[2*p+1])return 0}else n[p]=u[p];return 1}function pu(t,e,r){const n=[];let a=0,i=1,s=1;for(let o=4;o<=5;++o){n[2]=t[o];for(let c=2;c<=3;++c){n[1]=t[c];for(let u=0;u<=1;++u)if(n[0]=t[u],a=be.evaluate(r,e,n),s&&(i=a>=0?1:-1,s=0),a===0||i>0&&a<0||i<0&&a>0)return 1}}return 0}function hu(t,e){if(!(wt(t)&&wt(e)))return!1;const r=[0,0,0,0,0,0];let n;for(let a=0;a<3;a++)if(n=!1,e[a*2]>=t[a*2]&&e[a*2]<=t[a*2+1]?(n=!0,r[a*2]=e[a*2]):t[a*2]>=e[a*2]&&t[a*2]<=e[a*2+1]&&(n=!0,r[a*2]=t[a*2]),e[a*2+1]>=t[a*2]&&e[a*2+1]<=t[a*2+1]?(n=!0,r[a*2+1]=e[2*a+1]):t[a*2+1]>=e[a*2]&&t[a*2+1]<=e[a*2+1]&&(n=!0,r[a*2+1]=t[a*2+1]),!n)return!1;return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],!0}function ta(t,e){if(!(wt(t)&&wt(e)))return!1;for(let r=0;r<3;r++)if(!(e[r*2]>=t[r*2]&&e[r*2]<=t[r*2+1])&&!(t[r*2]>=e[r*2]&&t[r*2]<=e[r*2+1])&&!(e[r*2+1]>=t[r*2]&&e[r*2+1]<=t[r*2+1])&&!(t[r*2+1]>=e[r*2]&&t[r*2+1]<=e[r*2+1]))return!1;return!0}function na(t,e,r,n){return!(e<t[0]||e>t[1]||r<t[2]||r>t[3]||n<t[4]||n>t[5])}function uh(t,e){return!(!ta(t,e)||!na(t,...Ai(e))||!na(t,...Yi(e)))}function du(t,e,r){const n=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],a=[0,0,0,0,0,0,0,0];let i=0;for(let f=0;f<2;f++)for(let l=2;l<4;l++)for(let p=4;p<6;p++){const d=[t[f],t[l],t[p]];a[i++]=be.evaluate(r,e,d)}let s=2;for(;s--&&!(Cr(a[n[s][0]],a[n[s][4]])&&Cr(a[n[s][1]],a[n[s][5]])&&Cr(a[n[s][2]],a[n[s][6]])&&Cr(a[n[s][3]],a[n[s][7]])););if(s<0)return!1;const o=Math.sign(r[s]),c=Math.abs((t[s*2+1]-t[s*2])*r[s]);let u=o>0?1:0;for(let f=0;f<4;f++){if(c===0)continue;const l=Math.abs(a[n[s][f]])/c;o>0&&l<u&&(u=l),o<0&&l>u&&(u=l)}const g=(1-u)*t[s*2]+u*t[s*2+1];return o>0?t[s*2]=g:t[s*2+1]=g,!0}class fh{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(ya))}getBounds(){return this.bounds}equals(e){return Qc(this.bounds,e)}isValid(){return wt(this.bounds)}setBounds(e){return Hi(this.bounds,e)}reset(){return ji(this.bounds)}addPoint(){for(var e=arguments.length,r=new Array(e),n=0;n<e;n++)r[n]=arguments[n];return ea(this.bounds,...r)}addPoints(e){return bi(this.bounds,e)}addBounds(e,r,n,a,i,s){return Ic(this.bounds,e,r,n,a,i,s)}setMinPoint(e,r,n){return eu(this.bounds,e,r,n)}setMaxPoint(e,r,n){return tu(this.bounds,e,r,n)}inflate(e){return nu(this.bounds,e)}scale(e,r,n){return Ki(this.bounds,e,r,n)}getCenter(){return Xi(this.bounds)}getLength(e){return An(this.bounds,e)}getLengths(){return Ca(this.bounds)}getMaxLength(){return su(this.bounds)}getDiagonalLength(){return ou(this.bounds)}getMinPoint(){return Ai(this.bounds)}getMaxPoint(){return Yi(this.bounds)}getXRange(){return ru(this.bounds)}getYRange(){return au(this.bounds)}getZRange(){return iu(this.bounds)}getCorners(e){return qi(this.bounds,e)}computeCornerPoints(e,r){return cu(this.bounds,e,r)}computeLocalBounds(e,r,n){return gu(this.bounds,e,r,n)}transformBounds(e){let r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[];return uu(this.bounds,e,r)}computeScale3(e){return fu(this.bounds,e)}cutWithPlane(e,r){return du(this.bounds,e,r)}intersectBox(e,r,n,a){return lu(this.bounds,e,r,n,a)}intersectPlane(e,r){return pu(this.bounds,e,r)}intersect(e){return hu(this.bounds,e)}intersects(e){return ta(this.bounds,e)}containsPoint(e,r,n){return na(this.bounds,e,r,n)}contains(e){return ta(this.bounds,e)}}function gh(t){const e=t&&t.bounds;return new fh(e)}const Tu={equals:Qc,isValid:wt,setBounds:Hi,reset:ji,addPoint:ea,addPoints:bi,addBounds:Ic,setMinPoint:eu,setMaxPoint:tu,inflate:nu,scale:Ki,scaleAboutCenter:ch,getCenter:Xi,getLength:An,getLengths:Ca,getMaxLength:su,getDiagonalLength:ou,getMinPoint:Ai,getMaxPoint:Yi,getXRange:ru,getYRange:au,getZRange:iu,getCorners:qi,computeCornerPoints:cu,computeLocalBounds:gu,transformBounds:uu,computeScale3:fu,cutWithPlane:du,intersectBox:lu,intersectPlane:pu,intersect:hu,intersects:ta,containsPoint:na,contains:uh,INIT_BOUNDS:ya};var K={newInstance:gh,...Tu};function lh(t,e){t.getBounds=()=>(y.vtkErrorMacro("vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED"),xt()),t.getCenter=()=>{var n;const r=t.getBounds();return e.center=K.isValid(r)?K.getCenter(r):null,(n=e.center)==null?void 0:n.slice()},t.getLength=()=>{const r=t.getBounds();return K.getDiagonalLength(r)}}const ph=t=>({bounds:[...K.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...t});function hh(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,ph(r)),yc.extend(t,e,r),y.setGet(t,e,["viewSpecificProperties"]),lh(t,e)}var Zi={extend:hh};const dh={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},J={VOID:"",CHAR:"Int8Array",SIGNED_CHAR:"Int8Array",UNSIGNED_CHAR:"Uint8Array",UNSIGNED_CHAR_CLAMPED:"Uint8ClampedArray",SHORT:"Int16Array",UNSIGNED_SHORT:"Uint16Array",INT:"Int32Array",UNSIGNED_INT:"Uint32Array",FLOAT:"Float32Array",DOUBLE:"Float64Array"},Th=J.FLOAT;var vu={DefaultDataType:Th,DataTypeByteSize:dh,VtkDataTypes:J};const{vtkErrorMacro:vh}=We,{DefaultDataType:yh}=vu,Ch=1e-6;function ci(t,e,r){const n=t.length;let a=Number.MAX_VALUE,i=-Number.MAX_VALUE,s,o;for(o=e;o<n;o+=r)if(!Number.isNaN(t[o])){a=t[o],i=a;break}for(;o<n;o+=r)s=t[o],s<a?a=s:s>i&&(i=s);return{min:a,max:i}}function Sh(){let t=Number.MAX_VALUE,e=-Number.MAX_VALUE,r=0,n=0;return{add(a){t>a&&(t=a),e<a&&(e=a),r++,n+=a},get(){return{min:t,max:e,count:r,sum:n,mean:n/r}},getRange(){return{min:t,max:e}}}}function yu(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:1;if(e<0&&r>1){const a=t.length/r,i=new Float64Array(a);for(let s=0,o=0;s<a;++s){for(let c=o+r;o<c;++o)i[s]+=t[o]*t[o];i[s]**=.5}return ci(i,0,1)}return ci(t,e<0?0:e,r)}function _s(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0;const r=t||[];for(;r.length<=e;)r.push(null);return r}function Pi(t){return Object.prototype.toString.call(t).slice(8,-1)}function xh(t){const e=t.getNumberOfComponents();let r=0;const n=new Array(e);for(let a=0;a<t.getNumberOfTuples();++a){t.getTuple(a,n);const i=Pe(n,e);i>r&&(r=i)}return r}const wh={computeRange:yu,createRangeHelper:Sh,fastComputeRange:ci,getDataType:Pi,getMaxNorm:xh};function Rh(t,e){e.classHierarchy.push("vtkDataArray");function r(n){if(n<0)return!1;const a=t.getNumberOfComponents(),i=e.values.length/(a>0?a:1);if(n===i)return!0;if(n>i){const s=e.values;return e.values=ar(e.dataType,(n+i)*a),e.values.set(s),!0}return e.size>n*a&&(e.size=n*a,t.dataChange()),!0}t.dataChange=()=>{e.ranges=null,t.modified()},t.resize=n=>{r(n);const a=n*t.getNumberOfComponents();return e.size!==a?(e.size=a,t.dataChange(),!0):!1},t.initialize=()=>{t.resize(0)},t.getElementComponentSize=()=>e.values.BYTES_PER_ELEMENT,t.getComponent=function(n){let a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0;return e.values[n*e.numberOfComponents+a]},t.setComponent=(n,a,i)=>{i!==e.values[n*e.numberOfComponents+a]&&(e.values[n*e.numberOfComponents+a]=i,t.dataChange())},t.getValue=n=>{const a=n/e.numberOfComponents,i=n%e.numberOfComponents;return t.getComponent(a,i)},t.setValue=(n,a)=>{const i=n/e.numberOfComponents,s=n%e.numberOfComponents;t.setComponent(i,s,a)},t.getData=()=>e.size===e.values.length?e.values:e.values.subarray(0,e.size),t.getRange=function(){let n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:-1,a=n;a<0&&(a=e.numberOfComponents===1?0:e.numberOfComponents);let i=null;return e.ranges||(e.ranges=_s(e.ranges,e.numberOfComponents)),i=e.ranges[a],i?(e.rangeTuple[0]=i.min,e.rangeTuple[1]=i.max,e.rangeTuple):(i=yu(t.getData(),n,e.numberOfComponents),e.ranges[a]=i,e.rangeTuple[0]=i.min,e.rangeTuple[1]=i.max,e.rangeTuple)},t.setRange=(n,a)=>{e.ranges||(e.ranges=_s(e.ranges,e.numberOfComponents));const i={min:n.min,max:n.max};return e.ranges[a]=i,e.rangeTuple[0]=i.min,e.rangeTuple[1]=i.max,e.rangeTuple},t.setTuple=(n,a)=>{const i=n*e.numberOfComponents;for(let s=0;s<e.numberOfComponents;s++)e.values[i+s]=a[s]},t.setTuples=(n,a)=>{let i=n*e.numberOfComponents;const s=Math.min(a.length,e.size-i);for(let o=0;o<s;)e.values[i++]=a[o++]},t.insertTuple=(n,a)=>(e.size<=n*e.numberOfComponents&&(e.size=(n+1)*e.numberOfComponents,r(n+1)),t.setTuple(n,a),n),t.insertTuples=(n,a)=>{const i=n+a.length/e.numberOfComponents;return e.size<i*e.numberOfComponents&&(e.size=i*e.numberOfComponents,r(i)),t.setTuples(n,a),i},t.insertNextTuple=n=>{const a=e.size/e.numberOfComponents;return t.insertTuple(a,n)},t.insertNextTuples=n=>{const a=e.size/e.numberOfComponents;return t.insertTuples(a,n)},t.findTuple=function(n){let a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Ch;for(let i=0;i<e.size;i+=e.numberOfComponents)if(Math.abs(n[0]-e.values[i])<=a){let s=!0;for(let o=1;o<e.numberOfComponents;++o)if(Math.abs(n[o]-e.values[i+o])>a){s=!1;break}if(s)return i/e.numberOfComponents}return-1},t.getTuple=function(n){let a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[];const i=e.numberOfComponents||1,s=n*i;switch(i){case 4:a[3]=e.values[s+3];case 3:a[2]=e.values[s+2];case 2:a[1]=e.values[s+1];case 1:a[0]=e.values[s];break;default:for(let o=i-1;o>=0;--o)a[o]=e.values[s+o]}return a},t.getTuples=(n,a)=>{const i=(n??0)*e.numberOfComponents,s=(a??t.getNumberOfTuples())*e.numberOfComponents,o=t.getData().subarray(i,s);return o.length>0?o:null},t.getTupleLocation=function(){return(arguments.length>0&&arguments[0]!==void 0?arguments[0]:1)*e.numberOfComponents},t.getNumberOfComponents=()=>e.numberOfComponents,t.getNumberOfValues=()=>e.size,t.getNumberOfTuples=()=>e.size/e.numberOfComponents,t.getDataType=()=>e.dataType,t.newClone=()=>Su({empty:!0,name:e.name,dataType:e.dataType,numberOfComponents:e.numberOfComponents}),t.getName=()=>(e.name||(t.modified(),e.name=`vtkDataArray${t.getMTime()}`),e.name),t.setData=(n,a)=>{e.values=n,e.size=n.length,e.dataType=Pi(n),a&&(e.numberOfComponents=a),e.size%e.numberOfComponents!==0&&(e.numberOfComponents=1),t.dataChange()},t.getState=()=>{if(e.deleted)return null;const n={...e,vtkClass:t.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach(i=>{n[i]||delete n[i]});const a={};return Object.keys(n).sort().forEach(i=>{a[i]=n[i]}),a.mtime&&delete a.mtime,a},t.deepCopy=n=>{const a=t.getDataType(),i=e.values;t.shallowCopy(n),(i==null?void 0:i.length)>=n.getNumberOfValues()&&a===n.getDataType()?(i.set(n.getData()),e.values=i,t.dataChange()):t.setData(n.getData().slice())},t.interpolateTuple=(n,a,i,s,o,c)=>{const u=e.numberOfComponents||1;(u!==a.getNumberOfComponents()||u!==s.getNumberOfComponents())&&vh("numberOfComponents must match");const g=a.getTuple(i),f=s.getTuple(o),l=[];switch(l.length=u,u){case 4:l[3]=g[3]+(f[3]-g[3])*c;case 3:l[2]=g[2]+(f[2]-g[2])*c;case 2:l[1]=g[1]+(f[1]-g[1])*c;case 1:l[0]=g[0]+(f[0]-g[0])*c;break;default:for(let p=0;p<u;p++)l[p]=g[p]+(f[p]-g[p])*c}return t.insertTuple(n,l)}}const Mh={name:"",numberOfComponents:1,dataType:yh,rangeTuple:[0,0]};function Cu(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};if(Object.assign(e,Mh,r),Array.isArray(r.values)&&r.dataType===void 0&&console.warn("vtkDataArray.newInstance: no dataType provided, converting to Float32Array"),!e.empty&&!e.values&&!e.size)throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");if(e.values?Array.isArray(e.values)&&(e.values=ha(e.dataType,e.values)):e.values=ar(e.dataType,e.size),e.values&&(e.size=e.size??e.values.length,e.dataType=Pi(e.values)),xe(t,e),ir(t,e,["name","numberOfComponents"]),e.size%e.numberOfComponents!==0)throw new RangeError("model.size is not a multiple of model.numberOfComponents");Rh(t,e)}const Su=ye(Cu,"vtkDataArray");var A={newInstance:Su,extend:Cu,...wh,...vu};const{vtkErrorMacro:Gs,vtkWarningMacro:Oh}=y;function mh(t,e){e.classHierarchy.push("vtkFieldData");const r=t.getState;e.arrays&&(e.arrays=e.arrays.map(n=>({data:Ze(n.data)}))),t.initialize=()=>{t.initializeFields(),t.copyAllOn(),t.clearFieldFlags()},t.initializeFields=()=>{e.arrays=[],e.copyFieldFlags={},t.modified()},t.copyStructure=n=>{t.initializeFields(),e.copyFieldFlags=n.getCopyFieldFlags().map(a=>a),e.arrays=n.arrays().map(a=>({array:a}))},t.getNumberOfArrays=()=>e.arrays.length,t.getNumberOfActiveArrays=()=>e.arrays.length,t.addArray=n=>{const a=n.getName(),{array:i,index:s}=t.getArrayWithIndex(a);return i!=null?(e.arrays[s]={data:n},s):(e.arrays=[].concat(e.arrays,{data:n}),e.arrays.length-1)},t.removeAllArrays=()=>{e.arrays=[]},t.removeArray=n=>{const a=e.arrays.findIndex(i=>i.data.getName()===n);return t.removeArrayByIndex(a)},t.removeArrayByIndex=n=>n!==-1&&n<e.arrays.length?(e.arrays.splice(n,1),!0):!1,t.getArrays=()=>e.arrays.map(n=>n.data),t.getArray=n=>typeof n=="number"?t.getArrayByIndex(n):t.getArrayByName(n),t.getArrayByName=n=>e.arrays.reduce((a,i,s)=>i.data.getName()===n?i.data:a,null),t.getArrayWithIndex=n=>{const a=e.arrays.findIndex(i=>i.data.getName()===n);return{array:a!==-1?e.arrays[a].data:null,index:a}},t.getArrayByIndex=n=>n>=0&&n<e.arrays.length?e.arrays[n].data:null,t.hasArray=n=>t.getArrayWithIndex(n).index>=0,t.getArrayName=n=>{const a=e.arrays[n];return a?a.data.getName():""},t.getCopyFieldFlags=()=>e.copyFieldFlags,t.getFlag=n=>e.copyFieldFlags[n],t.passData=function(n){let a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:-1,i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:-1;n.getArrays().forEach(s=>{const o=t.getFlag(s.getName());if(o!==!1&&!(e.doCopyAllOff&&o!==!0)&&s){let c=t.getArrayByName(s.getName());if(c)if(s.getNumberOfComponents()===c.getNumberOfComponents())if(a>-1&&a<s.getNumberOfTuples()){const u=i>-1?i:a;c.insertTuple(u,s.getTuple(a))}else c.insertTuples(0,s.getTuples());else Gs("Unhandled case in passData");else if(a<0||a>s.getNumberOfTuples())t.addArray(s),n.getAttributes(s).forEach(u=>{t.setAttribute(s,u)});else{const u=s.getNumberOfComponents();let g=s.getNumberOfValues();const f=i>-1?i:a;g<=f*u&&(g=(f+1)*u),c=A.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:u,values:y.newTypedArray(s.getDataType(),g),size:0}),c.insertTuple(f,s.getTuple(a)),t.addArray(c),n.getAttributes(s).forEach(l=>{t.setAttribute(c,l)})}}})},t.interpolateData=function(n){let a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:-1,i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:-1,s=arguments.length>3&&arguments[3]!==void 0?arguments[3]:-1,o=arguments.length>4&&arguments[4]!==void 0?arguments[4]:.5;n.getArrays().forEach(c=>{const u=t.getFlag(c.getName());if(u!==!1&&!(e.doCopyAllOff&&u!==!0)&&c){let g=t.getArrayByName(c.getName());if(g)if(c.getNumberOfComponents()===g.getNumberOfComponents())if(a>-1&&a<c.getNumberOfTuples()){const f=s>-1?s:a;g.interpolateTuple(f,c,a,c,i,o),Oh("Unexpected case in interpolateData")}else g.insertTuples(c.getTuples());else Gs("Unhandled case in interpolateData");else if(a<0||i<0||a>c.getNumberOfTuples())t.addArray(c),n.getAttributes(c).forEach(f=>{t.setAttribute(c,f)});else{const f=c.getNumberOfComponents();let l=c.getNumberOfValues();const p=s>-1?s:a;l<=p*f&&(l=(p+1)*f),g=A.newInstance({name:c.getName(),dataType:c.getDataType(),numberOfComponents:f,values:y.newTypedArray(c.getDataType(),l),size:0}),g.interpolateTuple(p,c,a,c,i,o),t.addArray(g),n.getAttributes(c).forEach(d=>{t.setAttribute(g,d)})}}})},t.copyFieldOn=n=>{e.copyFieldFlags[n]=!0},t.copyFieldOff=n=>{e.copyFieldFlags[n]=!1},t.copyAllOn=()=>{(!e.doCopyAllOn||e.doCopyAllOff)&&(e.doCopyAllOn=!0,e.doCopyAllOff=!1,t.modified())},t.copyAllOff=()=>{(e.doCopyAllOn||!e.doCopyAllOff)&&(e.doCopyAllOn=!1,e.doCopyAllOff=!0,t.modified())},t.clearFieldFlags=()=>{e.copyFieldFlags={}},t.deepCopy=n=>{e.arrays=n.getArrays().map(a=>{const i=a.newClone();return i.deepCopy(a),{data:i}})},t.copyFlags=n=>n.getCopyFieldFlags().map(a=>a),t.reset=()=>e.arrays.forEach(n=>n.data.reset()),t.getMTime=()=>e.arrays.reduce((n,a)=>a.data.getMTime()>n?a.data.getMTime():n,e.mtime),t.getNumberOfComponents=()=>e.arrays.reduce((n,a)=>n+a.data.getNumberOfComponents(),0),t.getNumberOfTuples=()=>e.arrays.length>0?e.arrays[0].getNumberOfTuples():0,t.getState=()=>{const n=r();return n&&(n.arrays=e.arrays.map(a=>({data:a.data.getState()}))),n}}const Eh={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function xu(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Eh,r),y.obj(t,e),mh(t,e)}const Dh=y.newInstance(xu,"vtkFieldData");var Vh={newInstance:Dh,extend:xu};const Lh={SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},Fh={MAX:0,EXACT:1,NOLIMIT:2},kh={DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},Nh={DUPLICATEPOINT:1,HIDDENPOINT:2},_h={COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},Gh="vtkGhostType",Uh={DEFAULT:0,SINGLE:1,DOUBLE:2};var wu={AttributeCopyOperations:_h,AttributeLimitTypes:Fh,AttributeTypes:Lh,CellGhostTypes:kh,DesiredOutputPrecision:Uh,PointGhostTypes:Nh,ghostArrayName:Gh};const{AttributeTypes:Ot,AttributeCopyOperations:Wt}=wu,{vtkWarningMacro:Sr}=y;function Bh(t,e){const r=["Scalars","Vectors","Normals","TCoords","Tensors","GlobalIds","PedigreeIds"];function n(s){let o=r.find(c=>Ot[c.toUpperCase()]===s||typeof s!="number"&&c.toLowerCase()===s.toLowerCase());return typeof o>"u"&&(o=null),o}e.classHierarchy.push("vtkDataSetAttributes");const a={...t};t.checkNumberOfComponents=s=>!0,t.setAttribute=(s,o)=>{const c=n(o);if(s&&c.toUpperCase()==="PEDIGREEIDS"&&!s.isA("vtkDataArray"))return Sr(`Cannot set attribute ${c}. The attribute must be a vtkDataArray.`),-1;if(s&&!t.checkNumberOfComponents(s,c))return Sr(`Cannot set attribute ${c}. Incorrect number of components.`),-1;let u=e[`active${c}`];if(u>=0&&u<e.arrays.length){if(e.arrays[u]===s)return u;t.removeArrayByIndex(u)}return s?(u=t.addArray(s),e[`active${c}`]=u):e[`active${c}`]=-1,t.modified(),e[`active${c}`]},t.getAttributes=s=>r.filter(o=>t[`get${o}`]()===s),t.setActiveAttributeByName=(s,o)=>t.setActiveAttributeByIndex(t.getArrayWithIndex(s).index,o),t.setActiveAttributeByIndex=(s,o)=>{const c=n(o);if(s>=0&&s<e.arrays.length){if(c.toUpperCase()!=="PEDIGREEIDS"){const u=t.getArrayByIndex(s);if(!u.isA("vtkDataArray"))return Sr(`Cannot set attribute ${c}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!t.checkNumberOfComponents(u,c))return Sr(`Cannot set attribute ${c}. Incorrect number of components.`),-1}return e[`active${c}`]=s,t.modified(),s}return s===-1&&(e[`active${c}`]=s,t.modified()),-1},t.getActiveAttribute=s=>{const o=n(s);return t[`get${o}`]()},t.removeAllArrays=()=>{r.forEach(s=>{e[`active${s}`]=-1}),a.removeAllArrays()},t.removeArrayByIndex=s=>(s!==-1&&r.forEach(o=>{s===e[`active${o}`]?e[`active${o}`]=-1:s<e[`active${o}`]&&(e[`active${o}`]-=1)}),a.removeArrayByIndex(s)),r.forEach(s=>{const o=`active${s}`;t[`get${s}`]=()=>t.getArrayByIndex(e[o]),t[`set${s}`]=c=>t.setAttribute(c,s),t[`setActive${s}`]=c=>t.setActiveAttributeByIndex(t.getArrayWithIndex(c).index,s),t[`copy${s}Off`]=()=>{const c=s.toUpperCase();e.copyAttributeFlags[Wt.PASSDATA][Ot[c]]=!1},t[`copy${s}On`]=()=>{const c=s.toUpperCase();e.copyAttributeFlags[Wt.PASSDATA][Ot[c]]=!0}}),t.initializeAttributeCopyFlags=()=>{e.copyAttributeFlags=[],Object.keys(Wt).filter(s=>s!=="ALLCOPY").forEach(s=>{e.copyAttributeFlags[Wt[s]]=Object.keys(Ot).filter(o=>o!=="NUM_ATTRIBUTES").reduce((o,c)=>(o[Ot[c]]=!0,o),[])}),e.copyAttributeFlags[Wt.COPYTUPLE][Ot.GLOBALIDS]=!1,e.copyAttributeFlags[Wt.INTERPOLATE][Ot.GLOBALIDS]=!1,e.copyAttributeFlags[Wt.COPYTUPLE][Ot.PEDIGREEIDS]=!1},t.initialize=y.chain(t.initialize,t.initializeAttributeCopyFlags),e.dataArrays&&Object.keys(e.dataArrays).length&&Object.keys(e.dataArrays).forEach(s=>{!e.dataArrays[s].ref&&e.dataArrays[s].type==="vtkDataArray"&&t.addArray(A.newInstance(e.dataArrays[s]))});const i=t.shallowCopy;t.shallowCopy=(s,o)=>{i(s,o),e.arrays=s.getArrays().map(c=>{const u=c.newClone();return u.shallowCopy(c,o),{data:u}})},t.initializeAttributeCopyFlags()}const Wh={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function Ru(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Wh,r),Vh.extend(t,e,r),y.setGet(t,e,["activeScalars","activeNormals","activeTCoords","activeVectors","activeTensors","activeGlobalIds","activePedigreeIds"]),e.arrays||(e.arrays={}),Bh(t,e)}const $h=y.newInstance(Ru,"vtkDataSetAttributes");var Us={newInstance:$h,extend:Ru,...wu};const zh={UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},Mu={FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7};var Hh={FieldDataTypes:zh,FieldAssociations:Mu};const ui=["pointData","cellData","fieldData"];function jh(t,e){e.classHierarchy.push("vtkDataSet"),ui.forEach(n=>{e[n]?e[n]=Ze(e[n]):e[n]=Us.newInstance()});const r=t.shallowCopy;t.shallowCopy=function(n){let a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;r(n,a),ui.forEach(i=>{e[i]=Us.newInstance(),e[i].shallowCopy(n.getReferenceByName(i))})}}const bh={};function Ou(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,bh,r),y.obj(t,e),y.setGet(t,e,ui),jh(t,e)}const Kh=y.newInstance(Ou,"vtkDataSet");var wn={newInstance:Kh,extend:Ou,...Hh};const Xe={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var mu={StructuredType:Xe};const{StructuredType:gt}=mu;function Xh(t){let e=0;for(let r=0;r<3;++r)t[r*2]<t[r*2+1]&&e++;return t[0]>t[1]||t[2]>t[3]||t[4]>t[5]?gt.EMPTY:e===3?gt.XYZ_GRID:e===2?t[0]===t[1]?gt.YZ_PLANE:t[2]===t[3]?gt.XZ_PLANE:gt.XY_PLANE:e===1?t[0]<t[1]?gt.X_LINE:t[2]<t[3]?gt.Y_LINE:gt.Z_LINE:gt.SINGLE_POINT}var Ah={getDataDescriptionFromExtent:Xh,...mu};const{vtkErrorMacro:$t}=y;function Yh(t,e){e.classHierarchy.push("vtkImageData"),t.setExtent=function(){if(e.deleted)return $t("instance deleted - cannot call any method"),!1;for(var r=arguments.length,n=new Array(r),a=0;a<r;a++)n[a]=arguments[a];const i=n.length===1?n[0]:n;if(i.length!==6)return!1;const s=e.extent.some((o,c)=>o!==i[c]);return s&&(e.extent=i.slice(),e.dataDescription=Ah.getDataDescriptionFromExtent(e.extent),t.modified()),s},t.setDimensions=function(){let r,n,a;if(e.deleted){$t("instance deleted - cannot call any method");return}if(arguments.length===1){const i=arguments.length<=0?void 0:arguments[0];r=i[0],n=i[1],a=i[2]}else if(arguments.length===3)r=arguments.length<=0?void 0:arguments[0],n=arguments.length<=1?void 0:arguments[1],a=arguments.length<=2?void 0:arguments[2];else{$t("Bad dimension specification");return}t.setExtent(0,r-1,0,n-1,0,a-1)},t.getDimensions=()=>[e.extent[1]-e.extent[0]+1,e.extent[3]-e.extent[2]+1,e.extent[5]-e.extent[4]+1],t.getNumberOfCells=()=>{const r=t.getDimensions();let n=1;for(let a=0;a<3;a++){if(r[a]===0)return 0;r[a]>1&&(n*=r[a]-1)}return n},t.getNumberOfPoints=()=>{const r=t.getDimensions();return r[0]*r[1]*r[2]},t.getPoint=r=>{const n=t.getDimensions();if(n[0]===0||n[1]===0||n[2]===0)return $t("Requesting a point from an empty image."),null;const a=new Float64Array(3);switch(e.dataDescription){case Xe.EMPTY:return null;case Xe.SINGLE_POINT:break;case Xe.X_LINE:a[0]=r;break;case Xe.Y_LINE:a[1]=r;break;case Xe.Z_LINE:a[2]=r;break;case Xe.XY_PLANE:a[0]=r%n[0],a[1]=r/n[0];break;case Xe.YZ_PLANE:a[1]=r%n[1],a[2]=r/n[1];break;case Xe.XZ_PLANE:a[0]=r%n[0],a[2]=r/n[0];break;case Xe.XYZ_GRID:a[0]=r%n[0],a[1]=r/n[0]%n[1],a[2]=r/(n[0]*n[1]);break;default:$t("Invalid dataDescription");break}const i=[0,0,0];return t.indexToWorld(a,i),i},t.getBounds=()=>t.extentToBounds(t.getSpatialExtent()),t.extentToBounds=r=>K.transformBounds(r,e.indexToWorld),t.getSpatialExtent=()=>K.inflate([...e.extent],.5),t.computeTransforms=()=>{Sl(e.indexToWorld,e.origin),e.indexToWorld[0]=e.direction[0],e.indexToWorld[1]=e.direction[1],e.indexToWorld[2]=e.direction[2],e.indexToWorld[4]=e.direction[3],e.indexToWorld[5]=e.direction[4],e.indexToWorld[6]=e.direction[5],e.indexToWorld[8]=e.direction[6],e.indexToWorld[9]=e.direction[7],e.indexToWorld[10]=e.direction[8],nn(e.indexToWorld,e.indexToWorld,e.spacing),je(e.worldToIndex,e.indexToWorld)},t.indexToWorld=function(r){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[];return q(n,r,e.indexToWorld),n},t.indexToWorldVec3=t.indexToWorld,t.worldToIndex=function(r){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[];return q(n,r,e.worldToIndex),n},t.worldToIndexVec3=t.worldToIndex,t.indexToWorldBounds=function(r){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[];return K.transformBounds(r,e.indexToWorld,n)},t.worldToIndexBounds=function(r){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[];return K.transformBounds(r,e.worldToIndex,n)},t.onModified(t.computeTransforms),t.computeTransforms(),t.getCenter=()=>K.getCenter(t.getBounds()),t.computeHistogram=function(r){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:null;const a=[0,0,0,0,0,0];t.worldToIndexBounds(r,a);const i=[0,0,0],s=[0,0,0];K.computeCornerPoints(a,i,s),ri(i,i),ri(s,s);const o=t.getDimensions();ii(i,[0,0,0],[o[0]-1,o[1]-1,o[2]-1],i),ii(s,[0,0,0],[o[0]-1,o[1]-1,o[2]-1],s);const c=o[0],u=o[0]*o[1],g=t.getPointData().getScalars().getData();let f=-1/0,l=1/0,p=0,d=0,h=0;for(let S=i[2];S<=s[2];S++)for(let x=i[1];x<=s[1];x++){let R=i[0]+x*c+S*u;for(let O=i[0];O<=s[0];O++){if(!n||n([O,x,S],a)){const w=g[R];w>f&&(f=w),w<l&&(l=w),p+=w*w,d+=w,h+=1}++R}}const T=h>0?d/h:0,v=h?Math.abs(p/h-T*T):0,C=Math.sqrt(v);return{minimum:l,maximum:f,average:T,variance:v,sigma:C,count:h}},t.computeIncrements=function(r){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:1;const a=[];let i=n;for(let s=0;s<3;++s)a[s]=i,i*=r[s*2+1]-r[s*2]+1;return a},t.computeOffsetIndex=r=>{let[n,a,i]=r;const s=t.getExtent(),o=t.getPointData().getScalars().getNumberOfComponents(),c=t.computeIncrements(s,o);return Math.floor((Math.round(n)-s[0])*c[0]+(Math.round(a)-s[2])*c[1]+(Math.round(i)-s[4])*c[2])},t.getOffsetIndexFromWorld=r=>{const n=t.getExtent(),a=t.worldToIndex(r);for(let i=0;i<3;++i)if(a[i]<n[i*2]||a[i]>n[i*2+1])return $t(`GetScalarPointer: Pixel ${a} is not in memory. Current extent = ${n}`),NaN;return t.computeOffsetIndex(a)},t.getScalarValueFromWorld=function(r){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0;const a=t.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=a)return $t(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${a}`),NaN;const i=t.getOffsetIndexFromWorld(r);return Number.isNaN(i)?i:t.getPointData().getScalars().getComponent(i,n)}}const qh={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:Xe.EMPTY};function Eu(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,qh,r),wn.extend(t,e,r),e.direction?Array.isArray(e.direction)&&(e.direction=new Float64Array(e.direction.slice(0,9))):e.direction=ct(new Float64Array(9)),e.indexToWorld=new Float64Array(16),e.worldToIndex=new Float64Array(16),y.get(t,e,["indexToWorld","worldToIndex"]),y.setGetArray(t,e,["origin","spacing"],3),y.setGetArray(t,e,["direction"],9),y.getArray(t,e,["extent"],6),Yh(t,e)}const Zh=y.newInstance(Eu,"vtkImageData");var Ji={newInstance:Zh,extend:Eu};const Ph={MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},fi={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var Qi={VectorMode:Ph,ScalarMappingTarget:fi};const Jh={DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},Du={DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5},Qh={BY_ID:0,BY_NAME:1};var Sa={ColorMode:Jh,GetArray:Qh,ScalarMode:Du};const{ScalarMappingTarget:Bs,VectorMode:rt}=Qi,{VtkDataTypes:mt}=A,{ColorMode:xr}=Sa,{vtkErrorMacro:Ws}=y;function Ih(t){return t}function $s(t){return Math.floor(t*255+.5)}function ed(t,e){e.classHierarchy.push("vtkScalarsToColors"),t.setVectorModeToMagnitude=()=>t.setVectorMode(rt.MAGNITUDE),t.setVectorModeToComponent=()=>t.setVectorMode(rt.COMPONENT),t.setVectorModeToRGBColors=()=>t.setVectorMode(rt.RGBCOLORS),t.build=()=>{},t.isOpaque=()=>!0,t.setAnnotations=(r,n)=>{if(!(r&&!n||!r&&n)){if(r&&n&&r.length!==n.length){Ws("Values and annotations do not have the same number of tuples so ignoring");return}if(e.annotationArray=[],n&&r){const a=n.length;for(let i=0;i<a;i++)e.annotationArray.push({value:r[i],annotation:String(n[i])})}t.updateAnnotatedValueMap(),t.modified()}},t.setAnnotation=(r,n)=>{let a=t.checkForAnnotatedValue(r),i=!1;return a>=0?e.annotationArray[a].annotation!==n&&(e.annotationArray[a].annotation=n,i=!0):(e.annotationArray.push({value:r,annotation:n}),a=e.annotationArray.length-1,i=!0),i&&(t.updateAnnotatedValueMap(),t.modified()),a},t.getNumberOfAnnotatedValues=()=>e.annotationArray.length,t.getAnnotatedValue=r=>r<0||r>=e.annotationArray.length?null:e.annotationArray[r].value,t.getAnnotation=r=>e.annotationArray[r]===void 0?null:e.annotationArray[r].annotation,t.getAnnotatedValueIndex=r=>e.annotationArray.length?t.checkForAnnotatedValue(r):-1,t.removeAnnotation=r=>{const n=t.checkForAnnotatedValue(r),a=n>=0;return a&&(e.annotationArray.splice(n,1),t.updateAnnotatedValueMap(),t.modified()),a},t.resetAnnotations=()=>{e.annotationArray=[],e.annotatedValueMap=[],t.modified()},t.getAnnotationColor=(r,n)=>{if(e.indexedLookup){const a=t.getAnnotatedValueIndex(r);t.getIndexedColor(a,n)}else t.getColor(parseFloat(r),n),n[3]=1},t.checkForAnnotatedValue=r=>t.getAnnotatedValueIndexInternal(r),t.getAnnotatedValueIndexInternal=r=>{if(e.annotatedValueMap[r]!==void 0){const n=e.annotationArray.length;return e.annotatedValueMap[r]%n}return-1},t.getIndexedColor=(r,n)=>{n[0]=0,n[1]=0,n[2]=0,n[3]=0},t.updateAnnotatedValueMap=()=>{e.annotatedValueMap=[];const r=e.annotationArray.length;for(let n=0;n<r;n++)e.annotatedValueMap[e.annotationArray[n].value]=n},t.mapScalars=(r,n,a)=>{const i=r.getNumberOfComponents();let s=null;if(n===xr.DEFAULT&&(r.getDataType()===mt.UNSIGNED_CHAR||r.getDataType()===mt.UNSIGNED_CHAR_CLAMPED)||n===xr.DIRECT_SCALARS&&r)s=t.convertToRGBA(r,i,r.getNumberOfTuples());else{const o={type:"vtkDataArray",name:"temp",numberOfComponents:4,dataType:mt.UNSIGNED_CHAR},c=y.newTypedArray(o.dataType,4*r.getNumberOfTuples());o.values=c,o.size=c.length,s=A.newInstance(o);let u=a;u<0&&i>1?t.mapVectorsThroughTable(r,s,Bs.RGBA,-1,-1):(u<0&&(u=0),u>=i&&(u=i-1),t.mapScalarsThroughTable(r,s,Bs.RGBA,u))}return s},t.mapVectorsToMagnitude=(r,n,a)=>{const i=r.getNumberOfTuples(),s=r.getNumberOfComponents(),o=n.getData(),c=r.getData();for(let u=0;u<i;u++){let g=0;for(let f=0;f<a;f++)g+=c[u*s+f]*c[u*s+f];o[u]=Math.sqrt(g)}},t.mapVectorsThroughTable=(r,n,a,i,s)=>{let o=t.getVectorMode(),c=s,u=i;const g=r.getNumberOfComponents();o===rt.COMPONENT?(u===-1&&(u=t.getVectorComponent()),u<0&&(u=0),u>=g&&(u=g-1)):(c===-1&&(c=t.getVectorSize()),c<=0?(u=0,c=g):(u<0&&(u=0),u>=g&&(u=g-1),u+c>g&&(c=g-u)),o===rt.MAGNITUDE&&(g===1||c===1)&&(o=rt.COMPONENT));let f=0;switch(u>0&&(f=u),o){case rt.COMPONENT:{t.mapScalarsThroughTable(r,n,a,f);break}case rt.RGBCOLORS:break;case rt.MAGNITUDE:default:{const l=A.newInstance({numberOfComponents:1,values:new Float32Array(r.getNumberOfTuples())});t.mapVectorsToMagnitude(r,l,c),t.mapScalarsThroughTable(l,n,a,0);break}}},t.luminanceToRGBA=(r,n,a,i)=>{const s=i(a),o=n.getData(),c=r.getData(),u=o.length,g=0,f=1;let l=0;for(let p=g;p<u;p+=f){const d=i(o[p]);c[l*4]=d,c[l*4+1]=d,c[l*4+2]=d,c[l*4+3]=s,l++}},t.luminanceAlphaToRGBA=(r,n,a,i)=>{const s=n.getData(),o=r.getData(),c=s.length,u=0,g=2;let f=0;for(let l=u;l<c;l+=g){const p=i(s[l]);o[f]=p,o[f+1]=p,o[f+2]=p,o[f+3]=i(s[l+1])*a,f+=4}},t.rGBToRGBA=(r,n,a,i)=>{const s=$s(a),o=n.getData(),c=r.getData(),u=o.length,g=0,f=3;let l=0;for(let p=g;p<u;p+=f)c[l*4]=i(o[p]),c[l*4+1]=i(o[p+1]),c[l*4+2]=i(o[p+2]),c[l*4+3]=s,l++},t.rGBAToRGBA=(r,n,a,i)=>{const s=n.getData(),o=r.getData(),c=s.length,u=0,g=4;let f=0;for(let l=u;l<c;l+=g)o[f*4]=i(s[l]),o[f*4+1]=i(s[l+1]),o[f*4+2]=i(s[l+2]),o[f*4+3]=i(s[l+3])*a,f++},t.convertToRGBA=(r,n,a)=>{let{alpha:i}=e;if(n===4&&i>=1&&r.getDataType()===mt.UNSIGNED_CHAR)return r;const s=A.newInstance({numberOfComponents:4,empty:!0,size:4*a,dataType:mt.UNSIGNED_CHAR});if(a<=0)return s;i=i>0?i:0,i=i<1?i:1;let o=Ih;switch((r.getDataType()===mt.FLOAT||r.getDataType()===mt.DOUBLE)&&(o=$s),n){case 1:t.luminanceToRGBA(s,r,i,o);break;case 2:t.luminanceAlphaToRGBA(s,r,o);break;case 3:t.rGBToRGBA(s,r,i,o);break;case 4:t.rGBAToRGBA(s,r,i,o);break;default:return Ws("Cannot convert colors"),null}return s},t.usingLogScale=()=>!1,t.getNumberOfAvailableColors=()=>256*256*256,t.setRange=(r,n)=>t.setMappingRange(r,n),t.getRange=()=>t.getMappingRange(),t.areScalarsOpaque=(r,n,a)=>{if(!r)return t.isOpaque();const i=r.getNumberOfComponents();return n===xr.DEFAULT&&r.getDataType()===mt.UNSIGNED_CHAR||n===xr.DIRECT_SCALARS?i===3||i===1?e.alpha>=1:r.getRange(i-1)[0]===255:!0}}const td={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:rt.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1};function Vu(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,td,r),y.obj(t,e),e.mappingRange=[0,255],e.annotationArray=[],e.annotatedValueMap=[],y.setGet(t,e,["vectorSize","vectorComponent","vectorMode","alpha","indexedLookup"]),y.setArray(t,e,["mappingRange"],2),y.getArray(t,e,["mappingRange"]),ed(t,e)}const nd=y.newInstance(Vu,"vtkScalarsToColors");var Ii={newInstance:nd,extend:Vu,...Qi};const{vtkErrorMacro:zs}=y,Hs=0,js=1,Fa=2;function rd(t,e){e.classHierarchy.push("vtkLookupTable"),t.isOpaque=()=>{if(e.opaqueFlagBuildTime.getMTime()<t.getMTime()){let r=!0;e.nanColor[3]<1&&(r=0),e.useBelowRangeColor&&e.belowRangeColor[3]<1&&(r=0),e.useAboveRangeColor&&e.aboveRangeColor[3]<1&&(r=0);for(let n=3;n<e.table.length&&r;n+=4)e.table[n]<255&&(r=!1);e.opaqueFlag=r,e.opaqueFlagBuildTime.modified()}return e.opaqueFlag},t.usingLogScale=()=>!1,t.getNumberOfAvailableColors=()=>e.table.length/4-3,t.linearIndexLookup=(r,n)=>{let a=0;const i=Number(r);return i<n.range[0]?a=n.maxIndex+Hs+1.5:i>n.range[1]?a=n.maxIndex+js+1.5:(a=(i+n.shift)*n.scale,a=a<n.maxIndex?a:n.maxIndex),Math.floor(a)},t.linearLookup=(r,n,a)=>{let i=0;Ir(r)?i=Math.floor(a.maxIndex+1.5+Fa):i=t.linearIndexLookup(r,a);const s=4*i;return n.slice(s,s+4)},t.indexedLookupFunction=(r,n,a)=>{let i=t.getAnnotatedValueIndexInternal(r);i===-1&&(i=e.numberOfColors+Fa);const s=4*i;return[n[s],n[s+1],n[s+2],n[s+3]]},t.lookupShiftAndScale=(r,n)=>{n.shift=-r[0],n.scale=Number.MAX_VALUE,r[1]>r[0]&&(n.scale=(n.maxIndex+1)/(r[1]-r[0]))},t.mapScalarsThroughTable=(r,n,a,i)=>{let s=t.linearLookup;e.indexedLookup&&(s=t.indexedLookupFunction);const o=t.getMappingRange(),c={maxIndex:t.getNumberOfColors()-1,range:o,shift:0,scale:0};t.lookupShiftAndScale(o,c);const u=t.getAlpha(),g=r.getNumberOfTuples(),f=r.getNumberOfComponents(),l=n.getData(),p=r.getData();if(u>=1){if(a===fi.RGBA)for(let d=0;d<g;d++){const h=s(p[d*f+i],e.table,c);l[d*4]=h[0],l[d*4+1]=h[1],l[d*4+2]=h[2],l[d*4+3]=h[3]}}else if(a===fi.RGBA)for(let d=0;d<g;d++){const h=s(p[d*f+i],e.table,c);l[d*4]=h[0],l[d*4+1]=h[1],l[d*4+2]=h[2],l[d*4+3]=Math.floor(h[3]*u+.5)}},t.forceBuild=()=>{let r=0,n=0,a=0,i=0;const s=e.numberOfColors-1;s&&(r=(e.hueRange[1]-e.hueRange[0])/s,n=(e.saturationRange[1]-e.saturationRange[0])/s,a=(e.valueRange[1]-e.valueRange[0])/s,i=(e.alphaRange[1]-e.alphaRange[0])/s),e.table.length=4*s+16;const o=[],c=[];for(let u=0;u<=s;u++)o[0]=e.hueRange[0]+u*r,o[1]=e.saturationRange[0]+u*n,o[2]=e.valueRange[0]+u*a,Yt(o,c),c[3]=e.alphaRange[0]+u*i,e.table[u*4]=c[0]*255+.5,e.table[u*4+1]=c[1]*255+.5,e.table[u*4+2]=c[2]*255+.5,e.table[u*4+3]=c[3]*255+.5;t.buildSpecialColors(),e.buildTime.modified()},t.setTable=r=>{if(Array.isArray(r)){const a=r[0].length;e.numberOfColors=r.length;const i=4-a;let s=0;for(let o=0;o<e.numberOfColors;o++)e.table[o*4]=255,e.table[o*4+1]=255,e.table[o*4+2]=255,e.table[o*4+3]=255;for(let o=0;o<r.length;o++){const c=r[o];for(let u=0;u<a;u++)e.table[s++]=c[u];s+=i}return t.buildSpecialColors(),e.insertTime.modified(),t.modified(),!0}if(r.getNumberOfComponents()!==4)return zs("Expected 4 components for RGBA colors"),!1;if(r.getDataType()!==J.UNSIGNED_CHAR)return zs("Expected unsigned char values for RGBA colors"),!1;e.numberOfColors=r.getNumberOfTuples();const n=r.getData();e.table.length=n.length;for(let a=0;a<n.length;a++)e.table[a]=n[a];return t.buildSpecialColors(),e.insertTime.modified(),t.modified(),!0},t.buildSpecialColors=()=>{const{numberOfColors:r}=e,n=e.table;let a=(r+Hs)*4;e.useBelowRangeColor||r===0?(n[a]=e.belowRangeColor[0]*255+.5,n[a+1]=e.belowRangeColor[1]*255+.5,n[a+2]=e.belowRangeColor[2]*255+.5,n[a+3]=e.belowRangeColor[3]*255+.5):(n[a]=n[0],n[a+1]=n[1],n[a+2]=n[2],n[a+3]=n[3]),a=(r+js)*4,e.useAboveRangeColor||r===0?(n[a]=e.aboveRangeColor[0]*255+.5,n[a+1]=e.aboveRangeColor[1]*255+.5,n[a+2]=e.aboveRangeColor[2]*255+.5,n[a+3]=e.aboveRangeColor[3]*255+.5):(n[a]=n[4*(r-1)+0],n[a+1]=n[4*(r-1)+1],n[a+2]=n[4*(r-1)+2],n[a+3]=n[4*(r-1)+3]),a=(r+Fa)*4,n[a]=e.nanColor[0]*255+.5,n[a+1]=e.nanColor[1]*255+.5,n[a+2]=e.nanColor[2]*255+.5,n[a+3]=e.nanColor[3]*255+.5},t.build=()=>{(e.table.length<1||t.getMTime()>e.buildTime.getMTime()&&e.insertTime.getMTime()<=e.buildTime.getMTime())&&t.forceBuild()},e.table.length>0&&(t.buildSpecialColors(),e.insertTime.modified())}const ad={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function Lu(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,ad,r),Ii.extend(t,e,r),e.table||(e.table=[]),e.buildTime={},y.obj(e.buildTime),e.opaqueFlagBuildTime={},y.obj(e.opaqueFlagBuildTime,{mtime:0}),e.insertTime={},y.obj(e.insertTime,{mtime:0}),y.get(t,e,["buildTime"]),y.setGet(t,e,["numberOfColors","useAboveRangeColor","useBelowRangeColor"]),y.setArray(t,e,["alphaRange","hueRange","saturationRange","valueRange"],2),y.setArray(t,e,["nanColor","belowRangeColor","aboveRangeColor"],4),y.getArray(t,e,["hueRange","saturationRange","valueRange","alphaRange","nanColor","belowRangeColor","aboveRangeColor"]),rd(t,e)}const id=y.newInstance(Lu,"vtkLookupTable");var ra={newInstance:id,extend:Lu};const Ie={Off:0,PolygonOffset:1};let gi=Ie.PolygonOffset,aa=Ie.Off;const sd=["VTK_RESOLVE_OFF","VTK_RESOLVE_POLYGON_OFFSET"];function od(){return gi}function cd(t){const e=gi===t;return gi=t,e}function ud(){return aa}function xa(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;const e=aa===t;return aa=t,e}function fd(){return xa(Ie.Off)}function gd(){return xa(Ie.Off)}function ld(){return xa(Ie.PolygonOffset)}function pd(){return sd[aa]}var li={Resolve:Ie,getResolveCoincidentTopologyAsString:pd,getResolveCoincidentTopologyPolygonOffsetFaces:od,getResolveCoincidentTopology:ud,setResolveCoincidentTopology:xa,setResolveCoincidentTopologyPolygonOffsetFaces:cd,setResolveCoincidentTopologyToDefault:fd,setResolveCoincidentTopologyToOff:gd,setResolveCoincidentTopologyToPolygonOffset:ld};function Fu(t,e,r){r.forEach(n=>{t[`get${n.method}`]=()=>e[n.key],t[`set${n.method}`]=y.objectSetterMap.object(t,e,{name:n.key,params:["factor","offset"]})})}const wa=["Polygon","Line","Point"],hd={Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},dd=()=>{},qt={modified:dd};Fu(qt,hd,wa.map(t=>({key:t,method:`ResolveCoincidentTopology${t}OffsetParameters`})));function Td(t,e){e.resolveCoincidentTopology===void 0&&(e.resolveCoincidentTopology=!1),y.setGet(t,e,["resolveCoincidentTopology"]),e.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(li).forEach(r=>{t[r]=li[r]}),Object.keys(qt).filter(r=>r!=="modified").forEach(r=>{t[r]=qt[r]}),Fu(t,e.topologyOffset,wa.map(r=>({key:r,method:`RelativeCoincidentTopology${r}OffsetParameters`}))),t.getCoincidentTopologyPolygonOffsetParameters=()=>{const r=qt.getResolveCoincidentTopologyPolygonOffsetParameters(),n=t.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:r.factor+n.factor,offset:r.offset+n.offset}},t.getCoincidentTopologyLineOffsetParameters=()=>{const r=qt.getResolveCoincidentTopologyLineOffsetParameters(),n=t.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:r.factor+n.factor,offset:r.offset+n.offset}},t.getCoincidentTopologyPointOffsetParameter=()=>{const r=qt.getResolveCoincidentTopologyPointOffsetParameters(),n=t.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:r.factor+n.factor,offset:r.offset+n.offset}}}var Rn={implementCoincidentTopologyMethods:Td,staticOffsetAPI:qt,otherStaticMethods:li,CATEGORIES:wa,Resolve:Ie};const ke={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var ku={PassTypes:ke};const{FieldAssociations:bs}=wn,{staticOffsetAPI:vd,otherStaticMethods:yd}=Rn,{ColorMode:wr,ScalarMode:zt,GetArray:ka}=Sa,{VectorMode:Cd}=Qi,{VtkDataTypes:Sd}=A;function On(t){return()=>y.vtkErrorMacro(`vtkMapper::${t} - NOT IMPLEMENTED`)}function xd(t,e){const r=t[1]%2===0?1:-1;if(t[0]+=r,t[0]>=e[0]||t[0]<0){const n=t[2]%2===0?1:-1;t[0]-=r,t[1]+=n,(t[1]>=e[1]||t[1]<0)&&(t[1]-=n,t[2]++)}}function wd(t,e){return t[0]+e[0]*(t[1]+e[1]*t[2])}function Ks(t,e,r){const n=Math.floor(e),a=n%(2*r[0]);let i,s;a<r[0]?(t[0]=a,i=1,s=t[0]===r[0]-1):(t[0]=2*r[0]-1-a,i=-1,s=t[0]===0);const o=Math.floor(n/r[0]),c=o%(2*r[1]);let u,g;c<r[1]?(t[1]=c,u=1,g=t[1]===r[1]-1):(t[1]=2*r[1]-1-c,u=-1,g=t[1]===0),t[2]=Math.floor(o/r[1]);const f=e-n;s?g?t[2]+=f:t[1]+=u*f:t[0]+=i*f,t[0]=(t[0]+.5)/r[0],t[1]=(t[1]+.5)/r[1],t[2]=(t[2]+.5)/r[2]}const Xs=new WeakMap;function Rd(t,e,r,n,a,i,s){var N;const o=new Array(arguments.length);for(let G=0;G<arguments.length;++G){const _=arguments[G];o[G]=((N=_.getMTime)==null?void 0:N.call(_))??_}const c=o.join("/"),u=Xs.get(t);if(u&&u.stringHash===c)return u.textureCoordinates;const g=(r[1]-r[0])/(n-1),[f,l]=[r[0]-g,r[1]+g],p=f-.5*g,d=1/(l-f+g),h=f,T=(n+1)/(l-f),v=t.getData(),C=t.getNumberOfTuples(),S=t.getNumberOfComponents(),x=e<0||e>=S,R=a[2]<=1?2:3,O=A.newInstance({numberOfComponents:R,values:new Float32Array(C*R)}),w=O.getData(),m=[0,0,0];Ks(m,n+2,a);let E=0,M=0;const D=[.5,.5,.5];for(let G=0;G<C;++G){let _;if(x){let B=0;for(let F=0;F<S;++F){const z=v[E+F];B+=z*z}_=Math.sqrt(B)}else _=v[E+e];if(E+=S,i&&(_=ra.applyLogScale(_,r,r)),Ir(_))D[0]=m[0],D[1]=m[1],D[2]=m[2];else if(s){let B=(_-h)*T;B<1?B=0:B>n&&(B=n+1),Ks(D,B,a)}else{D[1]=.49;const B=(_-p)*d;B>1e3?D[0]=1e3:B<-1e3?D[0]=-1e3:D[0]=B}for(let B=0;B<R;++B)w[M++]=D[B]}return Xs.set(t,{stringHash:c,textureCoordinates:O}),O}function Md(t,e){e.classHierarchy.push("vtkMapper"),t.getBounds=()=>{const r=t.getInputData();return r?(e.static||t.update(),e.bounds=r.getBounds()):e.bounds=xt(),e.bounds},t.setForceCompileOnly=r=>{e.forceCompileOnly=r},t.setSelectionWebGLIdsToVTKIds=r=>{e.selectionWebGLIdsToVTKIds=r},t.createDefaultLookupTable=()=>{e.lookupTable=ra.newInstance()},t.getColorModeAsString=()=>y.enumToString(wr,e.colorMode),t.setColorModeToDefault=()=>t.setColorMode(0),t.setColorModeToMapScalars=()=>t.setColorMode(1),t.setColorModeToDirectScalars=()=>t.setColorMode(2),t.getScalarModeAsString=()=>y.enumToString(zt,e.scalarMode),t.setScalarModeToDefault=()=>t.setScalarMode(0),t.setScalarModeToUsePointData=()=>t.setScalarMode(1),t.setScalarModeToUseCellData=()=>t.setScalarMode(2),t.setScalarModeToUsePointFieldData=()=>t.setScalarMode(3),t.setScalarModeToUseCellFieldData=()=>t.setScalarMode(4),t.setScalarModeToUseFieldData=()=>t.setScalarMode(5),t.getAbstractScalars=(r,n,a,i,s)=>{if(!r||!e.scalarVisibility)return{scalars:null,cellFlag:!1};let o=null,c=!1;if(n===zt.DEFAULT)o=r.getPointData().getScalars(),o||(o=r.getCellData().getScalars(),c=!0);else if(n===zt.USE_POINT_DATA)o=r.getPointData().getScalars();else if(n===zt.USE_CELL_DATA)o=r.getCellData().getScalars(),c=!0;else if(n===zt.USE_POINT_FIELD_DATA){const u=r.getPointData();a===ka.BY_ID?o=u.getArrayByIndex(i):o=u.getArrayByName(s)}else if(n===zt.USE_CELL_FIELD_DATA){const u=r.getCellData();c=!0,a===ka.BY_ID?o=u.getArrayByIndex(i):o=u.getArrayByName(s)}else if(n===zt.USE_FIELD_DATA){const u=r.getFieldData();a===ka.BY_ID?o=u.getArrayByIndex(i):o=u.getArrayByName(s)}return{scalars:o,cellFlag:c}},t.mapScalars=(r,n)=>{const{scalars:a,cellFlag:i}=t.getAbstractScalars(r,e.scalarMode,e.arrayAccessMode,e.arrayId,e.colorByArrayName);if(e.areScalarsMappedFromCells=i,!a){e.colorCoordinates=null,e.colorTextureMap=null,e.colorMapColors=null;return}const s=`${t.getMTime()}${a.getMTime()}${n}`;if(e.colorBuildString!==s){if(e.useLookupTableScalarRange||t.getLookupTable().setRange(e.scalarRange[0],e.scalarRange[1]),t.canUseTextureMapForColoring(a,i))e.mapScalarsToTexture(a,i,n);else{e.colorCoordinates=null,e.colorTextureMap=null;const o=t.getLookupTable();o&&(o.build(),e.colorMapColors=o.mapScalars(a,e.colorMode,e.fieldDataTupleId))}e.colorBuildString=`${t.getMTime()}${a.getMTime()}${n}`}},e.mapScalarsToTexture=(r,n,a)=>{const i=e.lookupTable.getRange(),s=e.lookupTable.usingLogScale();s&&ra.getLogRange(i,i);const o=e.lookupTable.getAlpha();if(e.colorMapColors=null,e.colorTextureMap==null||t.getMTime()>e.colorTextureMap.getMTime()||e.lookupTable.getMTime()>e.colorTextureMap.getMTime()||e.lookupTable.getAlpha()!==a){e.lookupTable.setAlpha(a),e.colorTextureMap=null,e.lookupTable.build();const u=e.lookupTable.getNumberOfAvailableColors(),g=2048,f=g**3-3,p=4096-2,d=2,h=n?f:p;e.numberOfColorsInRange=Math.min(Math.max(u,d),h);const T=e.numberOfColorsInRange+3,v=e.numberOfColorsInRange+2,C=n?[Math.min(Math.ceil(T/g**0),g),Math.min(Math.ceil(T/g**1),g),Math.min(Math.ceil(T/g**2),g)]:[v,2,1],S=C[0]*C[1]*C[2],x=new Float64Array(S);x.fill(NaN);const R=e.numberOfColorsInRange,O=R+2,w=[0,0,0],m=i[0],E=i[1]-i[0];for(let N=0;N<O;++N){const G=wd(w,C),_=m+E*(N-1)/(R-1);x[G]=s?10**_:_,xd(w,C)}const M=A.newInstance({numberOfComponents:1,values:x}),D=e.lookupTable.mapScalars(M,e.colorMode,0);e.colorTextureMap=Ji.newInstance(),e.colorTextureMap.setDimensions(C),e.colorTextureMap.getPointData().setScalars(D),e.lookupTable.setAlpha(o)}const c=e.lookupTable.getVectorMode()===Cd.MAGNITUDE&&r.getNumberOfComponents()>1?-1:e.lookupTable.getVectorComponent();e.colorCoordinates=Rd(r,c,i,e.numberOfColorsInRange,e.colorTextureMap.getDimensions(),s,n)},t.getIsOpaque=()=>{const r=t.getInputData(),a=t.getAbstractScalars(r,e.scalarMode,e.arrayAccessMode,e.arrayId,e.colorByArrayName).scalars;if(!e.scalarVisibility||a==null)return!0;const i=t.getLookupTable();return i?(i.build(),i.areScalarsOpaque(a,e.colorMode,-1)):!0},t.canUseTextureMapForColoring=(r,n)=>n&&e.colorMode!==wr.DIRECT_SCALARS?!0:!(!e.interpolateScalarsBeforeMapping||e.lookupTable&&e.lookupTable.getIndexedLookup()||!r||e.colorMode===wr.DEFAULT&&r.getDataType()===Sd.UNSIGNED_CHAR||e.colorMode===wr.DIRECT_SCALARS),t.clearColorArrays=()=>{e.colorMapColors=null,e.colorCoordinates=null,e.colorTextureMap=null},t.getLookupTable=()=>(e.lookupTable||t.createDefaultLookupTable(),e.lookupTable),t.getMTime=()=>{let r=e.mtime;if(e.lookupTable!==null){const n=e.lookupTable.getMTime();r=n>r?n:r}return r},t.getPrimitiveCount=()=>{const r=t.getInputData();return{points:r.getPoints().getNumberOfValues()/3,verts:r.getVerts().getNumberOfValues()-r.getVerts().getNumberOfCells(),lines:r.getLines().getNumberOfValues()-2*r.getLines().getNumberOfCells(),triangles:r.getPolys().getNumberOfValues()-3*r.getPolys().getNumberOfCells()}},t.acquireInvertibleLookupTable=On("AcquireInvertibleLookupTable"),t.valueToColor=On("ValueToColor"),t.colorToValue=On("ColorToValue"),t.useInvertibleColorFor=On("UseInvertibleColorFor"),t.clearInvertibleColor=On("ClearInvertibleColor"),t.processSelectorPixelBuffers=(r,n)=>{if(!r||!e.selectionWebGLIdsToVTKIds||!e.populateSelectionSettings)return;const a=r.getRawPixelBuffer(ke.ID_LOW24),i=r.getRawPixelBuffer(ke.ID_HIGH24),s=r.getCurrentPass(),o=r.getFieldAssociation();let c=null;o===bs.FIELD_ASSOCIATION_POINTS?c=e.selectionWebGLIdsToVTKIds.points:o===bs.FIELD_ASSOCIATION_CELLS&&(c=e.selectionWebGLIdsToVTKIds.cells),c&&n.forEach(u=>{if(s===ke.ID_LOW24){let g=0;i&&(g+=i[u],g*=256),g+=a[u+2],g*=256,g+=a[u+1],g*=256,g+=a[u];const f=c[g],l=r.getPixelBuffer(ke.ID_LOW24);l[u]=f&255,l[u+1]=(f&65280)>>8,l[u+2]=(f&16711680)>>16}else if(s===ke.ID_HIGH24&&i){let g=0;g+=i[u],g*=256,g+=a[u+2],g*=256,g+=a[u+1],g*=256,g+=a[u];const f=c[g],l=r.getPixelBuffer(ke.ID_HIGH24);l[u]=(f&4278190080)>>24}})}}const Od={colorMapColors:null,areScalarsMappedFromCells:!1,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,numberOfColorsInRange:0,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function Nu(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Od,r),Zi.extend(t,e,r),y.get(t,e,["areScalarsMappedFromCells","colorCoordinates","colorMapColors","colorTextureMap","numberOfColorsInRange","selectionWebGLIdsToVTKIds"]),y.setGet(t,e,["colorByArrayName","arrayAccessMode","colorMode","fieldDataTupleId","interpolateScalarsBeforeMapping","lookupTable","populateSelectionSettings","renderTime","scalarMode","scalarVisibility","static","useLookupTableScalarRange","customShaderAttributes"]),y.setGetArray(t,e,["scalarRange"],2),Rn.implementCoincidentTopologyMethods(t,e),Md(t,e)}const md=y.newInstance(Nu,"vtkMapper");var lr={newInstance:md,extend:Nu,...vd,...yd,...Sa};const In={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},j={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var _u={Wrap:In,Filter:j};const Gu=new Float32Array(1),Ed=new Int32Array(Gu.buffer);function Dd(t){Gu[0]=t;const e=Ed[0];let r=e>>16&32768,n=e>>12&2047;const a=e>>23&255;return a<103?r:a>142?(r|=31744,r|=(a===255?0:1)&&e&8388607,r):a<113?(n|=2048,r|=(n>>114-a)+(n>>113-a&1),r):(r|=a-112<<10|n>>1,r+=n&1,r)}function Vd(t){const e=(t&32768)>>15,r=(t&31744)>>10,n=t&1023;return r===0?(e?-1:1)*2**-14*(n/2**10):r===31?n?NaN:(e?-1:1)*(1/0):(e?-1:1)*2**(r-15)*(1+n/2**10)}var un={fromHalf:Vd,toHalf:Dd};function Ld(){try{const n=new Int16Array([0,32767]),a=[1,1],i=document.createElement("canvas");i.width=4,i.height=4;const s=i.getContext("webgl2");if(!s)return!1;const o=s.getExtension("EXT_texture_norm16");if(!o)return!1;const c=`#version 300 es
    void main() {
      gl_PointSize = ${4 .toFixed(1)};
      gl_Position = vec4(0, 0, 0, 1);
    }
  `,u=`#version 300 es
    precision highp float;
    precision highp int;
    precision highp sampler2D;

    uniform sampler2D u_image;

    out vec4 color;

    void main() {
        vec4 intColor = texture(u_image, gl_PointCoord.xy);
        color = vec4(vec3(intColor.rrr), 1);
    }
    `,g=s.createShader(s.VERTEX_SHADER);if(s.shaderSource(g,c),s.compileShader(g),!s.getShaderParameter(g,s.COMPILE_STATUS))return!1;const f=s.createShader(s.FRAGMENT_SHADER);if(s.shaderSource(f,u),s.compileShader(f),!s.getShaderParameter(f,s.COMPILE_STATUS))return!1;const l=s.createProgram();if(s.attachShader(l,g),s.attachShader(l,f),s.linkProgram(l),!s.getProgramParameter(l,s.LINK_STATUS))return!1;const p=s.createTexture();s.bindTexture(s.TEXTURE_2D,p),s.texImage2D(s.TEXTURE_2D,0,o.R16_SNORM_EXT,2,1,0,s.RED,s.SHORT,n),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MAG_FILTER,s.LINEAR),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MIN_FILTER,s.LINEAR),s.useProgram(l),s.drawArrays(s.POINTS,0,1);const d=new Uint8Array(4);s.readPixels(a[0],a[1],1,1,s.RGBA,s.UNSIGNED_BYTE,d);const[h,T,v]=d,C=s.getExtension("WEBGL_lose_context");return C&&C.loseContext(),h===T&&T===v&&h!==0}catch{return!1}}let Na;function Fd(){return Na===void 0&&(Na=Ld()),Na}const{Wrap:dt,Filter:Ce}=_u,{VtkDataTypes:ee}=A,{vtkDebugMacro:_a,vtkErrorMacro:an,vtkWarningMacro:As}=We,{toHalf:kd}=un;function Nd(t,e){e.classHierarchy.push("vtkOpenGLTexture"),t.render=function(){let u=arguments.length>0&&arguments[0]!==void 0?arguments[0]:null;if(u?e._openGLRenderWindow=u:(e._openGLRenderer=t.getFirstAncestorOfType("vtkOpenGLRenderer"),e._openGLRenderWindow=e._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow")),e.context=e._openGLRenderWindow.getContext(),e.renderable.getInterpolate()?(e.generateMipmap?t.setMinificationFilter(Ce.LINEAR_MIPMAP_LINEAR):t.setMinificationFilter(Ce.LINEAR),t.setMagnificationFilter(Ce.LINEAR)):(t.setMinificationFilter(Ce.NEAREST),t.setMagnificationFilter(Ce.NEAREST)),e.renderable.getRepeat()&&(t.setWrapR(dt.REPEAT),t.setWrapS(dt.REPEAT),t.setWrapT(dt.REPEAT)),e.renderable.getInputData()&&e.renderable.setImage(null),!e.handle||e.renderable.getMTime()>e.textureBuildTime.getMTime()){if(e.renderable.getImage()!==null&&(e.renderable.getInterpolate()&&(e.generateMipmap=!0,t.setMinificationFilter(Ce.LINEAR_MIPMAP_LINEAR)),e.renderable.getImage()&&e.renderable.getImageLoaded()&&(t.create2DFromImage(e.renderable.getImage()),t.activate(),t.sendParameters(),e.textureBuildTime.modified())),e.renderable.getCanvas()!==null){e.renderable.getInterpolate()&&(e.generateMipmap=!0,t.setMinificationFilter(Ce.LINEAR_MIPMAP_LINEAR));const f=e.renderable.getCanvas();t.create2DFromRaw(f.width,f.height,4,ee.UNSIGNED_CHAR,f,!0),t.activate(),t.sendParameters(),e.textureBuildTime.modified()}if(e.renderable.getJsImageData()!==null){const f=e.renderable.getJsImageData();e.renderable.getInterpolate()&&(e.generateMipmap=!0,t.setMinificationFilter(Ce.LINEAR_MIPMAP_LINEAR)),t.create2DFromRaw(f.width,f.height,4,ee.UNSIGNED_CHAR,f.data,!0),t.activate(),t.sendParameters(),e.textureBuildTime.modified()}const g=e.renderable.getInputData(0);if(g&&g.getPointData().getScalars()){const f=g.getExtent(),l=g.getPointData().getScalars(),p=[];for(let d=0;d<e.renderable.getNumberOfInputPorts();++d){const h=e.renderable.getInputData(d),T=h?h.getPointData().getScalars().getData():null;T&&p.push(T)}e.renderable.getInterpolate()&&l.getNumberOfComponents()===4&&(e.generateMipmap=!0,t.setMinificationFilter(Ce.LINEAR_MIPMAP_LINEAR)),p.length%6===0?t.createCubeFromRaw(f[1]-f[0]+1,f[3]-f[2]+1,l.getNumberOfComponents(),l.getDataType(),p):t.create2DFromRaw(f[1]-f[0]+1,f[3]-f[2]+1,l.getNumberOfComponents(),l.getDataType(),l.getData()),t.activate(),t.sendParameters(),e.textureBuildTime.modified()}}e.handle&&t.activate()};const r=()=>{if(!((e.minificationFilter===Ce.LINEAR||e.magnificationFilter===Ce.LINEAR)&&!Fd()))return e.oglNorm16Ext};t.destroyTexture=()=>{t.deactivate(),e.context&&e.handle&&e.context.deleteTexture(e.handle),e.handle=0,e.numberOfDimensions=0,e.target=0,e.components=0,e.width=0,e.height=0,e.depth=0,t.resetFormatAndType()},t.createTexture=()=>{e.handle||(e.handle=e.context.createTexture(),e.target&&(e.context.bindTexture(e.target,e.handle),e.context.texParameteri(e.target,e.context.TEXTURE_MIN_FILTER,t.getOpenGLFilterMode(e.minificationFilter)),e.context.texParameteri(e.target,e.context.TEXTURE_MAG_FILTER,t.getOpenGLFilterMode(e.magnificationFilter)),e.context.texParameteri(e.target,e.context.TEXTURE_WRAP_S,t.getOpenGLWrapMode(e.wrapS)),e.context.texParameteri(e.target,e.context.TEXTURE_WRAP_T,t.getOpenGLWrapMode(e.wrapT)),e._openGLRenderWindow.getWebgl2()&&e.context.texParameteri(e.target,e.context.TEXTURE_WRAP_R,t.getOpenGLWrapMode(e.wrapR)),e.context.bindTexture(e.target,null)))},t.getTextureUnit=()=>e._openGLRenderWindow?e._openGLRenderWindow.getTextureUnitForTexture(t):-1,t.activate=()=>{e._openGLRenderWindow.activateTexture(t),t.bind()},t.deactivate=()=>{e._openGLRenderWindow&&e._openGLRenderWindow.deactivateTexture(t)},t.releaseGraphicsResources=u=>{u&&e.handle&&(u.activateTexture(t),u.deactivateTexture(t),e.context.deleteTexture(e.handle),e.handle=0,e.numberOfDimensions=0,e.target=0,e.internalFormat=0,e.format=0,e.openGLDataType=0,e.components=0,e.width=0,e.height=0,e.depth=0,e.allocatedGPUMemoryInBytes=0),e.shaderProgram&&(e.shaderProgram.releaseGraphicsResources(u),e.shaderProgram=null)},t.bind=()=>{e.context.bindTexture(e.target,e.handle),e.autoParameters&&t.getMTime()>e.sendParametersTime.getMTime()&&t.sendParameters()},t.isBound=()=>{let u=!1;if(e.context&&e.handle){let g=0;switch(e.target){case e.context.TEXTURE_2D:g=e.context.TEXTURE_BINDING_2D;break;default:As("impossible case");break}u=e.context.getIntegerv(g)===e.handle}return u},t.sendParameters=()=>{e.context.texParameteri(e.target,e.context.TEXTURE_WRAP_S,t.getOpenGLWrapMode(e.wrapS)),e.context.texParameteri(e.target,e.context.TEXTURE_WRAP_T,t.getOpenGLWrapMode(e.wrapT)),e._openGLRenderWindow.getWebgl2()&&e.context.texParameteri(e.target,e.context.TEXTURE_WRAP_R,t.getOpenGLWrapMode(e.wrapR)),e.context.texParameteri(e.target,e.context.TEXTURE_MIN_FILTER,t.getOpenGLFilterMode(e.minificationFilter)),e.context.texParameteri(e.target,e.context.TEXTURE_MAG_FILTER,t.getOpenGLFilterMode(e.magnificationFilter)),e._openGLRenderWindow.getWebgl2()&&(e.context.texParameteri(e.target,e.context.TEXTURE_BASE_LEVEL,e.baseLevel),e.context.texParameteri(e.target,e.context.TEXTURE_MAX_LEVEL,e.maxLevel)),e.sendParametersTime.modified()},t.getInternalFormat=(u,g)=>(e._forceInternalFormat||(e.internalFormat=t.getDefaultInternalFormat(u,g)),e.internalFormat||_a(`Unable to find suitable internal format for T=${u} NC= ${g}`),[e.context.R32F,e.context.RG32F,e.context.RGB32F,e.context.RGBA32F].includes(e.internalFormat)&&!e.context.getExtension("OES_texture_float_linear")&&As("Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats."),e.internalFormat),t.getDefaultInternalFormat=(u,g)=>{let f=0;return f=e._openGLRenderWindow.getDefaultTextureInternalFormat(u,g,r(),t.useHalfFloat()),f||(f||(_a("Unsupported internal texture type!"),_a(`Unable to find suitable internal format for T=${u} NC= ${g}`)),f)},t.useHalfFloat=()=>e.enableUseHalfFloat&&e.canUseHalfFloat,t.setInternalFormat=u=>{e._forceInternalFormat=!0,u!==e.internalFormat&&(e.internalFormat=u,t.modified())},t.getFormat=(u,g)=>(e.format=t.getDefaultFormat(u,g),e.format),t.getDefaultFormat=(u,g)=>{if(e._openGLRenderWindow.getWebgl2())switch(g){case 1:return e.context.RED;case 2:return e.context.RG;case 3:return e.context.RGB;case 4:return e.context.RGBA;default:return e.context.RGB}else switch(g){case 1:return e.context.LUMINANCE;case 2:return e.context.LUMINANCE_ALPHA;case 3:return e.context.RGB;case 4:return e.context.RGBA;default:return e.context.RGB}},t.resetFormatAndType=()=>{e.format=0,e.internalFormat=0,e._forceInternalFormat=!1,e.openGLDataType=0},t.getDefaultDataType=u=>{const g=t.useHalfFloat();if(e._openGLRenderWindow.getWebgl2())switch(u){case ee.UNSIGNED_CHAR:return e.context.UNSIGNED_BYTE;case(r()&&!g&&ee.SHORT):return e.context.SHORT;case(r()&&!g&&ee.UNSIGNED_SHORT):return e.context.UNSIGNED_SHORT;case(g&&ee.SHORT):return e.context.HALF_FLOAT;case(g&&ee.UNSIGNED_SHORT):return e.context.HALF_FLOAT;case ee.FLOAT:case ee.VOID:default:return e.context.FLOAT}switch(u){case ee.UNSIGNED_CHAR:return e.context.UNSIGNED_BYTE;case ee.FLOAT:case ee.VOID:default:if(e.context.getExtension("OES_texture_float")&&e.context.getExtension("OES_texture_float_linear"))return e.context.FLOAT;{const f=e.context.getExtension("OES_texture_half_float");if(f&&e.context.getExtension("OES_texture_half_float_linear"))return f.HALF_FLOAT_OES}return e.context.UNSIGNED_BYTE}},t.getOpenGLDataType=function(u){let g=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;return(!e.openGLDataType||g)&&(e.openGLDataType=t.getDefaultDataType(u)),e.openGLDataType},t.getShiftAndScale=()=>{let u=0,g=1;switch(e.openGLDataType){case e.context.BYTE:g=127.5,u=g-128;break;case e.context.UNSIGNED_BYTE:g=255,u=0;break;case e.context.SHORT:g=32767.5,u=g-32768;break;case e.context.UNSIGNED_SHORT:g=65536,u=0;break;case e.context.INT:g=21474836475e-1,u=g-2147483648;break;case e.context.UNSIGNED_INT:g=4294967295,u=0;break;case e.context.FLOAT:}return{shift:u,scale:g}},t.getOpenGLFilterMode=u=>{switch(u){case Ce.NEAREST:return e.context.NEAREST;case Ce.LINEAR:return e.context.LINEAR;case Ce.NEAREST_MIPMAP_NEAREST:return e.context.NEAREST_MIPMAP_NEAREST;case Ce.NEAREST_MIPMAP_LINEAR:return e.context.NEAREST_MIPMAP_LINEAR;case Ce.LINEAR_MIPMAP_NEAREST:return e.context.LINEAR_MIPMAP_NEAREST;case Ce.LINEAR_MIPMAP_LINEAR:return e.context.LINEAR_MIPMAP_LINEAR;default:return e.context.NEAREST}},t.getOpenGLWrapMode=u=>{switch(u){case dt.CLAMP_TO_EDGE:return e.context.CLAMP_TO_EDGE;case dt.REPEAT:return e.context.REPEAT;case dt.MIRRORED_REPEAT:return e.context.MIRRORED_REPEAT;default:return e.context.CLAMP_TO_EDGE}},t.updateArrayDataTypeForGL=function(u,g){let f=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1;const l=[];let p=e.width*e.height*e.components;if(f&&(p*=e.depth),u!==ee.FLOAT&&e.openGLDataType===e.context.FLOAT)for(let h=0;h<g.length;h++)if(g[h]){const T=g[h].length>p?g[h].subarray(0,p):g[h];l.push(new Float32Array(T))}else l.push(null);if(u!==ee.UNSIGNED_CHAR&&e.openGLDataType===e.context.UNSIGNED_BYTE)for(let h=0;h<g.length;h++)if(g[h]){const T=g[h].length>p?g[h].subarray(0,p):g[h];l.push(new Uint8Array(T))}else l.push(null);let d=!1;if(e._openGLRenderWindow.getWebgl2())d=e.openGLDataType===e.context.HALF_FLOAT;else{const h=e.context.getExtension("OES_texture_half_float");d=h&&e.openGLDataType===h.HALF_FLOAT_OES}if(d)for(let h=0;h<g.length;h++)if(g[h]){const T=new Uint16Array(p),v=g[h];for(let C=0;C<p;C++)T[C]=kd(v[C]);l.push(T)}else l.push(null);if(l.length===0)for(let h=0;h<g.length;h++)l.push(g[h]);return l};function n(u){if(e._openGLRenderWindow.getWebgl2())return u;const g=[],f=e.width,l=e.height,p=e.components;if(u&&(!Nn(f)||!Nn(l))){const d=e.context.getExtension("OES_texture_half_float"),h=Nt(f),T=Nt(l),v=h*T*e.components;for(let C=0;C<u.length;C++)if(u[C]!==null){let S=null;const x=l/T,R=f/h;let O=!1;e.openGLDataType===e.context.FLOAT?S=new Float32Array(v):d&&e.openGLDataType===d.HALF_FLOAT_OES?(S=new Uint16Array(v),O=!0):S=new Uint8Array(v);for(let w=0;w<T;w++){const m=w*h*p,E=w*x;let M=Math.floor(E),D=Math.ceil(E);D>=l&&(D=l-1);const N=E-M,G=1-N;M=M*f*p,D=D*f*p;for(let _=0;_<h;_++){const B=_*p,F=_*R;let z=Math.floor(F),U=Math.ceil(F);U>=f&&(U=f-1);const k=F-z;z*=p,U*=p;for(let L=0;L<p;L++)O?S[m+B+L]=un.toHalf(un.fromHalf(u[C][M+z+L])*G*(1-k)+un.fromHalf(u[C][M+U+L])*G*k+un.fromHalf(u[C][D+z+L])*N*(1-k)+un.fromHalf(u[C][D+U+L])*N*k):S[m+B+L]=u[C][M+z+L]*G*(1-k)+u[C][M+U+L]*G*k+u[C][D+z+L]*N*(1-k)+u[C][D+U+L]*N*k}}g.push(S),e.width=h,e.height=T}else g.push(null)}if(g.length===0)for(let d=0;d<u.length;d++)g.push(u[d]);return g}function a(u){var g;return e._openGLRenderWindow?e.resizable||(g=e.renderable)!=null&&g.getResizable()?!1:e._openGLRenderWindow.getWebgl2()?!(e._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&r()&&(u===ee.UNSIGNED_SHORT||u===ee.SHORT)):!1:!1}t.create2DFromRaw=function(u,g,f,l,p){let d=arguments.length>5&&arguments[5]!==void 0?arguments[5]:!1;if(t.getOpenGLDataType(l,!0),t.getInternalFormat(l,f),t.getFormat(l,f),!e.internalFormat||!e.format||!e.openGLDataType)return an("Failed to determine texture parameters."),!1;e.target=e.context.TEXTURE_2D,e.components=f,e.width=u,e.height=g,e.depth=1,e.numberOfDimensions=2,e._openGLRenderWindow.activateTexture(t),t.createTexture(),t.bind();const h=[p],T=t.updateArrayDataTypeForGL(l,h),v=n(T);return e.context.pixelStorei(e.context.UNPACK_FLIP_Y_WEBGL,d),e.context.pixelStorei(e.context.UNPACK_ALIGNMENT,1),a(l)?(e.context.texStorage2D(e.target,1,e.internalFormat,e.width,e.height),v[0]!=null&&e.context.texSubImage2D(e.target,0,0,0,e.width,e.height,e.format,e.openGLDataType,v[0])):e.context.texImage2D(e.target,0,e.internalFormat,e.width,e.height,0,e.format,e.openGLDataType,v[0]),e.generateMipmap&&e.context.generateMipmap(e.target),d&&e.context.pixelStorei(e.context.UNPACK_FLIP_Y_WEBGL,!1),e.allocatedGPUMemoryInBytes=e.width*e.height*e.depth*f*e._openGLRenderWindow.getDefaultTextureByteSize(l,r(),t.useHalfFloat()),t.deactivate(),!0},t.createCubeFromRaw=(u,g,f,l,p)=>{if(t.getOpenGLDataType(l),t.getInternalFormat(l,f),t.getFormat(l,f),!e.internalFormat||!e.format||!e.openGLDataType)return an("Failed to determine texture parameters."),!1;e.target=e.context.TEXTURE_CUBE_MAP,e.components=f,e.width=u,e.height=g,e.depth=1,e.numberOfDimensions=2,e._openGLRenderWindow.activateTexture(t),e.maxLevel=p.length/6-1,t.createTexture(),t.bind();const d=t.updateArrayDataTypeForGL(l,p),h=n(d),T=[];let v=e.width,C=e.height;for(let S=0;S<h.length;S++){S%6===0&&S!==0&&(v/=2,C/=2),T[S]=ar(l,C*v*e.components);for(let x=0;x<C;++x){const R=x*v*e.components,O=(C-x-1)*v*e.components;T[S].set(h[S].slice(O,O+v*e.components),R)}}e.context.pixelStorei(e.context.UNPACK_ALIGNMENT,1),a(l)&&e.context.texStorage2D(e.target,6,e.internalFormat,e.width,e.height);for(let S=0;S<6;S++){let x=0,R=e.width,O=e.height;for(;R>=1&&O>=1;){let w=null;x<=e.maxLevel&&(w=T[6*x+S]),a(l)?w!=null&&e.context.texSubImage2D(e.context.TEXTURE_CUBE_MAP_POSITIVE_X+S,x,0,0,R,O,e.format,e.openGLDataType,w):e.context.texImage2D(e.context.TEXTURE_CUBE_MAP_POSITIVE_X+S,x,e.internalFormat,R,O,0,e.format,e.openGLDataType,w),x++,R/=2,O/=2}}return e.allocatedGPUMemoryInBytes=e.width*e.height*e.depth*f*e._openGLRenderWindow.getDefaultTextureByteSize(l,r(),t.useHalfFloat()),t.deactivate(),!0},t.createDepthFromRaw=(u,g,f,l)=>(t.getOpenGLDataType(f),e.format=e.context.DEPTH_COMPONENT,e._openGLRenderWindow.getWebgl2()?f===ee.FLOAT?e.internalFormat=e.context.DEPTH_COMPONENT32F:e.internalFormat=e.context.DEPTH_COMPONENT16:e.internalFormat=e.context.DEPTH_COMPONENT,!e.internalFormat||!e.format||!e.openGLDataType?(an("Failed to determine texture parameters."),!1):(e.target=e.context.TEXTURE_2D,e.components=1,e.width=u,e.height=g,e.depth=1,e.numberOfDimensions=2,e._openGLRenderWindow.activateTexture(t),t.createTexture(),t.bind(),e.context.pixelStorei(e.context.UNPACK_ALIGNMENT,1),a(f)?(e.context.texStorage2D(e.target,1,e.internalFormat,e.width,e.height),l!=null&&e.context.texSubImage2D(e.target,0,0,0,e.width,e.height,e.format,e.openGLDataType,l)):e.context.texImage2D(e.target,0,e.internalFormat,e.width,e.height,0,e.format,e.openGLDataType,l),e.generateMipmap&&e.context.generateMipmap(e.target),e.allocatedGPUMemoryInBytes=e.width*e.height*e.depth*e.components*e._openGLRenderWindow.getDefaultTextureByteSize(f,r(),t.useHalfFloat()),t.deactivate(),!0)),t.create2DFromImage=u=>{if(t.getOpenGLDataType(ee.UNSIGNED_CHAR),t.getInternalFormat(ee.UNSIGNED_CHAR,4),t.getFormat(ee.UNSIGNED_CHAR,4),!e.internalFormat||!e.format||!e.openGLDataType)return an("Failed to determine texture parameters."),!1;e.target=e.context.TEXTURE_2D,e.components=4,e.depth=1,e.numberOfDimensions=2,e._openGLRenderWindow.activateTexture(t),t.createTexture(),t.bind(),e.context.pixelStorei(e.context.UNPACK_ALIGNMENT,1);const g=!e._openGLRenderWindow.getWebgl2()&&(!Nn(u.width)||!Nn(u.height)),f=document.createElement("canvas");f.width=g?Nt(u.width):u.width,f.height=g?Nt(u.height):u.height,e.width=f.width,e.height=f.height;const l=f.getContext("2d");l.translate(0,f.height),l.scale(1,-1),l.drawImage(u,0,0,u.width,u.height,0,0,f.width,f.height);const p=f;return a(ee.UNSIGNED_CHAR)?(e.context.texStorage2D(e.target,1,e.internalFormat,e.width,e.height),p!=null&&e.context.texSubImage2D(e.target,0,0,0,e.width,e.height,e.format,e.openGLDataType,p)):e.context.texImage2D(e.target,0,e.internalFormat,e.width,e.height,0,e.format,e.openGLDataType,p),e.generateMipmap&&e.context.generateMipmap(e.target),e.allocatedGPUMemoryInBytes=e.width*e.height*e.depth*e.components*e._openGLRenderWindow.getDefaultTextureByteSize(ee.UNSIGNED_CHAR,r(),t.useHalfFloat()),t.deactivate(),!0};function i(u,g,f){const l=new Array(f),p=new Array(f);for(let d=0;d<f;++d)l[d]=u[d],p[d]=g[d]-u[d]||1;return{scale:p,offset:l}}function s(u,g){for(let f=0;f<u.length;f++){const l=u[f],p=g[f]+l;if(l<-2048||l>2048||p<-2048||p>2048)return!1}return!0}function o(u,g,f,l){t.getOpenGLDataType(u);const p=s(g,f)||l;let d=!1;if(e._openGLRenderWindow.getWebgl2())d=e.openGLDataType===e.context.FLOAT&&e.context.getExtension("OES_texture_float_linear")===null&&p||e.openGLDataType===e.context.HALF_FLOAT;else{const h=e.context.getExtension("OES_texture_half_float");d=h&&e.openGLDataType===h.HALF_FLOAT_OES}e.canUseHalfFloat=d&&p}function c(u,g){const f=u.getNumberOfComponents(),l=u.getDataType(),p=u.getData(),d=new Array(f),h=new Array(f);for(let v=0;v<f;++v){const[C,S]=u.getRange(v);d[v]=C,h[v]=S}const T=i(d,h,f);return o(l,T.offset,T.scale,g),t.useHalfFloat()||t.getOpenGLDataType(l,!0),{numComps:f,dataType:l,data:p,scaleOffsets:T}}t.create2DFilterableFromRaw=function(u,g,f,l,p){let d=arguments.length>5&&arguments[5]!==void 0?arguments[5]:!1;return t.create2DFilterableFromDataArray(u,g,A.newInstance({numberOfComponents:f,dataType:l,values:p}),d)},t.create2DFilterableFromDataArray=function(u,g,f){let l=arguments.length>3&&arguments[3]!==void 0?arguments[3]:!1;const{numComps:p,dataType:d,data:h}=c(f,l);t.create2DFromRaw(u,g,p,d,h)},t.updateVolumeInfoForGL=(u,g)=>{var p,d;let f=!1;const l=t.useHalfFloat();(!((p=e.volumeInfo)!=null&&p.scale)||!((d=e.volumeInfo)!=null&&d.offset))&&(e.volumeInfo={scale:new Array(g),offset:new Array(g)});for(let h=0;h<g;++h)e.volumeInfo.scale[h]=1,e.volumeInfo.offset[h]=0;if(r()&&!l&&u===ee.SHORT){for(let h=0;h<g;++h)e.volumeInfo.scale[h]=32767;f=!0}if(r()&&!l&&u===ee.UNSIGNED_SHORT){for(let h=0;h<g;++h)e.volumeInfo.scale[h]=65535;f=!0}if(u===ee.UNSIGNED_CHAR){for(let h=0;h<g;++h)e.volumeInfo.scale[h]=255;f=!0}return(u===ee.FLOAT||l&&(u===ee.SHORT||u===ee.UNSIGNED_SHORT))&&(f=!0),f},t.create3DFromRaw=(u,g,f,l,p,d)=>{let h=p,T=d;if(!t.updateVolumeInfoForGL(h,l)&&T){const R=u*g*f,O=structuredClone(e.volumeInfo),w=new Float32Array(R*l);e.volumeInfo.offset=O.offset,e.volumeInfo.scale=O.scale;let m=0;const E=O.scale.map(M=>1/M);for(let M=0;M<R;M++)for(let D=0;D<l;D++)w[m]=(T[m]-O.offset[D])*E[D],m++;h=ee.FLOAT,T=w}if(t.getOpenGLDataType(h),t.getInternalFormat(h,l),t.getFormat(h,l),!e.internalFormat||!e.format||!e.openGLDataType)return an("Failed to determine texture parameters."),!1;e.target=e.context.TEXTURE_3D,e.components=l,e.width=u,e.height=g,e.depth=f,e.numberOfDimensions=3,e._openGLRenderWindow.activateTexture(t),t.createTexture(),t.bind();const v=[T],C=!0,S=t.updateArrayDataTypeForGL(h,v,C),x=n(S);return e.context.pixelStorei(e.context.UNPACK_ALIGNMENT,1),a(h)?(e.context.texStorage3D(e.target,1,e.internalFormat,e.width,e.height,e.depth),x[0]!=null&&e.context.texSubImage3D(e.target,0,0,0,0,e.width,e.height,e.depth,e.format,e.openGLDataType,x[0])):e.context.texImage3D(e.target,0,e.internalFormat,e.width,e.height,e.depth,0,e.format,e.openGLDataType,x[0]),e.generateMipmap&&e.context.generateMipmap(e.target),e.allocatedGPUMemoryInBytes=e.width*e.height*e.depth*e.components*e._openGLRenderWindow.getDefaultTextureByteSize(h,r(),t.useHalfFloat()),t.deactivate(),!0},t.create3DFilterableFromRaw=function(u,g,f,l,p,d){let h=arguments.length>6&&arguments[6]!==void 0?arguments[6]:!1;return t.create3DFilterableFromDataArray(u,g,f,A.newInstance({numberOfComponents:l,dataType:p,values:d}),h)},t.create3DFilterableFromDataArray=function(u,g,f,l){let p=arguments.length>4&&arguments[4]!==void 0?arguments[4]:!1;const{numComps:d,dataType:h,data:T,scaleOffsets:v}=c(l,p),C=[],S=[];for(let L=0;L<d;++L)C[L]=0,S[L]=1;if(e.volumeInfo={scale:S,offset:C,dataComputedScale:v.scale,dataComputedOffset:v.offset,width:u,height:g,depth:f},e._openGLRenderWindow.getWebgl2())return t.create3DFromRaw(u,g,f,d,h,T);const x=u*g*f,R=structuredClone(v);let O=(L,W,H,$,Q)=>{L[W]=H},w=ee.UNSIGNED_CHAR;if(h===ee.UNSIGNED_CHAR)for(let L=0;L<d;++L)R.offset[L]=0,R.scale[L]=255;else e.context.getExtension("OES_texture_float")&&e.context.getExtension("OES_texture_float_linear")?(w=ee.FLOAT,O=(L,W,H,$,Q)=>{L[W]=(H-$)/Q}):(w=ee.UNSIGNED_CHAR,O=(L,W,H,$,Q)=>{L[W]=255*(H-$)/Q});if(t.getOpenGLDataType(w),t.getInternalFormat(w,d),t.getFormat(w,d),!e.internalFormat||!e.format||!e.openGLDataType)return an("Failed to determine texture parameters."),!1;e.target=e.context.TEXTURE_2D,e.components=d,e.depth=1,e.numberOfDimensions=2;let m=e.context.getParameter(e.context.MAX_TEXTURE_SIZE);m>4096&&(w===ee.FLOAT||d>=3)&&(m=4096);let E=1,M=1;x>m*m&&(E=Math.ceil(Math.sqrt(x/(m*m))),M=E);let D=Math.sqrt(x)/E;D=Nt(D);const N=Math.floor(D*E/u),G=Math.ceil(f/N),_=Nt(g*G/M);e.width=D,e.height=_,e._openGLRenderWindow.activateTexture(t),t.createTexture(),t.bind(),e.volumeInfo.xreps=N,e.volumeInfo.yreps=G,e.volumeInfo.xstride=E,e.volumeInfo.ystride=M,e.volumeInfo.offset=R.offset,e.volumeInfo.scale=R.scale;let B;const F=D*_*d;w===ee.FLOAT?B=new Float32Array(F):B=new Uint8Array(F);let z=0;const U=Math.floor(u/E),k=Math.floor(g/M);for(let L=0;L<G;L++){const W=Math.min(N,f-L*N),H=d*(e.width-W*Math.floor(u/E));for(let $=0;$<k;$++){for(let Q=0;Q<W;Q++){const Mt=d*((L*N+Q)*u*g+M*$*u);for(let Ve=0;Ve<U;Ve++)for(let et=0;et<d;et++)O(B,z,T[Mt+E*Ve*d+et],R.offset[et],R.scale[et]),z++}z+=H}}return e.context.pixelStorei(e.context.UNPACK_ALIGNMENT,1),a(w)?(e.context.texStorage2D(e.target,1,e.internalFormat,e.width,e.height),B!=null&&e.context.texSubImage2D(e.target,0,0,0,e.width,e.height,e.format,e.openGLDataType,B)):e.context.texImage2D(e.target,0,e.internalFormat,e.width,e.height,0,e.format,e.openGLDataType,B),t.deactivate(),!0},t.setOpenGLRenderWindow=u=>{e._openGLRenderWindow!==u&&(t.releaseGraphicsResources(),e._openGLRenderWindow=u,e.context=null,u&&(e.context=e._openGLRenderWindow.getContext()))},t.getMaximumTextureSize=u=>u&&u.isCurrent()?u.getIntegerv(u.MAX_TEXTURE_SIZE):-1,t.enableUseHalfFloat=u=>{e.enableUseHalfFloat=u}}const _d={_openGLRenderWindow:null,_forceInternalFormat:!1,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:dt.CLAMP_TO_EDGE,wrapT:dt.CLAMP_TO_EDGE,wrapR:dt.CLAMP_TO_EDGE,minificationFilter:Ce.NEAREST,magnificationFilter:Ce.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0,enableUseHalfFloat:!0,canUseHalfFloat:!1};function Uu(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,_d,r),De.extend(t,e,r),e.sendParametersTime={},xe(e.sendParametersTime,{mtime:0}),e.textureBuildTime={},xe(e.textureBuildTime,{mtime:0}),ir(t,e,["format","openGLDataType"]),Me(t,e,["keyMatrixTime","minificationFilter","magnificationFilter","wrapS","wrapT","wrapR","generateMipmap","oglNorm16Ext"]),Ke(t,e,["width","height","volumeInfo","components","handle","target","allocatedGPUMemoryInBytes"]),or(t,e,["openGLRenderWindow"]),Nd(t,e)}const Bu=ye(Uu,"vtkOpenGLTexture");var he={newInstance:Bu,extend:Uu,..._u};Oe("vtkTexture",Bu);const Gd={DISPLAY:0,WORLD:1};var Wu={CoordinateSystem:Gd};const{CoordinateSystem:pi}=Wu;function Ys(t){return()=>y.vtkErrorMacro(`vtkProp::${t} - NOT IMPLEMENTED`)}function Ud(t,e){e.classHierarchy.push("vtkProp"),t.getMTime=()=>{let r=e.mtime;for(let n=0;n<e.textures.length;++n){const a=e.textures[n].getMTime();a>r&&(r=a)}return r},t.processSelectorPixelBuffers=(r,n)=>{},t.getNestedProps=()=>null,t.getActors=()=>[],t.getActors2D=()=>[],t.getVolumes=()=>[],t.pick=Ys("pick"),t.hasKey=Ys("hasKey"),t.getNestedVisibility=()=>e.visibility&&(!e._parentProp||e._parentProp.getNestedVisibility()),t.getNestedPickable=()=>e.pickable&&(!e._parentProp||e._parentProp.getNestedPickable()),t.getNestedDragable=()=>e.dragable&&(!e._parentProp||e._parentProp.getNestedDragable()),t.getRedrawMTime=()=>e.mtime,t.setEstimatedRenderTime=r=>{e.estimatedRenderTime=r,e.savedEstimatedRenderTime=r},t.restoreEstimatedRenderTime=()=>{e.estimatedRenderTime=e.savedEstimatedRenderTime},t.addEstimatedRenderTime=r=>{e.estimatedRenderTime+=r},t.setAllocatedRenderTime=r=>{e.allocatedRenderTime=r,e.savedEstimatedRenderTime=e.estimatedRenderTime,e.estimatedRenderTime=0},t.getSupportsSelection=()=>!1,t.getTextures=()=>e.textures,t.hasTexture=r=>e.textures.indexOf(r)!==-1,t.addTexture=r=>{r&&!t.hasTexture(r)&&(e.textures=e.textures.concat(r),t.modified())},t.removeTexture=r=>{const n=e.textures.filter(a=>a!==r);e.textures.length!==n.length&&(e.textures=n,t.modified())},t.removeAllTextures=()=>{e.textures=[],t.modified()},t.setCoordinateSystemToWorld=()=>t.setCoordinateSystem(pi.WORLD),t.setCoordinateSystemToDisplay=()=>t.setCoordinateSystem(pi.DISPLAY)}const Bd={allocatedRenderTime:10,coordinateSystem:pi.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function $u(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Bd,r),y.obj(t,e),y.get(t,e,["estimatedRenderTime","allocatedRenderTime"]),y.setGet(t,e,["_parentProp","coordinateSystem","dragable","pickable","renderTimeMultiplier","useBounds","visibility"]),y.moveToProtected(t,e,["parentProp"]),Ud(t,e)}const Wd=y.newInstance($u,"vtkProp");var pr={newInstance:Wd,extend:$u,...Wu};const{Representation:Gn,Interpolation:Un}=lc;function qs(t){return()=>y.vtkErrorMacro(`vtkProperty::${t} - NOT IMPLEMENTED`)}function $d(t,e){e.classHierarchy.push("vtkProperty"),t.setColor=(r,n,a)=>{Array.isArray(r)?(e.color[0]!==r[0]||e.color[1]!==r[1]||e.color[2]!==r[2])&&(e.color[0]=r[0],e.color[1]=r[1],e.color[2]=r[2],t.modified()):(e.color[0]!==r||e.color[1]!==n||e.color[2]!==a)&&(e.color[0]=r,e.color[1]=n,e.color[2]=a,t.modified()),t.setDiffuseColor(e.color),t.setAmbientColor(e.color),t.setSpecularColor(e.color)},t.computeCompositeColor=qs("ComputeCompositeColor"),t.getColor=()=>{let r=0;e.ambient+e.diffuse+e.specular>0&&(r=1/(e.ambient+e.diffuse+e.specular));for(let n=0;n<3;n++)e.color[n]=r*(e.ambient*e.ambientColor[n]+e.diffuse*e.diffuseColor[n]+e.specular*e.specularColor[n]);return[].concat(e.color)},t.setSpecularPower=r=>{const n=1/Math.max(1,r);(e.roughness!==n||e.specularPower!==r)&&(e.specularPower=r,e.roughness=n,t.modified())},t.addShaderVariable=qs("AddShaderVariable"),t.setInterpolationToFlat=()=>t.setInterpolation(Un.FLAT),t.setInterpolationToGouraud=()=>t.setInterpolation(Un.GOURAUD),t.setInterpolationToPhong=()=>t.setInterpolation(Un.PHONG),t.getInterpolationAsString=()=>y.enumToString(Un,e.interpolation),t.setRepresentationToWireframe=()=>t.setRepresentation(Gn.WIREFRAME),t.setRepresentationToSurface=()=>t.setRepresentation(Gn.SURFACE),t.setRepresentationToPoints=()=>t.setRepresentation(Gn.POINTS),t.getRepresentationAsString=()=>y.enumToString(Gn,e.representation)}const zd={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:Un.GOURAUD,representation:Gn.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null};function zu(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,zd,r),y.obj(t,e),y.setGet(t,e,["lighting","interpolation","ambient","diffuse","metallic","roughness","normalStrength","emission","baseIOR","specular","specularPower","opacity","edgeVisibility","lineWidth","pointSize","backfaceCulling","frontfaceCulling","representation","diffuseTexture","metallicTexture","roughnessTexture","normalTexture","ambientOcclusionTexture","emissionTexture"]),y.setGetArray(t,e,["ambientColor","specularColor","diffuseColor","edgeColor"],3),$d(t,e)}const Hd=y.newInstance(zu,"vtkProperty");var Ra={newInstance:Hd,extend:zu,...lc},es=`//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkPolyDataVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

attribute vec4 vertexMC;

// frag position in VC
//VTK::PositionVC::Dec

// optional normal declaration
//VTK::Normal::Dec

// extra lighting parameters
//VTK::Light::Dec

// Texture coordinates
//VTK::TCoord::Dec

// material property values
//VTK::Color::Dec

// clipping plane vars
//VTK::Clip::Dec

// camera and actor matrix values
//VTK::Camera::Dec

// Apple Bug
//VTK::PrimID::Dec

// picking support
//VTK::Picking::Dec

void main()
{
  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Clip::Impl

  //VTK::PrimID::Impl

  //VTK::PositionVC::Impl

  //VTK::Light::Impl

  //VTK::Picking::Impl
}
`,ts=`//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkPolyDataFS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// Template for the polydata mappers fragment shader

uniform int PrimitiveIDOffset;

// VC position of this fragment
//VTK::PositionVC::Dec

// optional color passed in from the vertex shader, vertexColor
//VTK::Color::Dec

// optional surface normal declaration
//VTK::Normal::Dec

// extra lighting parameters
//VTK::Light::Dec

// define vtkImageLabelOutlineOn
//VTK::ImageLabelOutlineOn

// Texture coordinates
//VTK::TCoord::Dec

// picking support
//VTK::Picking::Dec

// Depth Peeling Support
//VTK::DepthPeeling::Dec

// clipping plane vars
//VTK::Clip::Dec

// label outline 
//VTK::LabelOutline::Dec

// the output of this shader
//VTK::Output::Dec

// Apple Bug
//VTK::PrimID::Dec

// handle coincident offsets
//VTK::Coincident::Dec

//VTK::ZBuffer::Dec

//VTK::LabelOutlineHelperFunction

void main()
{
  // VC position of this fragment. This should not branch/return/discard.
  //VTK::PositionVC::Impl

  // Place any calls that require uniform flow (e.g. dFdx) here.
  //VTK::UniformFlow::Impl

  // Set gl_FragDepth here (gl_FragCoord.z by default)
  //VTK::Depth::Impl

  // Early depth peeling abort:
  //VTK::DepthPeeling::PreColor

  // Apple Bug
  //VTK::PrimID::Impl

  //VTK::Clip::Impl

  //VTK::Color::Impl

  // Generate the normal if we are not passed in one
  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Light::Impl

  if (gl_FragData[0].a <= 0.0)
    {
    discard;
    }

  //VTK::DepthPeeling::Impl

  //VTK::Picking::Impl

  // handle coincident offsets
  //VTK::Coincident::Impl

  //VTK::ZBuffer::Impl

  //VTK::RenderPassFragmentShader::Impl
}
`;function jd(t,e){t.replaceShaderCoincidentOffset=(r,n,a)=>{const i=t.getCoincidentParameters(n,a);if(i&&(i.factor!==0||i.offset!==0)){let s=r.Fragment;s=V.substitute(s,"//VTK::Coincident::Dec",["uniform float cfactor;","uniform float coffset;"]).result,e.context.getExtension("EXT_frag_depth")&&(i.factor!==0?(s=V.substitute(s,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,s=V.substitute(s,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):s=V.substitute(s,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result),e._openGLRenderWindow.getWebgl2()&&(i.factor!==0?(s=V.substitute(s,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,s=V.substitute(s,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):s=V.substitute(s,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result),r.Fragment=s}}}function bd(t,e){t.applyShaderReplacements=(r,n,a)=>{let i=null;if(n&&(i=n.ShaderReplacements),i)for(let s=0;s<i.length;s++){const o=i[s];if(a&&o.replaceFirst||!a&&!o.replaceFirst){const c=o.shaderType,u=r[c],g=V.substitute(u,o.originalValue,o.replacementValue,o.replaceAll);r[c]=g.result}}},t.buildShaders=(r,n,a)=>{t.getReplacedShaderTemplate(r,n,a),e.lastRenderPassShaderReplacement=e.currentRenderPass?e.currentRenderPass.getShaderReplacement():null,e.lastRenderPassShaderReplacement&&e.lastRenderPassShaderReplacement(r);const i=e.renderable.getViewSpecificProperties().OpenGL;t.applyShaderReplacements(r,i,!0),t.replaceShaderValues(r,n,a),t.applyShaderReplacements(r,i)},t.getReplacedShaderTemplate=(r,n,a)=>{const i=e.renderable.getViewSpecificProperties().OpenGL;t.getShaderTemplate(r,n,a);let s=r.Vertex;if(i){const u=i.VertexShaderCode;u!==void 0&&u!==""&&(s=u)}r.Vertex=s;let o=r.Fragment;if(i){const u=i.FragmentShaderCode;u!==void 0&&u!==""&&(o=u)}r.Fragment=o;let c=r.Geometry;if(i){const u=i.GeometryShaderCode;u!==void 0&&(c=u)}r.Geometry=c}}var ut={implementReplaceShaderCoincidentOffset:jd,implementBuildShadersWithReplacements:bd};const{FieldAssociations:Ga}=wn,{primTypes:Se}=ft,{Representation:sn,Shading:Zs}=Ra,{ScalarMode:Rr}=lr,{Filter:Ps,Wrap:Js}=he,{vtkErrorMacro:Ht}=We,Kd={type:"StartEvent"},Xd={type:"EndEvent"},{CoordinateSystem:Ad}=pr;function Yd(t){const e=t.getSelector();return e?e.getCurrentPass():ke.MIN_KNOWN_PASS-1}function qd(t,e){e.classHierarchy.push("vtkOpenGLPolyDataMapper"),t.buildPass=n=>{n&&(e.currentRenderPass=null,e.openGLActor=t.getFirstAncestorOfType("vtkOpenGLActor"),e._openGLRenderer=e.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer"),e._openGLRenderWindow=e._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),e.openGLCamera=e._openGLRenderer.getViewNodeFor(e._openGLRenderer.getRenderable().getActiveCamera()))},t.translucentPass=(n,a)=>{n&&(e.currentRenderPass=a,t.render())},t.zBufferPass=n=>{n&&(e.haveSeenDepthRequest=!0,e.renderDepth=!0,t.render(),e.renderDepth=!1)},t.opaqueZBufferPass=n=>t.zBufferPass(n),t.opaquePass=n=>{n&&t.render()},t.render=()=>{const n=e._openGLRenderWindow.getContext();if(e.context!==n){e.context=n;for(let s=Se.Start;s<Se.End;s++)e.primitives[s].setOpenGLRenderWindow(e._openGLRenderWindow)}const a=e.openGLActor.getRenderable(),i=e._openGLRenderer.getRenderable();t.renderPiece(i,a)},t.getShaderTemplate=(n,a,i)=>{n.Vertex=es,n.Fragment=ts,n.Geometry=""},t.replaceShaderColor=(n,a,i)=>{let s=n.Vertex,o=n.Geometry,c=n.Fragment;const u=e.lastBoundBO.getReferenceByName("lastLightComplexity");let g=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity","uniform vec3 ambientColorUniform;","uniform vec3 diffuseColorUniform;"];u&&(g=g.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let f=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];u&&(f=f.concat(["  vec3 specularColor;","  float specularPower;"])),f=f.concat(["  ambientColor = ambientColorUniform;","  diffuseColor = diffuseColorUniform;","  opacity = opacityUniform;"]),u&&(f=f.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),e.lastBoundBO.getCABO().getColorComponents()!==0&&!e.drawingEdges&&(g=g.concat(["varying vec4 vertexColorVSOutput;"]),s=V.substitute(s,"//VTK::Color::Dec",["attribute vec4 scalarColor;","varying vec4 vertexColorVSOutput;"]).result,s=V.substitute(s,"//VTK::Color::Impl",["vertexColorVSOutput =  scalarColor;"]).result,o=V.substitute(o,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,o=V.substitute(o,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result),e.lastBoundBO.getCABO().getColorComponents()!==0&&!e.drawingEdges?c=V.substitute(c,"//VTK::Color::Impl",f.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])).result:(e.renderable.getAreScalarsMappedFromCells()||e.renderable.getInterpolateScalarsBeforeMapping())&&e.renderable.getColorCoordinates()&&!e.drawingEdges?c=V.substitute(c,"//VTK::Color::Impl",f.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);","  diffuseColor = texColor.rgb;","  ambientColor = texColor.rgb;","  opacity = opacity*texColor.a;"])).result:(i.getBackfaceProperty()&&!e.drawingEdges&&(g=g.concat(["uniform float opacityUniformBF; // the fragment opacity","uniform float ambientIntensityBF; // the material ambient","uniform float diffuseIntensityBF; // the material diffuse","uniform vec3 ambientColorUniformBF; // ambient material color","uniform vec3 diffuseColorUniformBF; // diffuse material color"]),u?(g=g.concat(["uniform float specularIntensityBF; // the material specular intensity","uniform vec3 specularColorUniformBF; // intensity weighted color","uniform float specularPowerUniformBF;"]),f=f.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  specularColor = specularIntensityBF * specularColorUniformBF;","  specularPower = specularPowerUniformBF;","  opacity = opacityUniformBF; }"])):f=f.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  opacity = opacityUniformBF; }"])),e.haveCellScalars&&!e.drawingEdges&&(g=g.concat(["uniform samplerBuffer texture1;"])),c=V.substitute(c,"//VTK::Color::Impl",f).result),c=V.substitute(c,"//VTK::Color::Dec",g).result,n.Vertex=s,n.Geometry=o,n.Fragment=c},t.replaceShaderLight=(n,a,i)=>{let s=n.Fragment;const o="",c=e.lastBoundBO.getReferenceByName("lastLightComplexity"),u=e.lastBoundBO.getReferenceByName("lastLightCount");let g=[];switch(c){case 0:s=V.substitute(s,"//VTK::Light::Impl",["  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);","  //VTK::Light::Impl"],!1).result;break;case 1:s=V.substitute(s,"//VTK::Light::Impl",["  float df = max(0.0, normalVCVSOutput.z);","  float sf = pow(df, specularPower);","  vec3 diffuseL = df * diffuseColor;","  vec3 specularL = sf * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"],!1).result;break;case 2:for(let f=0;f<u;++f)g=g.concat([`uniform vec3 lightColor${f};`,`uniform vec3 lightDirectionVC${f}; // normalized`,`uniform vec3 lightHalfAngleVC${f}; // normalized`]);s=V.substitute(s,"//VTK::Light::Dec",g).result,g=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  float df;"];for(let f=0;f<u;++f)g=g.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${f}));`,`  diffuseL += ((df${o}) * lightColor${f});`,`  if (dot(normalVCVSOutput, lightDirectionVC${f}) < 0.0)`,"    {",`    float sf = sign(df)*pow(max(1e-5,
                                              dot(reflect(lightDirectionVC${f},normalVCVSOutput),
                                                  normalize(-vertexVC.xyz))),
                                         specularPower);`,`    specularL += (sf${o} * lightColor${f});`,"    }"]);g=g.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),s=V.substitute(s,"//VTK::Light::Impl",g,!1).result;break;case 3:for(let f=0;f<u;++f)g=g.concat([`uniform vec3 lightColor${f};`,`uniform vec3 lightDirectionVC${f}; // normalized`,`uniform vec3 lightHalfAngleVC${f}; // normalized`,`uniform vec3 lightPositionVC${f};`,`uniform vec3 lightAttenuation${f};`,`uniform float lightConeAngle${f};`,`uniform float lightExponent${f};`,`uniform int lightPositional${f};`]);s=V.substitute(s,"//VTK::Light::Dec",g).result,g=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  vec3 vertLightDirectionVC;","  float attenuation;","  float df;"];for(let f=0;f<u;++f)g=g.concat(["  attenuation = 1.0;",`  if (lightPositional${f} == 0)`,"    {",`      vertLightDirectionVC = lightDirectionVC${f};`,"    }","  else","    {",`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${f};`,"    float distanceVC = length(vertLightDirectionVC);","    vertLightDirectionVC = normalize(vertLightDirectionVC);","    attenuation = 1.0 /",`      (lightAttenuation${f}.x`,`       + lightAttenuation${f}.y * distanceVC`,`       + lightAttenuation${f}.z * distanceVC * distanceVC);`,"    // per OpenGL standard cone angle is 90 or less for a spot light",`    if (lightConeAngle${f} <= 90.0)`,"      {",`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${f});`,"      // if inside the cone",`      if (coneDot >= cos(radians(lightConeAngle${f})))`,"        {",`        attenuation = attenuation * pow(coneDot, lightExponent${f});`,"        }","      else","        {","        attenuation = 0.0;","        }","      }","    }","    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));",`    diffuseL += ((df${o}) * lightColor${f});`,"    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)","      {",`      float sf = sign(df)*attenuation*pow(max(1e-5,
                                                           dot(reflect(lightDirectionVC${f},
                                                                       normalVCVSOutput),
                                                               normalize(-vertexVC.xyz))),
                                                       specularPower);`,`    specularL += ((sf${o}) * lightColor${f});`,"    }"]);g=g.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),s=V.substitute(s,"//VTK::Light::Impl",g,!1).result;break;default:Ht("bad light complexity")}n.Fragment=s},t.replaceShaderNormal=(n,a,i)=>{if(e.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let o=n.Vertex,c=n.Geometry,u=n.Fragment;e.lastBoundBO.getCABO().getNormalOffset()?(o=V.substitute(o,"//VTK::Normal::Dec",["attribute vec3 normalMC;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,o=V.substitute(o,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * normalMC;"]).result,c=V.substitute(c,"//VTK::Normal::Dec",["in vec3 normalVCVSOutput[];","out vec3 normalVCGSOutput;"]).result,c=V.substitute(c,"//VTK::Normal::Impl",["normalVCGSOutput = normalVCVSOutput[i];"]).result,u=V.substitute(u,"//VTK::Normal::Dec",["varying vec3 normalVCVSOutput;"]).result,u=V.substitute(u,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalVCVSOutput);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):e.haveCellNormals?(u=V.substitute(u,"//VTK::Normal::Dec",["uniform mat3 normalMatrix;","uniform samplerBuffer textureN;"]).result,u=V.substitute(u,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalMatrix *","    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):e.lastBoundBO.getOpenGLMode(i.getProperty().getRepresentation())===e.context.LINES?(u=V.substitute(u,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,u=V.substitute(u,"//VTK::Normal::Impl",["vec3 normalVCVSOutput;","  if (abs(fdx.x) > 0.0)","    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }","  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"]).result):(u=V.substitute(u,"//VTK::Normal::Dec",["uniform int cameraParallel;"]).result,u=V.substitute(u,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,u=V.substitute(u,"//VTK::Normal::Impl",["  fdx = normalize(fdx);","  fdy = normalize(fdy);","  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));","  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }","  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"]).result),n.Vertex=o,n.Geometry=c,n.Fragment=u}},t.replaceShaderPositionVC=(n,a,i)=>{e.lastBoundBO.replaceShaderPositionVC(n,a,i);let s=n.Vertex,o=n.Geometry,c=n.Fragment;e.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(s=V.substitute(s,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,s=V.substitute(s,"//VTK::PositionVC::Impl",["vertexVCVSOutput = MCVCMatrix * vertexMC;","  gl_Position = MCPCMatrix * vertexMC;"]).result,s=V.substitute(s,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result,o=V.substitute(o,"//VTK::PositionVC::Dec",["in vec4 vertexVCVSOutput[];","out vec4 vertexVCGSOutput;"]).result,o=V.substitute(o,"//VTK::PositionVC::Impl",["vertexVCGSOutput = vertexVCVSOutput[i];"]).result,c=V.substitute(c,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,c=V.substitute(c,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;"]).result):(s=V.substitute(s,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,s=V.substitute(s,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result),n.Vertex=s,n.Geometry=o,n.Fragment=c},t.replaceShaderTCoord=(n,a,i)=>{if(e.lastBoundBO.getCABO().getTCoordOffset()){let s=n.Vertex,o=n.Geometry,c=n.Fragment;if(e.drawingEdges)return;s=V.substitute(s,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result;const u=e.openGLActor.getActiveTextures();let g=2,f=2;if(u&&u.length>0&&(g=u[0].getComponents(),u[0].getTarget()===e.context.TEXTURE_CUBE_MAP&&(f=3)),e.renderable.getColorTextureMap()&&(g=e.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),f=2),f===2){if(s=V.substitute(s,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result,o=V.substitute(o,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];","out vec2 tcoordVCGSOutput;"]).result,o=V.substitute(o,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,c=V.substitute(c,"//VTK::TCoord::Dec",["varying vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,u&&u.length>=1)switch(g){case 1:c=V.substitute(c,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:c=V.substitute(c,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:c=V.substitute(c,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}}else switch(s=V.substitute(s,"//VTK::TCoord::Dec","attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result,o=V.substitute(o,"//VTK::TCoord::Dec",["in vec3 tcoordVCVSOutput[];","out vec3 tcoordVCGSOutput;"]).result,o=V.substitute(o,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,c=V.substitute(c,"//VTK::TCoord::Dec",["varying vec3 tcoordVCVSOutput;","uniform samplerCube texture1;"]).result,g){case 1:c=V.substitute(c,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:c=V.substitute(c,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:c=V.substitute(c,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}n.Vertex=s,n.Geometry=o,n.Fragment=c}},t.replaceShaderClip=(n,a,i)=>{let s=n.Vertex,o=n.Fragment;if(e.renderable.getNumberOfClippingPlanes()){const c=e.renderable.getNumberOfClippingPlanes();s=V.substitute(s,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`uniform vec4 clipPlanes[${c}];`,`varying float clipDistancesVSOutput[${c}];`]).result,s=V.substitute(s,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${c}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,o=V.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`varying float clipDistancesVSOutput[${c}];`]).result,o=V.substitute(o,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${c}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}n.Vertex=s,n.Fragment=o},t.getCoincidentParameters=(n,a)=>{let i={factor:0,offset:0};const s=a.getProperty();if(e.renderable.getResolveCoincidentTopology()==Ie.PolygonOffset||s.getEdgeVisibility()&&s.getRepresentation()===sn.SURFACE){const c=e.lastBoundBO.getPrimitiveType();c===Se.Points||s.getRepresentation()===sn.POINTS?i=e.renderable.getCoincidentTopologyPointOffsetParameter():c===Se.Lines||s.getRepresentation()===sn.WIREFRAME?i=e.renderable.getCoincidentTopologyLineOffsetParameters():(c===Se.Tris||c===Se.TriStrips)&&(i=e.renderable.getCoincidentTopologyPolygonOffsetParameters()),(c===Se.TrisEdges||c===Se.TriStripsEdges)&&(i=e.renderable.getCoincidentTopologyPolygonOffsetParameters(),i.factor/=2,i.offset/=2)}const o=e._openGLRenderer.getSelector();return o&&o.getFieldAssociation()===Ga.FIELD_ASSOCIATION_POINTS&&(i.offset-=2),i},t.replaceShaderPicking=(n,a,i)=>{let s=n.Fragment,o=n.Vertex;if(s=V.substitute(s,"//VTK::Picking::Dec",["uniform int picking;","//VTK::Picking::Dec"]).result,!!e._openGLRenderer.getSelector()){switch((e.lastSelectionState===ke.ID_LOW24||e.lastSelectionState===ke.ID_HIGH24)&&(o=V.substitute(o,"//VTK::Picking::Dec",[`flat out int vertexIDVSOutput;
`,`uniform int VertexIDOffset;
`]).result,o=V.substitute(o,"//VTK::Picking::Impl",`  vertexIDVSOutput = gl_VertexID + VertexIDOffset;
`).result,s=V.substitute(s,"//VTK::Picking::Dec",`flat in int vertexIDVSOutput;
`).result,s=V.substitute(s,"//VTK::Picking::Impl",["  int idx = vertexIDVSOutput;","//VTK::Picking::Impl"]).result),e.lastSelectionState){case ke.ID_LOW24:s=V.substitute(s,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);").result;break;case ke.ID_HIGH24:s=V.substitute(s,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);").result;break;default:s=V.substitute(s,"//VTK::Picking::Dec","uniform vec3 mapperIndex;").result,s=V.substitute(s,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result}n.Fragment=s,n.Vertex=o}},t.replaceShaderValues=(n,a,i)=>{if(t.replaceShaderColor(n,a,i),t.replaceShaderNormal(n,a,i),t.replaceShaderLight(n,a,i),t.replaceShaderTCoord(n,a,i),t.replaceShaderPicking(n,a,i),t.replaceShaderClip(n,a,i),t.replaceShaderCoincidentOffset(n,a,i),t.replaceShaderPositionVC(n,a,i),e.haveSeenDepthRequest){let s=n.Fragment;s=V.substitute(s,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,s=V.substitute(s,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=s}},t.getNeedToRebuildShaders=(n,a,i)=>{let s=0,o=0;const c=n.getPrimitiveType(),u=e.currentInput;let g=!1;const f=u.getPointData().getNormals(),l=u.getCellData().getNormals(),p=i.getProperty().getInterpolation()===Zs.FLAT,d=i.getProperty().getRepresentation(),h=n.getOpenGLMode(d,c);if((h===e.context.TRIANGLES||l&&!f||!p&&f||!p&&h===e.context.LINES)&&(g=!0),i.getProperty().getLighting()&&g){s=0;const S=a.getLightsByReference();for(let x=0;x<S.length;++x){const R=S[x];R.getSwitch()>0&&(o++,s===0&&(s=1)),s===1&&(o>1||R.getIntensity()!==1||!R.lightTypeIsHeadLight())&&(s=2),s<3&&R.getPositional()&&(s=3)}}let T=!1;const v=e.lastBoundBO.getReferenceByName("lastLightComplexity"),C=e.lastBoundBO.getReferenceByName("lastLightCount");return(v!==s||C!==o)&&(e.lastBoundBO.set({lastLightComplexity:s},!0),e.lastBoundBO.set({lastLightCount:o},!0),T=!0),(!e.currentRenderPass&&e.lastRenderPassShaderReplacement||e.currentRenderPass&&e.currentRenderPass.getShaderReplacement()!==e.lastRenderPassShaderReplacement)&&(T=!0),e.lastHaveSeenDepthRequest!==e.haveSeenDepthRequest||n.getShaderSourceTime().getMTime()<e.renderable.getMTime()||n.getShaderSourceTime().getMTime()<e.currentInput.getMTime()||n.getShaderSourceTime().getMTime()<e.selectionStateChanged.getMTime()||T?(e.lastHaveSeenDepthRequest=e.haveSeenDepthRequest,!0):!1},t.invokeShaderCallbacks=(n,a,i)=>{const s=e.renderable.getViewSpecificProperties().ShadersCallbacks;s&&s.forEach(o=>{o.callback(o.userData,n,a,i)})},t.setMapperShaderParameters=(n,a,i)=>{if(n.getProgram().isUniformUsed("PrimitiveIDOffset")&&n.getProgram().setUniformi("PrimitiveIDOffset",e.primitiveIDOffset),n.getProgram().isUniformUsed("VertexIDOffset")&&n.getProgram().setUniformi("VertexIDOffset",e.vertexIDOffset),n.getCABO().getElementCount()&&(e.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const c=e.lastBoundBO.getReferenceByName("lastLightComplexity");n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),e.context.FLOAT,3,!1)||Ht("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("normalMC")&&n.getCABO().getNormalOffset()&&c>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"normalMC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),e.context.FLOAT,3,!1)||Ht("Error setting normalMC in shader VAO."):n.getVAO().removeAttributeArray("normalMC"),e.renderable.getCustomShaderAttributes().forEach((u,g)=>{n.getProgram().isAttributeUsed(`${u}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${u}MC`,n.getCABO().getCustomData()[g].offset,n.getCABO().getStride(),e.context.FLOAT,n.getCABO().getCustomData()[g].components,!1)||Ht(`Error setting ${u}MC in shader VAO.`))}),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),e.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||Ht("Error setting tcoordMC in shader VAO."):n.getVAO().removeAttributeArray("tcoordMC"),n.getProgram().isAttributeUsed("scalarColor")&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),"scalarColor",n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),e.context.UNSIGNED_BYTE,4,!0)||Ht("Error setting scalarColor in shader VAO."):n.getVAO().removeAttributeArray("scalarColor"),n.getAttributeUpdateTime().modified()}if(e.renderable.getNumberOfClippingPlanes()){const c=e.renderable.getNumberOfClippingPlanes(),u=[],f=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,l=f?Re(e.tmpMat4,i.getMatrix()):i.getMatrix();f&&(se(l,l),ae(l,l,f),se(l,l));for(let p=0;p<c;p++){const d=[];e.renderable.getClippingPlaneInDataCoords(l,p,d);for(let h=0;h<4;h++)u.push(d[h])}n.getProgram().setUniformi("numClipPlanes",c),n.getProgram().setUniform4fv("clipPlanes",u)}e.internalColorTexture&&n.getProgram().isUniformUsed("texture1")&&n.getProgram().setUniformi("texture1",e.internalColorTexture.getTextureUnit());const s=e.openGLActor.getActiveTextures();if(s)for(let c=0;c<s.length;++c){const g=s[c].getTextureUnit(),f=`texture${g+1}`;n.getProgram().isUniformUsed(f)&&n.getProgram().setUniformi(f,g)}if(e.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",e.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const c=t.getCoincidentParameters(a,i);n.getProgram().setUniformf("coffset",c.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",c.factor)}n.setMapperShaderParameters(a,i,e._openGLRenderer.getTiledSizeAndOrigin());const o=e._openGLRenderer.getSelector();n.getProgram().setUniform3fArray("mapperIndex",o?o.getPropColorValue():[0,0,0]),n.getProgram().setUniformi("picking",o?o.getCurrentPass()+1:0)},t.setLightingShaderParameters=(n,a,i)=>{const s=e.lastBoundBO.getReferenceByName("lastLightComplexity");if(s<2)return;const o=n.getProgram();let c=0;const u=a.getLightsByReference();for(let l=0;l<u.length;++l){const p=u[l];if(p.getSwitch()>0){const h=p.getColorByReference(),T=p.getIntensity();e.lightColor[0]=h[0]*T,e.lightColor[1]=h[1]*T,e.lightColor[2]=h[2]*T;const v=p.getDirection(),C=a.getActiveCamera().getViewMatrix(),S=[...v];p.lightTypeIsSceneLight()&&(S[0]=C[0]*v[0]+C[1]*v[1]+C[2]*v[2],S[1]=C[4]*v[0]+C[5]*v[1]+C[6]*v[2],S[2]=C[8]*v[0]+C[9]*v[1]+C[10]*v[2],pe(S)),e.lightDirection[0]=S[0],e.lightDirection[1]=S[1],e.lightDirection[2]=S[2],pe(e.lightDirection),o.setUniform3fArray(`lightColor${c}`,e.lightColor),o.setUniform3fArray(`lightDirectionVC${c}`,e.lightDirection),c++}}if(s<3)return;const f=a.getActiveCamera().getViewMatrix();se(f,f),c=0;for(let l=0;l<u.length;++l){const p=u[l];if(p.getSwitch()>0){const h=p.getTransformedPosition(),T=new Float64Array(3);q(T,h,f),o.setUniform3fArray(`lightAttenuation${c}`,p.getAttenuationValuesByReference()),o.setUniformi(`lightPositional${c}`,p.getPositional()),o.setUniformf(`lightExponent${c}`,p.getExponent()),o.setUniformf(`lightConeAngle${c}`,p.getConeAngle()),o.setUniform3fArray(`lightPositionVC${c}`,[T[0],T[1],T[2]]),c++}}};function r(n,a,i){return a.identity(i),n.reduce((s,o,c)=>c===0?o?a.copy(s,o):a.identity(s):o?a.multiply(s,s,o):s,i)}t.setCameraShaderParameters=(n,a,i)=>{const s=n.getProgram(),o=e.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=e.openGLCamera.getKeyMatrixTime().getMTime(),g=s.getLastCameraMTime(),l=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,p=i.getIsIdentity(),d=p?{mcwc:null,normalMatrix:null}:e.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===Ad.DISPLAY){const h=e._openGLRenderer.getTiledSizeAndOrigin();X(e.tmpMat4),e.tmpMat4[0]=2/h.usize,e.tmpMat4[12]=-1,e.tmpMat4[5]=2/h.vsize,e.tmpMat4[13]=-1,ae(e.tmpMat4,e.tmpMat4,l),s.setUniformMatrix("MCPCMatrix",e.tmpMat4)}else s.setUniformMatrix("MCPCMatrix",r([o.wcpc,d.mcwc,l],Jn,e.tmpMat4));s.isUniformUsed("MCVCMatrix")&&s.setUniformMatrix("MCVCMatrix",r([o.wcvc,d.mcwc,l],Jn,e.tmpMat4)),s.isUniformUsed("normalMatrix")&&s.setUniformMatrix3x3("normalMatrix",r([o.normalMatrix,d.normalMatrix],xl,e.tmpMat3)),g!==u&&(s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",c.getParallelProjection()),s.setLastCameraMTime(u)),p||s.setLastCameraMTime(0)},t.setPropertyShaderParameters=(n,a,i)=>{const s=n.getProgram();let o=i.getProperty(),c=o.getOpacity(),u=e.drawingEdges?o.getEdgeColorByReference():o.getAmbientColorByReference(),g=e.drawingEdges?o.getEdgeColorByReference():o.getDiffuseColorByReference(),f=e.drawingEdges?1:o.getAmbient(),l=e.drawingEdges?0:o.getDiffuse(),p=e.drawingEdges?0:o.getSpecular();const d=o.getSpecularPower();s.setUniformf("opacityUniform",c),s.setUniform3fArray("ambientColorUniform",u),s.setUniform3fArray("diffuseColorUniform",g),s.setUniformf("ambient",f),s.setUniformf("diffuse",l);const h=e.lastBoundBO.getReferenceByName("lastLightComplexity");if(h<1)return;let T=o.getSpecularColorByReference();if(s.setUniform3fArray("specularColorUniform",T),s.setUniformf("specularPowerUniform",d),s.setUniformf("specular",p),s.isUniformUsed("ambientIntensityBF")){if(o=i.getBackfaceProperty(),c=o.getOpacity(),u=o.getAmbientColor(),f=o.getAmbient(),g=o.getDiffuseColor(),l=o.getDiffuse(),T=o.getSpecularColor(),p=o.getSpecular(),s.setUniformf("ambientIntensityBF",f),s.setUniformf("diffuseIntensityBF",l),s.setUniformf("opacityUniformBF",c),s.setUniform3fArray("ambientColorUniformBF",u),s.setUniform3fArray("diffuseColorUniformBF",g),h<1)return;s.setUniformf("specularIntensityBF",p),s.setUniform3fArray("specularColorUniformBF",T),s.setUniformf("specularPowerUniformBF",d)}},t.updateMaximumPointCellIds=(n,a)=>{var o,c,u,g;const i=e._openGLRenderer.getSelector();if(!i)return;if((c=(o=e.selectionWebGLIdsToVTKIds)==null?void 0:o.points)!=null&&c.length){const f=e.selectionWebGLIdsToVTKIds.points.length;i.setMaximumPointId(f-1)}if((g=(u=e.selectionWebGLIdsToVTKIds)==null?void 0:u.cells)!=null&&g.length){const f=e.selectionWebGLIdsToVTKIds.cells.length;i.setMaximumCellId(f-1)}i.getFieldAssociation()===Ga.FIELD_ASSOCIATION_POINTS&&(e.pointPicking=!0)},t.renderPieceStart=(n,a)=>{e.primitiveIDOffset=0,e.vertexIDOffset=0;const i=Yd(e._openGLRenderer);if(e.lastSelectionState!==i&&(e.selectionStateChanged.modified(),e.lastSelectionState=i),e._openGLRenderer.getSelector())switch(i){default:e._openGLRenderer.getSelector().renderProp(a)}t.updateBufferObjects(n,a),e.renderable.getColorTextureMap()&&e.internalColorTexture.activate(),e.lastBoundBO=null},t.renderPieceDraw=(n,a)=>{const i=a.getProperty().getRepresentation(),s=a.getProperty().getEdgeVisibility()&&i===sn.SURFACE,o=e._openGLRenderer.getSelector(),c=o&&o.getFieldAssociation()===Ga.FIELD_ASSOCIATION_POINTS&&(e.lastSelectionState===ke.ID_LOW24||e.lastSelectionState===ke.ID_HIGH24);for(let u=Se.Start;u<Se.End;u++)e.primitives[u].setPointPicking(c),e.primitives[u].getCABO().getElementCount()&&(e.drawingEdges=s&&(u===Se.TrisEdges||u===Se.TriStripsEdges),(!e.drawingEdges||!(e.renderDepth||e.lastSelectionState>=0))&&(e.lastBoundBO=e.primitives[u],e.primitiveIDOffset+=e.primitives[u].drawArrays(n,a,i,t),e.vertexIDOffset+=e.primitives[u].getCABO().getElementCount()))},t.renderPieceFinish=(n,a)=>{e.LastBoundBO&&e.LastBoundBO.getVAO().release(),e.renderable.getColorTextureMap()&&e.internalColorTexture.deactivate()},t.renderPiece=(n,a)=>{if(t.invokeEvent(Kd),e.renderable.getStatic()||e.renderable.update(),e.currentInput=e.renderable.getInputData(),t.invokeEvent(Xd),!e.currentInput){Ht("No input!");return}if(!e.currentInput.getPoints||!e.currentInput.getPoints().getNumberOfValues())return;const i=e.context,s=a.getProperty().getBackfaceCulling(),o=a.getProperty().getFrontfaceCulling();!s&&!o?e._openGLRenderWindow.disableCullFace():o?(e._openGLRenderWindow.enableCullFace(),i.cullFace(i.FRONT)):(e._openGLRenderWindow.enableCullFace(),i.cullFace(i.BACK)),t.renderPieceStart(n,a),t.renderPieceDraw(n,a),t.renderPieceFinish(n,a)},t.computeBounds=(n,a)=>{if(!t.getInput()){xn(e.bounds);return}e.bounds=t.getInput().getBounds()},t.updateBufferObjects=(n,a)=>{t.getNeedToRebuildBufferObjects(n,a)&&t.buildBufferObjects(n,a),t.updateMaximumPointCellIds()},t.getNeedToRebuildBufferObjects=(n,a)=>{const i=e.VBOBuildTime.getMTime();return i<t.getMTime()||i<e.renderable.getMTime()||i<a.getMTime()||i<e.currentInput.getMTime()},t.buildBufferObjects=(n,a)=>{const i=e.currentInput;if(i===null)return;e.renderable.mapScalars(i,1);const s=e.renderable.getColorMapColors();e.haveCellScalars=!1;const o=e.renderable.getScalarMode();e.renderable.getScalarVisibility()&&(o===Rr.USE_CELL_DATA||o===Rr.USE_CELL_FIELD_DATA||o===Rr.USE_FIELD_DATA||!i.getPointData().getScalars())&&o!==Rr.USE_POINT_FIELD_DATA&&s&&(e.haveCellScalars=!0);let c=a.getProperty().getInterpolation()!==Zs.FLAT?i.getPointData().getNormals():null;c===null&&i.getCellData().getNormals()&&(e.haveCellNormals=!0,c=i.getCellData().getNormals());const u=a.getProperty().getRepresentation();let g=i.getPointData().getTCoords();e.openGLActor.getActiveTextures()||(g=null);let f=!1;if(e.renderable.getColorCoordinates()){g=e.renderable.getColorCoordinates(),f=e.renderable.getAreScalarsMappedFromCells(),e.internalColorTexture||(e.internalColorTexture=he.newInstance({resizable:!0}));const p=e.internalColorTexture;p.setMinificationFilter(Ps.NEAREST),p.setMagnificationFilter(Ps.NEAREST),p.setWrapS(Js.CLAMP_TO_EDGE),p.setWrapT(Js.CLAMP_TO_EDGE),p.setOpenGLRenderWindow(e._openGLRenderWindow);const d=e.renderable.getColorTextureMap(),h=d.getExtent(),T=d.getPointData().getScalars();p.create2DFromRaw(h[1]-h[0]+1,h[3]-h[2]+1,T.getNumberOfComponents(),T.getDataType(),T.getData()),p.activate(),p.sendParameters(),p.deactivate()}const l=`${i.getMTime()}A${u}B${i.getMTime()}C${c?c.getMTime():1}D${s?s.getMTime():1}E${a.getProperty().getEdgeVisibility()}F${g?g.getMTime():1}`;if(e.VBOBuildString!==l){const d={points:i.getPoints(),normals:c,tcoords:g,colors:s,cellOffset:0,vertexOffset:0,useTCoordsPerCell:f,haveCellScalars:e.haveCellScalars,haveCellNormals:e.haveCellNormals,customAttributes:e.renderable.getCustomShaderAttributes().map(v=>i.getPointData().getArrayByName(v))};e.renderable.getPopulateSelectionSettings()&&(e.selectionWebGLIdsToVTKIds={points:null,cells:null});const h=[{inRep:"verts",cells:i.getVerts()},{inRep:"lines",cells:i.getLines()},{inRep:"polys",cells:i.getPolys()},{inRep:"strips",cells:i.getStrips()},{inRep:"polys",cells:i.getPolys()},{inRep:"strips",cells:i.getStrips()}],T=a.getProperty().getEdgeVisibility()&&u===sn.SURFACE;for(let v=Se.Start;v<Se.End;v++)v!==Se.TrisEdges&&v!==Se.TriStripsEdges?(d.cellOffset+=e.primitives[v].getCABO().createVBO(h[v].cells,h[v].inRep,u,d,e.selectionWebGLIdsToVTKIds),d.vertexOffset+=e.primitives[v].getCABO().getElementCount()):T?e.primitives[v].getCABO().createVBO(h[v].cells,h[v].inRep,sn.WIREFRAME,{...d,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):e.primitives[v].releaseGraphicsResources();e.renderable.getPopulateSelectionSettings()&&e.renderable.setSelectionWebGLIdsToVTKIds(e.selectionWebGLIdsToVTKIds),e.VBOBuildString=l}e.VBOBuildTime.modified()},t.getAllocatedGPUMemoryInBytes=()=>{let n=0;return e.primitives.forEach(a=>{n+=a.getAllocatedGPUMemoryInBytes()}),n}}const Zd={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:ke.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function Hu(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Zd,r),De.extend(t,e,r),ut.implementReplaceShaderCoincidentOffset(t,e,r),ut.implementBuildShadersWithReplacements(t,e,r),e.primitives=[],e.primTypes=Se,e.tmpMat3=ct(new Float64Array(9)),e.tmpMat4=X(new Float64Array(16));for(let n=Se.Start;n<Se.End;n++)e.primitives[n]=ft.newInstance(),e.primitives[n].setPrimitiveType(n),e.primitives[n].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);Me(t,e,["context"]),e.VBOBuildTime={},xe(e.VBOBuildTime,{mtime:0}),e.selectionStateChanged={},xe(e.selectionStateChanged,{mtime:0}),qd(t,e)}const ju=ye(Hu,"vtkOpenGLPolyDataMapper");var Pd={newInstance:ju,extend:Hu};Oe("vtkMapper",ju);const{ColorMode:Jd,ScalarMode:jt,GetArray:Ua}=Sa;function Qd(t,e){e.classHierarchy.push("vtkMapper2D"),t.createDefaultLookupTable=()=>{e.lookupTable=ra.newInstance()},t.getColorModeAsString=()=>y.enumToString(Jd,e.colorMode),t.setColorModeToDefault=()=>t.setColorMode(0),t.setColorModeToMapScalars=()=>t.setColorMode(1),t.setColorModeToDirectScalars=()=>t.setColorMode(2),t.getScalarModeAsString=()=>y.enumToString(jt,e.scalarMode),t.setScalarModeToDefault=()=>t.setScalarMode(0),t.setScalarModeToUsePointData=()=>t.setScalarMode(1),t.setScalarModeToUseCellData=()=>t.setScalarMode(2),t.setScalarModeToUsePointFieldData=()=>t.setScalarMode(3),t.setScalarModeToUseCellFieldData=()=>t.setScalarMode(4),t.setScalarModeToUseFieldData=()=>t.setScalarMode(5),t.getAbstractScalars=(r,n,a,i,s)=>{if(!r||!e.scalarVisibility)return{scalars:null,cellFLag:!1};let o=null,c=!1;if(n===jt.DEFAULT)o=r.getPointData().getScalars(),o||(o=r.getCellData().getScalars(),c=!0);else if(n===jt.USE_POINT_DATA)o=r.getPointData().getScalars();else if(n===jt.USE_CELL_DATA)o=r.getCellData().getScalars(),c=!0;else if(n===jt.USE_POINT_FIELD_DATA){const u=r.getPointData();a===Ua.BY_ID?o=u.getArrayByIndex(i):o=u.getArrayByName(s)}else if(n===jt.USE_CELL_FIELD_DATA){const u=r.getCellData();c=!0,a===Ua.BY_ID?o=u.getArrayByIndex(i):o=u.getArrayByName(s)}else if(n===jt.USE_FIELD_DATA){const u=r.getFieldData();a===Ua.BY_ID?o=u.getArrayByIndex(i):o=u.getArrayByName(s)}return{scalars:o,cellFlag:c}},t.getLookupTable=()=>(e.lookupTable||t.createDefaultLookupTable(),e.lookupTable),t.getMTime=()=>{let r=e.mtime;if(e.lookupTable!==null){const n=e.lookupTable.getMTime();r=n>r?n:r}return r},t.mapScalars=(r,n)=>{const a=t.getAbstractScalars(r,e.scalarMode,e.arrayAccessMode,e.arrayId,e.colorByArrayName).scalars;if(!a){e.colorMapColors=null;return}const i=`${t.getMTime()}${a.getMTime()}${n}`;if(e.colorBuildString===i)return;e.useLookupTableScalarRange||t.getLookupTable().setRange(e.scalarRange[0],e.scalarRange[1]);const s=t.getLookupTable();s&&(s.build(),e.colorMapColors=s.mapScalars(a,e.colorMode,e.fieldDataTupleId)),e.colorBuildString=`${t.getMTime()}${a.getMTime()}${n}`},t.getPrimitiveCount=()=>{const r=t.getInputData();return{points:r.getPoints().getNumberOfValues()/3,verts:r.getVerts().getNumberOfValues()-r.getVerts().getNumberOfCells(),lines:r.getLines().getNumberOfValues()-2*r.getLines().getNumberOfCells(),triangles:r.getPolys().getNumberOfValues()-3*r.getPolys().getNumberOfCells()}}}const Id={static:!1,lookupTable:null,scalarVisibility:!1,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,transformCoordinate:null,viewSpecificProperties:null,customShaderAttributes:[]};function bu(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Id,r),yc.extend(t,e,r),y.get(t,e,["colorMapColors"]),y.setGet(t,e,["arrayAccessMode","colorByArrayName","colorMode","lookupTable","renderTime","scalarMode","scalarVisibility","static","transformCoordinate","useLookupTableScalarRange","viewSpecificProperties","customShaderAttributes"]),y.setGetArray(t,e,["scalarRange"],2),e.viewSpecificProperties||(e.viewSpecificProperties={}),Qd(t,e)}const eT=y.newInstance(bu,"vtkMapper2D");var tT={newInstance:eT,extend:bu};const{vtkErrorMacro:nT}=y,rT=[1,-1,1,-1,1,-1];function aT(t,e){e.classHierarchy.push("vtkPoints"),t.getNumberOfPoints=t.getNumberOfTuples,t.setNumberOfPoints=function(r){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:3;t.getNumberOfPoints()!==r&&(e.size=r*n,e.values=y.newTypedArray(e.dataType,e.size),t.setNumberOfComponents(n),t.modified())},t.setPoint=function(r){for(var n=arguments.length,a=new Array(n>1?n-1:0),i=1;i<n;i++)a[i-1]=arguments[i];t.setTuple(r,a)},t.getPoint=t.getTuple,t.findPoint=t.findTuple,t.insertNextPoint=(r,n,a)=>t.insertNextTuple([r,n,a]),t.getBounds=()=>{if(t.getNumberOfComponents()===3){const a=t.getRange(0);e.bounds[0]=a[0],e.bounds[1]=a[1];const i=t.getRange(1);e.bounds[2]=i[0],e.bounds[3]=i[1];const s=t.getRange(2);return e.bounds[4]=s[0],e.bounds[5]=s[1],e.bounds}if(t.getNumberOfComponents()!==2)return nT(`getBounds called on an array with components of
        ${t.getNumberOfComponents()}`),rT;const r=t.getRange(0);e.bounds[0]=r[0],e.bounds[1]=r[1];const n=t.getRange(1);return e.bounds[2]=n[0],e.bounds[3]=n[1],e.bounds[4]=0,e.bounds[5]=0,e.bounds},t.computeBounds=t.getBounds,t.setNumberOfComponents(e.numberOfComponents<2?3:e.numberOfComponents)}const iT={empty:!0,numberOfComponents:3,dataType:J.FLOAT,bounds:[1,-1,1,-1,1,-1]};function Ku(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,iT,r),A.extend(t,e,r),aT(t,e)}const sT=y.newInstance(Ku,"vtkPoints");var er={newInstance:sT,extend:Ku},oT=`//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkPolyData2DFS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

uniform int PrimitiveIDOffset;

// Texture coordinates
//VTK::TCoord::Dec

// Scalar coloring
//VTK::Color::Dec

// Depth Peeling
//VTK::DepthPeeling::Dec

// picking support
//VTK::Picking::Dec

// the output of this shader
//VTK::Output::Dec

// Apple Bug
//VTK::PrimID::Dec

void main()
{
  // Apple Bug
  //VTK::PrimID::Impl

  //VTK::Color::Impl
  //VTK::TCoord::Impl

  //VTK::DepthPeeling::Impl
  //VTK::Picking::Impl

  if (gl_FragData[0].a <= 0.0)
    {
    discard;
    }
}
`,cT=`//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkPolyData2DVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

// all variables that represent positions or directions have a suffix
// indicating the coordinate system they are in. The possible values are
// MC - Model Coordinates
// WC - WC world coordinates
// VC - View Coordinates
// DC - Display Coordinates

in vec4 vertexWC;

// frag position in VC
//VTK::PositionVC::Dec

// material property values
//VTK::Color::Dec

// Texture coordinates
//VTK::TCoord::Dec

// Apple Bug
//VTK::PrimID::Dec

uniform mat4 WCVCMatrix;  // World to view matrix

void main()
{
  // Apple Bug
  //VTK::PrimID::Impl

  gl_Position = WCVCMatrix*vertexWC;

  //VTK::TCoord::Impl

  //VTK::Color::Impl

  //VTK::PositionVC::Impl
}
`;const Xu={BACKGROUND:0,FOREGROUND:1};var Au={DisplayLocation:Xu};const{primTypes:Ae}=ft,{ScalarMode:Mr}=tT,{vtkErrorMacro:Or}=We,uT={type:"StartEvent"},fT={type:"EndEvent"};function gT(t,e){e.classHierarchy.push("vtkOpenGLPolyDataMapper2D"),t.buildPass=n=>{n&&(e.openGLActor2D=t.getFirstAncestorOfType("vtkOpenGLActor2D"),e._openGLRenderer=e.openGLActor2D.getFirstAncestorOfType("vtkOpenGLRenderer"),e._openGLRenderWindow=e._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),e.openGLCamera=e._openGLRenderer.getViewNodeFor(e._openGLRenderer.getRenderable().getActiveCamera()))},t.overlayPass=n=>{n&&t.render()},t.getShaderTemplate=(n,a,i)=>{n.Vertex=cT,n.Fragment=oT,n.Geometry=""},t.render=()=>{const n=e._openGLRenderWindow.getContext();if(e.context!==n){e.context=n;for(let s=Ae.Start;s<Ae.End;s++)e.primitives[s].setOpenGLRenderWindow(e._openGLRenderWindow)}const a=e.openGLActor2D.getRenderable(),i=e._openGLRenderer.getRenderable();t.renderPiece(i,a)},t.renderPiece=(n,a)=>{if(t.invokeEvent(uT),e.renderable.getStatic()||e.renderable.update(),e.currentInput=e.renderable.getInputData(),t.invokeEvent(fT),!e.currentInput){Or("No input!");return}!e.currentInput.getPoints||!e.currentInput.getPoints().getNumberOfValues()||(t.renderPieceStart(n,a),t.renderPieceDraw(n,a),t.renderPieceFinish(n,a))},t.renderPieceStart=(n,a)=>{if(e.primitiveIDOffset=0,e._openGLRenderer.getSelector())switch(e._openGLRenderer.getSelector().getCurrentPass()){default:e._openGLRenderer.getSelector().renderProp(a)}t.updateBufferObjects(n,a),e.lastBoundBO=null},t.getNeedToRebuildShaders=(n,a,i)=>n.getShaderSourceTime().getMTime()<e.renderable.getMTime()||n.getShaderSourceTime().getMTime()<e.currentInput.getMTime(),t.updateBufferObjects=(n,a)=>{t.getNeedToRebuildBufferObjects(n,a)&&t.buildBufferObjects(n,a)},t.getNeedToRebuildBufferObjects=(n,a)=>{const i=e.VBOBuildTime.getMTime();return!!(i<t.getMTime()||i<e._openGLRenderWindow.getMTime()||i<e.renderable.getMTime()||i<a.getMTime()||i<e.currentInput.getMTime()||e.renderable.getTransformCoordinate()&&i<n.getMTime())},t.buildBufferObjects=(n,a)=>{const i=e.currentInput;if(i===null)return;e.renderable.mapScalars(i,a.getProperty().getOpacity());const s=e.renderable.getColorMapColors();e.haveCellScalars=!1;const o=e.renderable.getScalarMode();e.renderable.getScalarVisibility()&&(o===Mr.USE_CELL_DATA||o===Mr.USE_CELL_FIELD_DATA||o===Mr.USE_FIELD_DATA||!i.getPointData().getScalars())&&o!==Mr.USE_POINT_FIELD_DATA&&s&&(e.haveCellScalars=!0);const c=a.getProperty().getRepresentation();let u=i.getPointData().getTCoords();e.openGLActor2D.getActiveTextures()||(u=null);const g=e.renderable.getTransformCoordinate(),l=n.getRenderWindow().getViews()[0].getViewportSize(n),p=`${i.getMTime()}A${c}B${i.getMTime()}C${s?s.getMTime():1}D${u?u.getMTime():1}E${g?n.getMTime():1}F${l}`;if(e.VBOBuildString!==p){let d=i.getPoints();if(g){const T=er.newInstance(),v=d.getNumberOfPoints();T.setNumberOfPoints(v);const C=[];for(let S=0;S<v;++S){d.getPoint(S,C),g.setValue(C);const x=g.getComputedDoubleViewportValue(n);T.setPoint(S,x[0],x[1],0)}d=T}const h={points:d,tcoords:u,colors:s,cellOffset:0,haveCellScalars:e.haveCellSCalars,customAttributes:e.renderable.getCustomShaderAttributes().map(T=>i.getPointData().getArrayByName(T))};h.cellOffset+=e.primitives[Ae.Points].getCABO().createVBO(i.getVerts(),"verts",c,h),h.cellOffset+=e.primitives[Ae.Lines].getCABO().createVBO(i.getLines(),"lines",c,h),h.cellOffset+=e.primitives[Ae.Tris].getCABO().createVBO(i.getPolys(),"polys",c,h),h.cellOffset+=e.primitives[Ae.TriStrips].getCABO().createVBO(i.getStrips(),"strips",c,h),e.VBOBuildTime.modified(),e.VBOBuildString=p}},t.renderPieceDraw=(n,a)=>{const i=a.getProperty().getRepresentation();e.context.depthMask(!0);for(let o=Ae.Start;o<Ae.End;o++)e.primitives[o].getCABO().getElementCount()&&(e.lastBoundBO=e.primitives[o],e.primitiveIDOffset+=e.primitives[o].drawArrays(n,a,i,t))},t.renderPieceFinish=(n,a)=>{e.lastBoundBO&&e.lastBoundBO.getVAO().release()},t.replaceShaderValues=(n,a,i)=>{t.replaceShaderColor(n,a,i),t.replaceShaderTCoord(n,a,i),t.replaceShaderPicking(n,a,i),t.replaceShaderPositionVC(n,a,i)},t.replaceShaderColor=(n,a,i)=>{let s=n.Vertex,o=n.Geometry,c=n.Fragment;e.haveCellScalars&&(c=V.substitute(c,"//VTK::Color::Dec",["uniform samplerBuffer texture1;"]).result,c=V.substitute(c,"//VTK::Color::Impl",["gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);"]).result),e.lastBoundBO.getCABO().getColorComponents()!==0?(s=V.substitute(s,"//VTK::Color::Dec",["in vec4 diffuseColor;","out vec4 fcolorVSOutput;"]).result,s=V.substitute(s,"//VTK::Color::Impl",["fcolorVSOutput = diffuseColor;"]).result,o=V.substitute(o,"//VTK::Color::Dec",[`in vec4 fcolorVSOutput[];
`,"out vec4 fcolorGSOutput;"]).result,o=V.substitute(o,"//VTK::Color::Impl",["fcolorGSOutput = fcolorVSOutput[i];"]).result,c=V.substitute(c,"//VTK::Color::Dec",["in vec4 fcolorVSOutput;"]).result,c=V.substitute(c,"//VTK::Color::Impl",["gl_FragData[0] = fcolorVSOutput;"]).result):(c=V.substitute(c,"//VTK::Color::Dec",["uniform vec4 diffuseColor;"]).result,c=V.substitute(c,"//VTK::Color::Impl",["gl_FragData[0] = diffuseColor;"]).result),n.Vertex=s,n.Geometry=o,n.Fragment=c},t.replaceShaderTCoord=(n,a,i)=>{if(e.lastBoundBO.getCABO().getTCoordOffset()){let s=n.Vertex,o=n.Geometry,c=n.Fragment;const u=e.lastBoundBO.getCABO().getTCoordComponents();u===1?(s=V.substitute(s,"//VTK::TCoord::Dec",["in float tcoordMC;","out float tcoordVCVSOutput;"]).result,s=V.substitute(s,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,o=V.substitute(o,"//VTK::TCoord::Dec",[`in float tcoordVCVSOutput[];
`,"out float tcoordVCGSOutput;"]).result,o=V.substitute(o,["//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,c=V.substitute(c,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,c=V.substitute(c,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));"]).result):u===2&&(s=V.substitute(s,"//VTK::TCoord::Dec",["in vec2 tcoordMC;","out vec2 tcoordVCVSOutput;"]).result,s=V.substitute(s,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,o=V.substitute(o,"//VTK::TCoord::Dec",[`in vec2 tcoordVCVSOutput[];
`,"out vec2 tcoordVCGSOutput;"]).result,o=V.substitute(o,"//VTK::TCoord::Impl",["tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,c=V.substitute(c,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,c=V.substitute(c,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);"]).result),e.haveCellScalars&&(o=V.substitute(o,"//VTK::PrimID::Impl",["gl_PrimitiveID = gl_PrimitiveIDIn;"]).result),n.Vertex=s,n.Geometry=o,n.Fragment=c}},t.replaceShaderPicking=(n,a,i)=>{let s=n.Fragment;s=V.substitute(s,"//VTK::Picking::Dec",["uniform vec3 mapperIndex;","uniform int picking;"]).result,s=V.substitute(s,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result,n.Fragment=s},t.replaceShaderPositionVC=(n,a,i)=>{e.lastBoundBO.replaceShaderPositionVC(n,a,i)},t.invokeShaderCallbacks=(n,a,i)=>{const s=e.renderable.getViewSpecificProperties().ShadersCallbacks;s&&s.forEach(o=>{o.callback(o.userData,n,a,i)})},t.setMapperShaderParameters=(n,a,i)=>{if(n.getProgram().isUniformUsed("PrimitiveIDOffset")&&n.getProgram().setUniformi("PrimitiveIDOffset",e.primitiveIDOffset),n.getProgram().isAttributeUsed("vertexWC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexWC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),e.context.FLOAT,3,!1)||Or("Error setting vertexWC in shader VAO.")),n.getCABO().getElementCount()&&(e.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){e.renderable.getCustomShaderAttributes().forEach((c,u)=>{n.getProgram().isAttributeUsed(`${c}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${c}MC`,n.getCABO().getCustomData()[u].offset,n.getCABO().getStride(),e.context.FLOAT,n.getCABO().getCustomData()[u].components,!1)||Or(`Error setting ${c}MC in shader VAO.`))}),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),e.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||Or("Error setting tcoordMC in shader VAO."):n.getVAO().removeAttributeArray("tcoordMC"),e.internalColorTexture&&n.getProgram().isUniformUsed("texture1")&&n.getProgram().setUniformi("texture1",e.internalColorTexture.getTextureUnit());const s=e.openGLActor2D.getActiveTextures();if(s)for(let c=0;c<s.length;++c){const g=s[c].getTextureUnit(),f=`texture${g+1}`;n.getProgram().isUniformUsed(f)&&n.getProgram().setUniformi(f,g)}n.setMapperShaderParameters(a,i,e._openGLRenderer.getTiledSizeAndOrigin());const o=e._openGLRenderer.getSelector();n.getProgram().setUniform3fArray("mapperIndex",o?o.getPropColorValue():[0,0,0]),n.getProgram().setUniformi("picking",o?o.getCurrentPass()+1:0)}},t.setPropertyShaderParameters=(n,a,i)=>{const s=e.renderable.getColorMapColors();if(!s||s.getNumberOfComponents()===0){const o=n.getProgram(),c=i.getProperty(),u=c.getOpacity(),g=c.getColor(),f=[g[0],g[1],g[2],u];o.setUniform4f("diffuseColor",f)}},t.setLightingShaderParameters=(n,a,i)=>{};function r(n,a,i){return a.identity(i),n.reduce((s,o,c)=>c===0?o?a.copy(s,o):a.identity(s):o?a.multiply(s,s,o):s,i)}t.setCameraShaderParameters=(n,a,i)=>{const s=n.getProgram(),c=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,g=a.getRenderWindow().getViews()[0].getViewportSize(a),f=a.getViewport(),l=i.getActualPositionCoordinate().getComputedDoubleViewportValue(a),p=[0,0,1,1],d=[0,0,1,1];if(d[0]=f[0]>=p[0]?f[0]:p[0],d[1]=f[1]>=p[1]?f[1]:p[1],d[2]=f[2]<=p[2]?f[2]:p[2],d[3]=f[3]<=p[3]?f[3]:p[3],d[0]>=d[2]||d[1]>=d[3])return;g[0]=yt(g[0]*(d[2]-d[0])/(f[2]-f[0])),g[1]=yt(g[1]*(d[3]-d[1])/(f[3]-f[1]));const h=e._openGLRenderer.getParent().getSize(),T=yt(l[0]-(d[0]-f[0])*h[0]),v=yt(l[1]-(d[1]-f[1])*h[1]),C=-T;let S=-T+g[0];const x=-v;let R=-v+g[1];C===S&&(S=C+1),x===R&&(R=x+1);const O=X(new Float64Array(16));O[0]=2/(S-C),O[1*4+1]=2/(R-x),O[0*4+3]=-1*(S+C)/(S-C),O[1*4+3]=-1*(R+x)/(R-x),O[2*4+2]=0,O[2*4+3]=i.getProperty().getDisplayLocation()===Xu.FOREGROUND?-1:1,O[3*4+3]=1,se(O,O),s.setUniformMatrix("WCVCMatrix",r([O,c],Jn,e.tmpMat4))},t.getAllocatedGPUMemoryInBytes=()=>{let n=0;return e.primitives.forEach(a=>{n+=a.getAllocatedGPUMemoryInBytes()}),n}}const lT={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};function pT(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,lT,r),De.extend(t,e,r),ut.implementReplaceShaderCoincidentOffset(t,e,r),ut.implementBuildShadersWithReplacements(t,e,r),e.primitives=[],e.primTypes=Ae,e.tmpMat4=X(new Float64Array(16));for(let n=Ae.Start;n<Ae.End;n++)e.primitives[n]=ft.newInstance(),e.primitives[n].setPrimitiveType(n),e.primitives[n].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);Me(t,e,["context"]),e.VBOBuildTime={},xe(e.VBOBuildTime,{mtime:0}),gT(t,e)}const hT=ye(pT,"vtkOpenGLPolyDataMapper2D");Oe("vtkMapper2D",hT);const{vtkErrorMacro:Qs}=We;function dT(t,e){e.classHierarchy.push("vtkOpenGLSkybox"),t.buildPass=r=>{if(r){e._openGLRenderer=t.getFirstAncestorOfType("vtkOpenGLRenderer"),e._openGLRenderWindow=e._openGLRenderer.getParent(),e.context=e._openGLRenderWindow.getContext(),e.tris.setOpenGLRenderWindow(e._openGLRenderWindow),e.openGLTexture.setOpenGLRenderWindow(e._openGLRenderWindow);const n=e._openGLRenderer.getRenderable();e.openGLCamera=e._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},t.queryPass=(r,n)=>{if(r){if(!e.renderable||!e.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},t.opaquePass=(r,n)=>{if(r&&!e._openGLRenderer.getSelector()){t.updateBufferObjects(),e.context.depthMask(!0),e._openGLRenderWindow.getShaderCache().readyShaderProgram(e.tris.getProgram()),e.openGLTexture.render(e._openGLRenderWindow);const a=e.openGLTexture.getTextureUnit();e.tris.getProgram().setUniformi("sbtexture",a);const i=e._openGLRenderer.getRenderable(),s=e.openGLCamera.getKeyMatrices(i),o=new Float64Array(16);if(je(o,s.wcpc),e.tris.getProgram().setUniformMatrix("IMCPCMatrix",o),e.lastFormat==="box"){const c=i.getActiveCamera().getPosition();e.tris.getProgram().setUniform3f("camPos",c[0],c[1],c[2])}e.tris.getVAO().bind(),e.context.drawArrays(e.context.TRIANGLES,0,e.tris.getCABO().getElementCount()),e.tris.getVAO().release(),e.openGLTexture.deactivate()}},t.updateBufferObjects=()=>{if(!e.tris.getCABO().getElementCount()){const n=new Float32Array(12);for(let o=0;o<4;o++)n[o*3]=o%2*2-1,n[o*3+1]=o>1?1:-1,n[o*3+2]=1;const a=A.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=new Uint16Array(8);i[0]=3,i[1]=0,i[2]=1,i[3]=3,i[4]=3,i[5]=0,i[6]=3,i[7]=2;const s=A.newInstance({numberOfComponents:1,values:i});e.tris.getCABO().createVBO(s,"polys",me.SURFACE,{points:a,cellOffset:0})}e.renderable.getFormat()!==e.lastFormat&&(e.lastFormat=e.renderable.getFormat(),e.lastFormat==="box"&&e.tris.setProgram(e._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec3 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = wpos.xyz/wpos.w;
             }`,`//VTK::System::Dec
             //VTK::Output::Dec
             varying vec3 TexCoords;
             uniform samplerCube sbtexture;
             uniform vec3 camPos;
             void main () {
               // skybox looks from inside out
               // which means we have to adjust
               // our tcoords. Otherwise text would
               // be flipped
               vec3 tc = normalize(TexCoords - camPos);
               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))
               {
                 tc = vec3(1.0, 1.0, -1.0) * tc;
               }
               else
               {
                 tc = vec3(-1.0, 1.0, 1.0) * tc;
               }
               gl_FragData[0] = textureCube(sbtexture, tc);
             }`,"")),e.lastFormat==="background"&&e.tris.setProgram(e._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec2 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;
             }`,`//VTK::System::Dec
             //VTK::Output::Dec
             varying vec2 TexCoords;
             uniform sampler2D sbtexture;
             void main () {
               gl_FragData[0] = texture2D(sbtexture, TexCoords);
             }`,"")),e.tris.getShaderSourceTime().modified(),e.tris.getVAO().bind(),e.tris.getVAO().addAttributeArray(e.tris.getProgram(),e.tris.getCABO(),"vertexMC",e.tris.getCABO().getVertexOffset(),e.tris.getCABO().getStride(),e.context.FLOAT,3,e.context.FALSE)||Qs("Error setting vertexMC in shader VAO."));const r=e.renderable.getTextures();r.length||Qs("vtkSkybox requires a texture map"),e.openGLTexture.getRenderable()!==r[0]&&(e.openGLTexture.releaseGraphicsResources(e._openGLRenderWindow),e.openGLTexture.setRenderable(r[0]))}}const TT={context:null};function vT(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,TT,r),De.extend(t,e,r),e.openGLTexture=he.newInstance(),e.tris=ft.newInstance(),e.keyMatrixTime={},xe(e.keyMatrixTime,{mtime:0}),e.keyMatrices={normalMatrix:ct(new Float64Array(9)),mcwc:X(new Float64Array(16))},Me(t,e,["context"]),Ke(t,e,["activeTextures"]),dT(t,e)}const yT=ye(vT);Oe("vtkSkybox",yT);const{vtkDebugMacro:CT}=We;function ST(t,e){e.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper"),t.opaquePass=(r,n)=>{e._openGLRenderer=t.getFirstAncestorOfType("vtkOpenGLRenderer"),e._openGLRenderWindow=e._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");const a=e._openGLRenderer.getAspectRatio(),i=e._openGLRenderer?e._openGLRenderer.getRenderable().getActiveCamera():null,s=e._openGLRenderer.getTiledSizeAndOrigin();let o=null;if(e.renderable.getUseZValues()){const c=n.getZBufferTexture(),u=Math.floor(c.getWidth()),g=Math.floor(c.getHeight()),f=e._openGLRenderWindow.getContext();c.bind();const l=n.getFramebuffer();l?l.saveCurrentBindingsAndBuffers():CT("No framebuffer to save/restore");const p=f.createFramebuffer();f.bindFramebuffer(f.FRAMEBUFFER,p),f.framebufferTexture2D(f.FRAMEBUFFER,f.COLOR_ATTACHMENT0,f.TEXTURE_2D,c.getHandle(),0),f.checkFramebufferStatus(f.FRAMEBUFFER)===f.FRAMEBUFFER_COMPLETE&&(o=new Uint8Array(u*g*4),f.viewport(0,0,u,g),f.readPixels(0,0,u,g,f.RGBA,f.UNSIGNED_BYTE,o)),l&&l.restorePreviousBindingsAndBuffers(),f.deleteFramebuffer(p)}e.renderable.invokeCallback(e.renderable.getInputData(),i,a,s,o)},t.queryPass=(r,n)=>{r&&e.renderable.getUseZValues()&&n.requestDepth()}}const xT={};function wT(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,xT,r),De.extend(t,e,r),ST(t,e)}const RT=ye(wT,"vtkOpenGLPixelSpaceCallbackMapper");Oe("vtkPixelSpaceCallbackMapper",RT);function Yu(t){let e=0;return t.filter((r,n)=>n===e?(e+=r+1,!0):!1)}function qu(t){let e=0;for(let r=0;r<t.length;)r+=t[r]+1,e++;return e}const MT={extractCellSizes:Yu,getNumberOfCells:qu};function OT(t,e){e.classHierarchy.push("vtkCellArray");const r={...t};t.getNumberOfCells=n=>(e.numberOfCells!==void 0&&!n||(e.cellSizes?e.numberOfCells=e.cellSizes.length:e.numberOfCells=qu(t.getData())),e.numberOfCells),t.getCellSizes=n=>(e.cellSizes!==void 0&&!n||(e.cellSizes=Yu(t.getData())),e.cellSizes),t.resize=n=>{const a=t.getNumberOfTuples();r.resize(n);const i=t.getNumberOfTuples();i<a&&(i===0?(e.numberOfCells=0,e.cellSizes=[]):(e.numberOfCells=void 0,e.cellSizes=void 0))},t.setData=n=>{r.setData(n,1),e.numberOfCells=void 0,e.cellSizes=void 0},t.getCell=n=>{let a=n;const i=e.values[a++];return e.values.subarray(a,a+i)},t.insertNextCell=n=>{const a=t.getNumberOfCells();return t.insertNextTuples([n.length,...n]),++e.numberOfCells,e.cellSizes!=null&&e.cellSizes.push(n.length),a}}function mT(t){return{empty:!0,numberOfComponents:1,dataType:J.UNSIGNED_INT,...t}}function Zu(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};A.extend(t,e,mT(r)),OT(t,e)}const ET=y.newInstance(Zu,"vtkCellArray");var vn={newInstance:ET,extend:Zu,...MT};function DT(t,e){e.classHierarchy.push("vtkCell"),t.initialize=function(r){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:null;if(n){e.pointsIds=n;let a=e.points.getData();a.length!==3*e.pointsIds.length&&(a=y.newTypedArray(r.getDataType(),3*e.pointsIds.length));const i=r.getData();e.pointsIds.forEach((s,o)=>{let c=3*s,u=3*o;a[u]=i[c],a[++u]=i[++c],a[++u]=i[++c]}),e.points.setData(a)}else{e.points=r,e.pointsIds=new Array(r.getNumberOfPoints());for(let a=r.getNumberOfPoints()-1;a>=0;--a)e.pointsIds[a]=a}},t.getBounds=()=>{const r=e.points.getNumberOfPoints(),n=[];if(r){e.points.getPoint(0,n),e.bounds[0]=n[0],e.bounds[1]=n[0],e.bounds[2]=n[1],e.bounds[3]=n[1],e.bounds[4]=n[2],e.bounds[5]=n[2];for(let a=1;a<r;a++)e.points.getPoint(a,n),e.bounds[0]=n[0]<e.bounds[0]?n[0]:e.bounds[0],e.bounds[1]=n[0]>e.bounds[1]?n[0]:e.bounds[1],e.bounds[2]=n[1]<e.bounds[2]?n[1]:e.bounds[2],e.bounds[3]=n[1]>e.bounds[3]?n[1]:e.bounds[3],e.bounds[4]=n[2]<e.bounds[4]?n[2]:e.bounds[4],e.bounds[5]=n[2]>e.bounds[5]?n[2]:e.bounds[5]}else xn(e.bounds);return e.bounds},t.getLength2=()=>{t.getBounds();let r=0,n=0;for(let a=0;a<3;a++)n=e.bounds[2*a+1]-e.bounds[2*a],r+=n*n;return r},t.getParametricDistance=r=>{let n,a=0;for(let i=0;i<3;i++)r[i]<0?n=-r[i]:r[i]>1?n=r[i]-1:n=0,n>a&&(a=n);return a},t.getNumberOfPoints=()=>e.points.getNumberOfPoints(),t.deepCopy=r=>{r.initialize(e.points,e.pointsIds)},t.getCellDimension=()=>{},t.intersectWithLine=(r,n,a,i,s,o,c)=>{},t.evaluatePosition=(r,n,a,i,s,o)=>{y.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.")}}const VT={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function Pu(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,VT,r),y.obj(t,e),e.points||(e.points=er.newInstance()),y.get(t,e,["points","pointsIds"]),DT(t,e)}const LT=y.newInstance(Pu,"vtkCell");var ia={newInstance:LT,extend:Pu};function FT(t,e){let r=e;for(e>=t.array.length&&(r+=t.array.length);r>t.array.length;)t.array.push({ncells:0,cells:null});t.array.length=r}function kT(t,e){e.classHierarchy.push("vtkCellLinks"),t.buildLinks=r=>{const n=r.getPoints().getNumberOfPoints(),a=r.getNumberOfCells(),i=new Uint32Array(n);if(r.isA("vtkPolyData")){for(let s=0;s<a;++s){const{cellPointIds:o}=r.getCellPoints(s);o.forEach(c=>{t.incrementLinkCount(c)})}t.allocateLinks(n),e.maxId=n-1;for(let s=0;s<a;++s){const{cellPointIds:o}=r.getCellPoints(s);o.forEach(c=>{t.insertCellReference(c,i[c]++,s)})}}else{for(let s=0;s<a;s++)ia.newInstance().getPointsIds().forEach(c=>{t.incrementLinkCount(c)});t.allocateLinks(n),e.maxId=n-1;for(let s=0;s<a;++s)ia.newInstance().getPointsIds().forEach(c=>{t.insertCellReference(c,i[c]++,s)})}},t.allocate=function(r){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:1e3;e.array=Array(r).fill().map(()=>({ncells:0,cells:null})),e.extend=n,e.maxId=-1},t.initialize=()=>{e.array=null},t.getLink=r=>e.array[r],t.getNcells=r=>e.array[r].ncells,t.getCells=r=>e.array[r].cells,t.insertNextPoint=r=>{e.array.push({ncells:r,cells:Array(r)}),++e.maxId},t.insertNextCellReference=(r,n)=>{e.array[r].cells[e.array[r].ncells++]=n},t.deletePoint=r=>{e.array[r].ncells=0,e.array[r].cells=null},t.removeCellReference=(r,n)=>{e.array[n].cells=e.array[n].cells.filter(a=>a!==r),e.array[n].ncells=e.array[n].cells.length},t.addCellReference=(r,n)=>{e.array[n].cells[e.array[n].ncells++]=r},t.resizeCellList=(r,n)=>{e.array[r].cells.length=n},t.squeeze=()=>{FT(e,e.maxId+1)},t.reset=()=>{e.maxId=-1},t.deepCopy=r=>{e.array=[...r.array],e.extend=r.extend,e.maxId=r.maxId},t.incrementLinkCount=r=>{++e.array[r].ncells},t.allocateLinks=r=>{for(let n=0;n<r;++n)e.array[n].cells=new Array(e.array[n].ncells)},t.insertCellReference=(r,n,a)=>{e.array[r].cells[n]=a}}const NT={array:null,maxId:0,extend:0};function Ju(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,NT,r),y.obj(t,e),kT(t,e)}const _T=y.newInstance(Ju,"vtkCellLinks");var GT={newInstance:_T,extend:Ju};const ce={VTK_EMPTY_CELL:0,VTK_VERTEX:1,VTK_POLY_VERTEX:2,VTK_LINE:3,VTK_POLY_LINE:4,VTK_TRIANGLE:5,VTK_TRIANGLE_STRIP:6,VTK_POLYGON:7,VTK_PIXEL:8,VTK_QUAD:9,VTK_TETRA:10,VTK_VOXEL:11,VTK_HEXAHEDRON:12,VTK_WEDGE:13,VTK_PYRAMID:14,VTK_PENTAGONAL_PRISM:15,VTK_HEXAGONAL_PRISM:16,VTK_QUADRATIC_EDGE:21,VTK_QUADRATIC_TRIANGLE:22,VTK_QUADRATIC_QUAD:23,VTK_QUADRATIC_POLYGON:36,VTK_QUADRATIC_TETRA:24,VTK_QUADRATIC_HEXAHEDRON:25,VTK_QUADRATIC_WEDGE:26,VTK_QUADRATIC_PYRAMID:27,VTK_BIQUADRATIC_QUAD:28,VTK_TRIQUADRATIC_HEXAHEDRON:29,VTK_QUADRATIC_LINEAR_QUAD:30,VTK_QUADRATIC_LINEAR_WEDGE:31,VTK_BIQUADRATIC_QUADRATIC_WEDGE:32,VTK_BIQUADRATIC_QUADRATIC_HEXAHEDRON:33,VTK_BIQUADRATIC_TRIANGLE:34,VTK_CUBIC_LINE:35,VTK_CONVEX_POINT_SET:41,VTK_POLYHEDRON:42,VTK_PARAMETRIC_CURVE:51,VTK_PARAMETRIC_SURFACE:52,VTK_PARAMETRIC_TRI_SURFACE:53,VTK_PARAMETRIC_QUAD_SURFACE:54,VTK_PARAMETRIC_TETRA_REGION:55,VTK_PARAMETRIC_HEX_REGION:56,VTK_HIGHER_ORDER_EDGE:60,VTK_HIGHER_ORDER_TRIANGLE:61,VTK_HIGHER_ORDER_QUAD:62,VTK_HIGHER_ORDER_POLYGON:63,VTK_HIGHER_ORDER_TETRAHEDRON:64,VTK_HIGHER_ORDER_WEDGE:65,VTK_HIGHER_ORDER_PYRAMID:66,VTK_HIGHER_ORDER_HEXAHEDRON:67,VTK_LAGRANGE_CURVE:68,VTK_LAGRANGE_TRIANGLE:69,VTK_LAGRANGE_QUADRILATERAL:70,VTK_LAGRANGE_TETRAHEDRON:71,VTK_LAGRANGE_HEXAHEDRON:72,VTK_LAGRANGE_WEDGE:73,VTK_LAGRANGE_PYRAMID:74,VTK_NUMBER_OF_CELL_TYPES:75},hi=["vtkEmptyCell","vtkVertex","vtkPolyVertex","vtkLine","vtkPolyLine","vtkTriangle","vtkTriangleStrip","vtkPolygon","vtkPixel","vtkQuad","vtkTetra","vtkVoxel","vtkHexahedron","vtkWedge","vtkPyramid","vtkPentagonalPrism","vtkHexagonalPrism","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkQuadraticEdge","vtkQuadraticTriangle","vtkQuadraticQuad","vtkQuadraticTetra","vtkQuadraticHexahedron","vtkQuadraticWedge","vtkQuadraticPyramid","vtkBiQuadraticQuad","vtkTriQuadraticHexahedron","vtkQuadraticLinearQuad","vtkQuadraticLinearWedge","vtkBiQuadraticQuadraticWedge","vtkBiQuadraticQuadraticHexahedron","vtkBiQuadraticTriangle","vtkCubicLine","vtkQuadraticPolygon","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkConvexPointSet","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkParametricCurve","vtkParametricSurface","vtkParametricTriSurface","vtkParametricQuadSurface","vtkParametricTetraRegion","vtkParametricHexRegion","UnknownClass","UnknownClass","UnknownClass","vtkHigherOrderEdge","vtkHigherOrderTriangle","vtkHigherOrderQuad","vtkHigherOrderPolygon","vtkHigherOrderTetrahedron","vtkHigherOrderWedge","vtkHigherOrderPyramid","vtkHigherOrderHexahedron"];function UT(t){return t<hi.length?hi[t]:"UnknownClass"}function BT(t){return hi.findIndex(t)}function WT(t){return t<ce.VTK_QUADRATIC_EDGE||t===ce.VTK_CONVEX_POINT_SET||t===ce.VTK_POLYHEDRON}function $T(t){return t===ce.VTK_TRIANGLE_STRIP||t===ce.VTK_POLY_LINE||t===ce.VTK_POLY_VERTEX}const zT={getClassNameFromTypeId:UT,getTypeIdFromClassName:BT,isLinear:WT,hasSubCells:$T};function HT(t,e){e.classHierarchy.push("vtkCellTypes"),t.allocate=function(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:512,n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:1e3;e.size=r>0?r:1,e.extend=n>0?n:1,e.maxId=-1,e.typeArray=new Uint8Array(r),e.locationArray=new Uint32Array(r)},t.insertCell=(r,n,a)=>{e.typeArray[r]=n,e.locationArray[r]=a,r>e.maxId&&(e.maxId=r)},t.insertNextCell=(r,n)=>(t.insertCell(++e.maxId,r,n),e.maxId),t.setCellTypes=(r,n,a)=>{e.size=r,e.typeArray=n,e.locationArray=a,e.maxId=r-1},t.getCellLocation=r=>e.locationArray[r],t.deleteCell=r=>{e.typeArray[r]=ce.VTK_EMPTY_CELL},t.getNumberOfTypes=()=>e.maxId+1,t.isType=r=>{const n=t.getNumberOfTypes();for(let a=0;a<n;++a)if(r===t.getCellType(a))return!0;return!1},t.insertNextType=r=>t.insertNextCell(r,-1),t.getCellType=r=>e.typeArray[r],t.reset=()=>{e.maxId=-1},t.deepCopy=r=>{t.allocate(r.getSize(),r.getExtend()),e.typeArray.set(r.getTypeArray()),e.locationArray.set(r.getLocationArray()),e.maxId=r.getMaxId()}}const jT={size:0,maxId:-1,extend:1e3};function Qu(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,jT,r),y.obj(t,e),y.get(t,e,["size","maxId","extend"]),y.getArray(t,e,["typeArray","locationArray"]),HT(t,e)}const bT=y.newInstance(Qu,"vtkCellTypes");var KT={newInstance:bT,extend:Qu,...zT};const XT={NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2};var Iu={IntersectionState:XT};const{IntersectionState:jr}=Iu;function pn(t,e,r){let n=arguments.length>3&&arguments[3]!==void 0?arguments[3]:null;const a={t:Number.MIN_VALUE,distance:0},i=[];let s;i[0]=r[0]-e[0],i[1]=r[1]-e[1],i[2]=r[2]-e[2];const o=i[0]*(t[0]-e[0])+i[1]*(t[1]-e[1])+i[2]*(t[2]-e[2]),c=b(i,i);let u=1e-5*o;return c!==0&&(a.t=o/c),u<0&&(u=-u),-u<c&&c<u||c<=0||a.t<0?s=e:a.t>1?s=r:(s=i,i[0]=e[0]+a.t*i[0],i[1]=e[1]+a.t*i[1],i[2]=e[2]+a.t*i[2]),n&&(n[0]=s[0],n[1]=s[1],n[2]=s[2]),a.distance=Ye(s,t),a}function ef(t,e,r,n,a,i){const s=[],o=[],c=[];a[0]=0,i[0]=0,re(e,t,s),re(n,r,o),re(r,t,c);const u=[b(s,s),-b(s,o),-b(s,o),b(o,o)],g=[];if(g[0]=b(s,c),g[1]=-b(o,c),kc(u,g,2)===0){let f=Number.MAX_VALUE;const l=[t,e,r,n],p=[r,r,t,t],d=[n,n,e,e];i[0],i[0],a[0],a[0],a[0],a[0],i[0],i[0];let h;for(let T=0;T<4;T++)h=pn(l[T],p[T],d[T]),h.distance<f&&(f=h.distance);return jr.ON_LINE}return a[0]=g[0],i[0]=g[1],a[0]>=0&&a[0]<=1&&i[0]>=0&&i[0]<=1?jr.YES_INTERSECTION:jr.NO_INTERSECTION}const AT={distanceToLine:pn,intersection:ef};function YT(t,e){e.classHierarchy.push("vtkLine");function r(n){return n>=0&&n<=1}t.getCellDimension=()=>1,t.intersectWithLine=(n,a,i,s,o)=>{const c={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};o[1]=0,o[2]=0;const u=[],g=[],f=[];e.points.getPoint(0,g),e.points.getPoint(1,f);const l=[],p=[],d=ef(n,a,g,f,l,p);if(c.t=l[0],c.betweenPoints=r(c.t),o[0]=p[0],d===jr.YES_INTERSECTION){for(let h=0;h<3;h++)s[h]=g[h]+o[0]*(f[h]-g[h]),u[h]=n[h]+c.t*(a[h]-n[h]);if(Ye(s,u)<=i*i)return c.intersect=1,c}else{let h;if(c.t<0)return h=pn(n,g,f,s),h.distance<=i*i&&(c.t=0,c.intersect=1,c.betweenPoints=!0),c;if(c.t>1)return h=pn(a,g,f,s),h.distance<=i*i&&(c.t=1,c.intersect=1,c.betweenPoints=!0),c;if(o[0]<0)return o[0]=0,h=pn(g,n,a,s),c.t=h.t,h.distance<=i*i&&(c.intersect=1),c;if(o[0]>1)return o[0]=1,h=pn(f,n,a,s),c.t=h.t,h.distance<=i*i&&(c.intersect=1),c}return c},t.evaluateLocation=(n,a,i)=>{const s=[],o=[];e.points.getPoint(0,s),e.points.getPoint(1,o);for(let c=0;c<3;c++)a[c]=s[c]+n[0]*(o[c]-s[c]);i[0]=1-n[0],i[1]=n[0]},t.evaluateOrientation=(n,a,i)=>e.orientations?(wl(a,e.orientations[0],e.orientations[1],n[0]),i[0]=1-n[0],i[1]=n[0],!0):!1}const qT={orientations:null};function tf(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,qT,r),ia.extend(t,e,r),y.setGet(t,e,["orientations"]),YT(t,e)}const ZT=y.newInstance(tf,"vtkLine");var Ue={newInstance:ZT,extend:tf,...AT,...Iu};function PT(t,e){e.classHierarchy.push("vtkPointSet"),e.points?e.points=Ze(e.points):e.points=er.newInstance(),t.getNumberOfPoints=()=>e.points.getNumberOfPoints(),t.getBounds=()=>e.points.getBounds(),t.computeBounds=()=>{t.getBounds()};const r=t.shallowCopy;t.shallowCopy=function(n){let a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;r(n,a),e.points=er.newInstance(),e.points.shallowCopy(n.getPoints())}}const JT={};function nf(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,JT,r),wn.extend(t,e,r),y.setGet(t,e,["points"]),PT(t,e)}const QT=y.newInstance(nf,"vtkPointSet");var IT={newInstance:QT,extend:nf};function ns(t,e,r,n){const a=r[0]-e[0],i=r[1]-e[1],s=r[2]-e[2],o=t[0]-e[0],c=t[1]-e[1],u=t[2]-e[2];n[0]=i*u-s*c,n[1]=s*o-a*u,n[2]=a*c-i*o}function sa(t,e,r,n){ns(t,e,r,n);const a=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);a!==0&&(n[0]/=a,n[1]/=a,n[2]/=a)}function ev(t,e,r,n,a,i){let s=arguments.length>6&&arguments[6]!==void 0?arguments[6]:1e-6,o=!1;const c=[],u=[],g=[],f=[],l=[];sa(t,e,r,f),sa(n,a,i,l);const p=-b(f,t),d=-b(l,n),h=[b(l,t)+d,b(l,e)+d,b(l,r)+d];if(h[0]*h[1]>s&&h[0]*h[2]>s)return{intersect:!1,coplanar:o,pt1:c,pt2:u,surfaceId:g};const T=[b(f,n)+p,b(f,a)+p,b(f,i)+p];if(T[0]*T[1]>s&&T[0]*T[2]>s)return{intersect:!1,coplanar:o,pt1:c,pt2:u,surfaceId:g};if(Math.abs(f[0]-l[0])<1e-9&&Math.abs(f[1]-l[1])<1e-9&&Math.abs(f[2]-l[2])<1e-9&&Math.abs(p-d)<1e-9)return o=!0,{intersect:!1,coplanar:o,pt1:c,pt2:u,surfaceId:g};const v=[t,e,r],C=[n,a,i],S=b(f,l),x=(p-d*S)/(S*S-1),R=(d-p*S)/(S*S-1),O=[x*f[0]+R*l[0],x*f[1]+R*l[1],x*f[2]+R*l[2]],w=Te(f,l,[]);pe(w);let m=0,E=0;const M=[],D=[];let N=50,G=50;for(let F=0;F<3;F++){const z=F,U=(F+1)%3,k=be.intersectWithLine(v[z],v[U],n,l);k.intersection&&k.t>0-s&&k.t<1+s&&(k.t<1+s&&k.t>1-s&&(N=m),M[m++]=b(k.x,w)-b(O,w));const L=be.intersectWithLine(C[z],C[U],t,f);L.intersection&&L.t>0-s&&L.t<1+s&&(L.t<1+s&&L.t>1-s&&(G=E),D[E++]=b(L.x,w)-b(O,w))}if(m>2){m--;const F=M[2];M[2]=M[N],M[N]=F}if(E>2){E--;const F=D[2];D[2]=D[G],D[G]=F}if(m!==2||E!==2)return{intersect:!1,coplanar:o,pt1:c,pt2:u,surfaceId:g};if(Number.isNaN(M[0])||Number.isNaN(M[1])||Number.isNaN(D[0])||Number.isNaN(D[1]))return{intersect:!1,coplanar:o,pt1:c,pt2:u,surfaceId:g};if(M[0]>M[1]){const F=M[1];M[1]=M[0],M[0]=F}if(D[0]>D[1]){const F=D[1];D[1]=D[0],D[0]=F}let _,B;return M[1]<D[0]||D[1]<M[0]?{intersect:!1,coplanar:o,pt1:c,pt2:u,surfaceId:g}:(M[0]<D[0]?M[1]<D[1]?(g[0]=2,g[1]=1,_=D[0],B=M[1]):(g[0]=2,g[1]=2,_=D[0],B=D[1]):M[1]<D[1]?(g[0]=1,g[1]=1,_=M[0],B=M[1]):(g[0]=1,g[1]=2,_=M[0],B=D[1]),Tt(O,w,_,c),Tt(O,w,B,u),{intersect:!0,coplanar:o,pt1:c,pt2:u,surfaceId:g})}const tv={computeNormalDirection:ns,computeNormal:sa,intersectWithTriangle:ev};function nv(t,e){e.classHierarchy.push("vtkTriangle"),t.getCellDimension=()=>2,t.intersectWithLine=(r,n,a,i,s)=>{const o={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};s[2]=0;const c=[],u=a*a,g=[],f=[],l=[];e.points.getPoint(0,g),e.points.getPoint(1,f),e.points.getPoint(2,l);const p=[],d=[];if(sa(g,f,l,p),p[0]!==0||p[1]!==0||p[2]!==0){const S=be.intersectWithLine(r,n,g,p);if(o.betweenPoints=S.betweenPoints,o.t=S.t,i[0]=S.x[0],i[1]=S.x[1],i[2]=S.x[2],!S.intersection)return s[0]=0,s[1]=0,o.intersect=0,o;const x=t.evaluatePosition(i,c,s,d);if(x.evaluation>=0)return x.dist2<=u?(o.intersect=1,o):(o.intersect=x.evaluation,o)}const h=Ye(g,f),T=Ye(f,l),v=Ye(l,g);e.line||(e.line=Ue.newInstance()),h>T&&h>v?(e.line.getPoints().setPoint(0,g),e.line.getPoints().setPoint(1,f)):T>v&&T>h?(e.line.getPoints().setPoint(0,f),e.line.getPoints().setPoint(1,l)):(e.line.getPoints().setPoint(0,l),e.line.getPoints().setPoint(1,g));const C=e.line.intersectWithLine(r,n,a,i,s);if(o.betweenPoints=C.betweenPoints,o.t=C.t,C.intersect){const S=[],x=[],R=[];for(let O=0;O<3;O++)S[O]=g[O]-l[O],x[O]=f[O]-l[O],R[O]=i[O]-l[O];return s[0]=b(R,S)/v,s[1]=b(R,x)/T,o.intersect=1,o}return s[0]=0,s[1]=0,o.intersect=0,o},t.evaluatePosition=(r,n,a,i)=>{const s={subId:0,dist2:0,evaluation:-1};let o,c;const u=[],g=[],f=[],l=[];let p;const d=[],h=[],T=[];let v=0,C=0;const S=[];let x,R,O,w=[];const m=[],E=[],M=[];s.subId=0,a[2]=0,e.points.getPoint(1,u),e.points.getPoint(2,g),e.points.getPoint(0,f),ns(u,g,f,l),be.generalizedProjectPoint(r,u,l,M);let D=0;for(o=0;o<3;o++)l[o]<0?p=-l[o]:p=l[o],p>D&&(D=p,C=o);for(c=0,o=0;o<3;o++)o!==C&&(S[c++]=o);for(o=0;o<2;o++)d[o]=M[S[o]]-f[S[o]],h[o]=u[S[o]]-f[S[o]],T[o]=g[S[o]]-f[S[o]];if(v=le(h,T),v===0)return a[0]=0,a[1]=0,s.evaluation=-1,s;if(a[0]=le(d,T)/v,a[1]=le(h,d)/v,i[0]=1-(a[0]+a[1]),i[1]=a[0],i[2]=a[1],i[0]>=0&&i[0]<=1&&i[1]>=0&&i[1]<=1&&i[2]>=0&&i[2]<=1)n&&(s.dist2=Ye(M,r),n[0]=M[0],n[1]=M[1],n[2]=M[2]),s.evaluation=1;else{let N;if(n){if(i[1]<0&&i[2]<0)for(x=Ye(r,f),R=Ue.distanceToLine(r,u,f,N,m),O=Ue.distanceToLine(r,f,g,N,E),x<R?(s.dist2=x,w=f):(s.dist2=R,w=m),O<s.dist2&&(s.dist2=O,w=E),o=0;o<3;o++)n[o]=w[o];else if(i[2]<0&&i[0]<0)for(x=Ye(r,u),R=Ue.distanceToLine(r,u,f,N,m),O=Ue.distanceToLine(r,u,g,N,E),x<R?(s.dist2=x,w=u):(s.dist2=R,w=m),O<s.dist2&&(s.dist2=O,w=E),o=0;o<3;o++)n[o]=w[o];else if(i[1]<0&&i[0]<0)for(x=Ye(r,g),R=Ue.distanceToLine(r,g,f,N,m),O=Ue.distanceToLine(r,u,g,N,E),x<R?(s.dist2=x,w=g):(s.dist2=R,w=m),O<s.dist2&&(s.dist2=O,w=E),o=0;o<3;o++)n[o]=w[o];else if(i[0]<0){const G=Ue.distanceToLine(r,u,g,n);s.dist2=G.distance}else if(i[1]<0){const G=Ue.distanceToLine(r,g,f,n);s.dist2=G.distance}else if(i[2]<0){const G=Ue.distanceToLine(r,u,f,n);s.dist2=G.distance}}s.evaluation=0}return s},t.evaluateLocation=(r,n,a)=>{const i=[],s=[],o=[];e.points.getPoint(0,i),e.points.getPoint(1,s),e.points.getPoint(2,o);const c=1-r[0]-r[1];for(let u=0;u<3;u++)n[u]=i[u]*c+s[u]*r[0]+o[u]*r[1];a[0]=c,a[1]=r[0],a[2]=r[1]},t.getParametricDistance=r=>{let n,a=0;const i=[];i[0]=r[0],i[1]=r[1],i[2]=1-r[0]-r[1];for(let s=0;s<3;s++)i[s]<0?n=-i[s]:i[s]>1?n=i[s]-1:n=0,n>a&&(a=n);return a}}const rv={};function rf(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,rv,r),ia.extend(t,e,r),nv(t,e)}const av=y.newInstance(rf,"vtkTriangle");var iv={newInstance:av,extend:rf,...tv};const Yn=["verts","lines","polys","strips"],{vtkWarningMacro:Is}=y,sv={[ce.VTK_LINE]:Ue,[ce.VTK_POLY_LINE]:Ue,[ce.VTK_TRIANGLE]:iv};function ov(t,e){e.classHierarchy.push("vtkPolyData");function r(a){return a.replace(/(?:^\w|[A-Z]|\b\w)/g,i=>i.toUpperCase()).replace(/\s+/g,"")}Yn.forEach(a=>{t[`getNumberOf${r(a)}`]=()=>e[a].getNumberOfCells(),e[a]?e[a]=Ze(e[a]):e[a]=vn.newInstance()}),t.getNumberOfCells=()=>Yn.reduce((a,i)=>a+e[i].getNumberOfCells(),0);const n=t.shallowCopy;t.shallowCopy=function(a){let i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;n(a,i),Yn.forEach(s=>{e[s]=vn.newInstance(),e[s].shallowCopy(a.getReferenceByName(s))})},t.buildCells=()=>{const a=t.getNumberOfVerts(),i=t.getNumberOfLines(),s=t.getNumberOfPolys(),o=t.getNumberOfStrips(),c=a+i+s+o,u=new Uint8Array(c);let g=u;const f=new Uint32Array(c);let l=f;if(a){let p=0;e.verts.getCellSizes().forEach((d,h)=>{l[h]=p,g[h]=d>1?ce.VTK_POLY_VERTEX:ce.VTK_VERTEX,p+=d+1}),l=l.subarray(a),g=g.subarray(a)}if(i){let p=0;e.lines.getCellSizes().forEach((d,h)=>{l[h]=p,g[h]=d>2?ce.VTK_POLY_LINE:ce.VTK_LINE,d===1&&Is("Building VTK_LINE ",h," with only one point, but VTK_LINE needs at least two points. Check the input."),p+=d+1}),l=l.subarray(i),g=g.subarray(i)}if(s){let p=0;e.polys.getCellSizes().forEach((d,h)=>{switch(l[h]=p,d){case 3:g[h]=ce.VTK_TRIANGLE;break;case 4:g[h]=ce.VTK_QUAD;break;default:g[h]=ce.VTK_POLYGON;break}d<3&&Is("Building VTK_TRIANGLE ",h," with less than three points, but VTK_TRIANGLE needs at least three points. Check the input."),p+=d+1}),l+=l.subarray(s),g+=g.subarray(s)}if(o){let p=0;g.fill(ce.VTK_TRIANGLE_STRIP,0,o),e.strips.getCellSizes().forEach((d,h)=>{l[h]=p,p+=d+1})}e.cells=KT.newInstance(),e.cells.setCellTypes(c,u,f)},t.buildLinks=function(){let a=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;e.cells===void 0&&t.buildCells(),e.links=GT.newInstance(),a>0?e.links.allocate(a):e.links.allocate(t.getPoints().getNumberOfPoints()),e.links.buildLinks(t)},t.getCellType=a=>e.cells.getCellType(a),t.getCellPoints=a=>{const i=t.getCellType(a);let s=null;switch(i){case ce.VTK_VERTEX:case ce.VTK_POLY_VERTEX:s=e.verts;break;case ce.VTK_LINE:case ce.VTK_POLY_LINE:s=e.lines;break;case ce.VTK_TRIANGLE:case ce.VTK_QUAD:case ce.VTK_POLYGON:s=e.polys;break;case ce.VTK_TRIANGLE_STRIP:s=e.strips;break;default:return s=null,{type:0,cellPointIds:null}}const o=e.cells.getCellLocation(a),c=s.getCell(o);return{cellType:i,cellPointIds:c}},t.getPointCells=a=>e.links.getCells(a),t.getCellEdgeNeighbors=(a,i,s)=>{const o=e.links.getLink(i),c=e.links.getLink(s);return o.cells.filter(u=>u!==a&&c.cells.indexOf(u)!==-1)},t.getCell=function(a){let i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:null;const s=t.getCellPoints(a),o=i||sv[s.cellType].newInstance();return o.initialize(t.getPoints(),s.cellPointIds),o}}const cv={};function af(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,cv,r),IT.extend(t,e,r),y.get(t,e,["cells","links"]),y.setGet(t,e,["verts","lines","polys","strips"]),ov(t,e)}const uv=y.newInstance(af,"vtkPolyData");var Be={newInstance:uv,extend:af};const{vtkErrorMacro:fv}=y;class gv{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const r=e[0],n=e[e.length-1];if(r===n||e.length<2)return;const a=this.segmentMapping[r],i=this.segmentMapping[n];if(a!==void 0&&i!==void 0)if(Math.abs(a)===Math.abs(i)){const s=a<i?i:a,o=this.segments[s];if(a>0)for(let c=1;c<e.length-1;c++)o.push(e[c]);else for(let c=1;c<e.length-1;c++)o.unshift(e[e.length-1-c]);this.faces.push(o),this.segments[s]=null,this.segmentMapping[r]=void 0,this.segmentMapping[n]=void 0}else{const s=Math.abs(a),o=Math.abs(i),c=this.segments[s],u=this.segments[o];this.segments[s]=null,this.segments[o]=null,this.segmentMapping[c[0]]=void 0,this.segmentMapping[u[0]]=void 0,this.segmentMapping[c[c.length-1]]=void 0,this.segmentMapping[u[u.length-1]]=void 0,this.addSegment(e),this.addSegment(c),this.addSegment(u)}else if(a!==void 0){if(a>0){const s=this.segments[a];for(let o=1;o<e.length;o++)s.push(e[o]);this.segmentMapping[n]=a}else{const s=this.segments[-a];this.segmentMapping[n]=a;for(let o=1;o<e.length;o++)s.unshift(e[o])}this.segmentMapping[r]=void 0}else if(i!==void 0){if(i>0){const s=this.segments[i];for(let o=1;o<e.length;o++)s.push(e[e.length-1-o]);this.segmentMapping[r]=i}else{const s=this.segments[-i];this.segmentMapping[r]=i;for(let o=1;o<e.length;o++)s.unshift(e[e.length-o-1])}this.segmentMapping[n]=void 0}else{const s=this.segments.length;this.segments.push(e),this.segmentMapping[r]=-s,this.segmentMapping[n]=s}}}function lv(t,e){e.classHierarchy.push("vtkClosedPolyLineToSurfaceFilter"),t.requestData=(r,n)=>{const a=r[0];if(!a){fv("Invalid or missing input");return}const i=Be.newInstance();i.shallowCopy(a);const s=new gv,o=a.getLines().getData();let c=0;for(;c<o.length;){const l=o[c++],p=[];for(let d=0;d<l;d++)p.push(o[c+d]);s.addSegment(p),c+=l}const{faces:u}=s;let g=u.length;for(let l=0;l<u.length;l++)g+=u[l].length;const f=new Uint16Array(g);c=0;for(let l=0;l<u.length;l++){const p=u[l];f[c++]=p.length;for(let d=0;d<p.length;d++)f[c++]=p[d]}i.setPolys(vn.newInstance({values:f,name:"faces"})),n[0]=i}}const pv={};function sf(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,pv,r),y.obj(t,e),y.algo(t,e,1,1),lv(t,e)}const hv=y.newInstance(sf,"vtkClosedPolyLineToSurfaceFilter");var dv={newInstance:hv,extend:sf};const{vtkErrorMacro:eo}=We;function Tv(t){const e=t.getPolys().getData(),r=t.getStrips().getData(),n={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(n.polyIdx<e.length){n.cellSize=e[n.polyIdx];const a=n.polyIdx+1,i=a+n.cellSize;n.polyIdx=i;let s=0;for(let o=a;o<i;++o)n.cell[s++]=e[o]}else if(n.stripIdx<r.length){n.cellSize=3,n.remainingStripLength===0&&(n.remainingStripLength=r[n.stripIdx]-2,n.stripIdx+=3);const a=n.stripIdx-2,i=n.stripIdx+1;n.stripIdx++,n.remainingStripLength--;let s=0;for(let o=a;o<i;++o)n.cell[s++]=r[o]}else if(!n.done)n.done=!0;else throw new Error("Iterator is done")}};return n.next(),n}function vv(t,e){e.classHierarchy.push("vtkCutter");const r={...t};t.getMTime=()=>{let a=r.getMTime();return e.cutFunction&&(a=Math.max(a,e.cutFunction.getMTime())),a};function n(a,i){const s=a.getPoints(),o=s.getData(),c=s.getNumberOfPoints(),u=[],g=[],f=[];(!e.cutScalars||e.cutScalars.length<c)&&(e.cutScalars=new Float32Array(c));let l=0,p=0;for(;l<o.length;)e.cutScalars[p++]=e.cutFunction.evaluateFunction(o[l++],o[l++],o[l++]);const d=[],h=new Array(3),T=new Array(3),v=[];for(const S=Tv(a);!S.done;S.next()){if(S.cellSize<=2)continue;for(let m=0;m<S.cellSize;)v[m]=e.cutScalars[S.cell[m++]];const x=v[0]>0;let R=!0;for(let m=1;m<S.cell.length;m++)if(v[m]>0!==x){R=!1;break}if(R)continue;const O=[];for(let m=0;m<S.cellSize;m++){const E=m+1===S.cellSize?0:m+1,M=v[m]>0;if(v[E]>0===M)continue;let N=m,G=E,_=v[G]-v[N];_<=0&&(N=E,G=m,_*=-1);let B=0;_!==0&&(B=(e.cutValue-v[N])/_);const F=S.cell[N],z=S.cell[G];h[0]=o[F*3],h[1]=o[F*3+1],h[2]=o[F*3+2],T[0]=o[z*3],T[1]=o[z*3+1],T[2]=o[z*3+2];const U=[h[0]+B*(T[0]-h[0]),h[1]+B*(T[1]-h[1]),h[2]+B*(T[2]-h[2])];O.push({pointEdge1:F,pointEdge2:z,intersectedPoint:U,newPointID:-1})}for(let m=0;m<O.length;m++){const E=O[m];let M=!1;for(let D=0;D<d.length;D++){const N=d[D],G=E.pointEdge1===N.pointEdge1&&E.pointEdge2===N.pointEdge2,_=E.intersectedPoint[0]===N.intersectedPoint[0]&&E.intersectedPoint[1]===N.intersectedPoint[1]&&E.intersectedPoint[2]===N.intersectedPoint[2];if(G||_){M=!0,O[m].newPointID=d[D].newPointID;break}}M||(u.push(E.intersectedPoint[0]),u.push(E.intersectedPoint[1]),u.push(E.intersectedPoint[2]),O[m].newPointID=u.length/3-1,d.push(O[m]))}const w=O.length;w===2?g.push(w,O[0].newPointID,O[1].newPointID):w>2&&(f.push(w),O.forEach(m=>{f.push(m.newPointID)}))}i.getPoints().setData(ha(s.getDataType(),u),3),g.length!==0&&i.getLines().setData(Uint16Array.from(g)),f.length!==0&&i.getPolys().setData(Uint16Array.from(f))}t.requestData=(a,i)=>{const s=a[0];if(!s){eo("Invalid or missing input");return}if(!e.cutFunction){eo("Missing cut function");return}const o=Be.newInstance();n(s,o),i[0]=o}}const yv={cutFunction:null,cutScalars:null,cutValue:0};function of(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,yv,r),xe(t,e),ki(t,e,1,1),Me(t,e,["cutFunction","cutValue"]),vv(t,e)}const Cv=ye(of,"vtkCutter");var cf={newInstance:Cv,extend:of};const Sv=t=>t,to=1e-6;class uf{constructor(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:!1;this.matrix=X(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?Rl:Sv}rotateFromDirections(e,r){const n=new Float64Array(3),a=new Float64Array(3),i=new Float64Array(16);oe(n,e[0],e[1],e[2]),oe(a,r[0],r[1],r[2]),Ct(n,n),Ct(a,a);const s=qa(n,a);return s>=1?this:(Da(this.tmp,n,a),jn(this.tmp)<to&&(Da(this.tmp,[1,0,0],e),jn(this.tmp)<to&&Da(this.tmp,[0,1,0],e)),Ml(i,Math.acos(s),this.tmp),ae(this.matrix,this.matrix,i),this)}rotate(e,r){return oe(this.tmp,...r),Ct(this.tmp,this.tmp),Fe(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return Ei(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return Zr(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return Di(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,r,n){return oe(this.tmp,e,r,n),ge(this.matrix,this.matrix,this.tmp),this}scale(e,r,n){return oe(this.tmp,e,r,n),nn(this.matrix,this.matrix,this.tmp),this}multiply(e){return ae(this.matrix,this.matrix,e),this}multiply3x3(e){return ae(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return je(this.matrix,this.matrix),this}identity(){return X(this.matrix),this}apply(e){let r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:-1;if(fr(Bi,this.matrix))return this;const a=n===-1?e.length:r+n*3;for(let i=r;i<a;i+=3)oe(this.tmp,e[i],e[i+1],e[i+2]),q(this.tmp,this.tmp,this.matrix),e[i]=this.tmp[0],e[i+1]=this.tmp[1],e[i+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&e.length===16&&Re(this.matrix,e),this}}function xv(){return new uf(!0)}function wv(){return new uf(!1)}var ot={buildFromDegree:xv,buildFromRadian:wv};const Rv=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],Mv=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22];function Ov(t,e){e.classHierarchy.push("vtkCubeSource");function r(n,a){if(e.deleted)return;const i=Be.newInstance();a[0]=i;const s=24,o=y.newTypedArray(e.pointType,s*3);i.getPoints().setData(o,3);const c=y.newTypedArray(e.pointType,s*3),u=A.newInstance({name:"Normals",values:c,numberOfComponents:3});i.getPointData().setNormals(u);let g=2;e.generate3DTextureCoordinates===!0&&(g=3);const f=y.newTypedArray(e.pointType,s*g),l=A.newInstance({name:"TextureCoordinates",values:f,numberOfComponents:g});i.getPointData().setTCoords(l);const p=[0,0,0],d=[0,0,0],h=[0,0];let T=0;p[0]=-e.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let v=0;v<2;v++){p[1]=-e.yLength/2;for(let C=0;C<2;C++){h[1]=p[1]+.5,p[2]=-e.zLength/2;for(let S=0;S<2;S++)h[0]=(p[2]+.5)*(1-2*v),o[T*3]=p[0],o[T*3+1]=p[1],o[T*3+2]=p[2],c[T*3]=d[0],c[T*3+1]=d[1],c[T*3+2]=d[2],g===2?(f[T*g]=h[0],f[T*g+1]=h[1]):(f[T*g]=2*v-1,f[T*g+1]=2*C-1,f[T*g+2]=2*S-1),T++,p[2]+=e.zLength;p[1]+=e.yLength}p[0]+=e.xLength,d[0]+=2}p[1]=-e.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let v=0;v<2;v++){p[0]=-e.xLength/2;for(let C=0;C<2;C++){h[0]=(p[0]+.5)*(2*v-1),p[2]=-e.zLength/2;for(let S=0;S<2;S++)h[1]=(p[2]+.5)*-1,o[T*3]=p[0],o[T*3+1]=p[1],o[T*3+2]=p[2],c[T*3]=d[0],c[T*3+1]=d[1],c[T*3+2]=d[2],g===2?(f[T*g]=h[0],f[T*g+1]=h[1]):(f[T*g]=2*C-1,f[T*g+1]=2*v-1,f[T*g+2]=2*S-1),T++,p[2]+=e.zLength;p[0]+=e.xLength}p[1]+=e.yLength,d[1]+=2}p[2]=-e.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let v=0;v<2;v++){p[1]=-e.yLength/2;for(let C=0;C<2;C++){h[1]=p[1]+.5,p[0]=-e.xLength/2;for(let S=0;S<2;S++)h[0]=(p[0]+.5)*(2*v-1),o[T*3]=p[0],o[T*3+1]=p[1],o[T*3+2]=p[2],c[T*3]=d[0],c[T*3+1]=d[1],c[T*3+2]=d[2],g===2?(f[T*g]=h[0],f[T*g+1]=h[1]):(f[T*g]=2*S-1,f[T*g+1]=2*C-1,f[T*g+2]=2*v-1),T++,p[0]+=e.xLength;p[1]+=e.yLength}p[2]+=e.zLength,d[2]+=2}if(e.rotations&&ot.buildFromDegree().rotateX(e.rotations[0]).rotateY(e.rotations[1]).rotateZ(e.rotations[2]).apply(o).apply(c),e.center&&ot.buildFromRadian().translate(...e.center).apply(o),e.matrix){ot.buildFromRadian().setMatrix(e.matrix).apply(o);const v=[e.matrix[0],e.matrix[1],e.matrix[2],0,e.matrix[4],e.matrix[5],e.matrix[6],0,e.matrix[8],e.matrix[9],e.matrix[10],0,0,0,0,1];ot.buildFromRadian().setMatrix(v).apply(c)}e.generateFaces?i.getPolys().deepCopy(e._polys):i.getPolys().initialize(),e.generateLines?(i.getLines().deepCopy(e._lineCells),i.getPointData().setNormals(null)):i.getLines().initialize(),i.modified()}t.setBounds=function(){let n=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))n=arguments.length<=0?void 0:arguments[0];else for(let a=0;a<arguments.length;a++)n.push(a<0||arguments.length<=a?void 0:arguments[a]);n.length===6&&(t.setXLength(n[1]-n[0]),t.setYLength(n[3]-n[2]),t.setZLength(n[5]-n[4]),t.setCenter([(n[0]+n[1])/2,(n[2]+n[3])/2,(n[4]+n[5])/2]))},t.requestData=r}const mv={xLength:1,yLength:1,zLength:1,pointType:"Float64Array",generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function ff(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,mv,r),y.obj(t,e),y.setGet(t,e,["xLength","yLength","zLength","generate3DTextureCoordinates","generateFaces","generateLines"]),y.setGetArray(t,e,["center","rotations"],3),y.setGetArray(t,e,["matrix"],16),e._polys=vn.newInstance({values:Uint16Array.from(Mv)}),e._lineCells=vn.newInstance({values:Uint16Array.from(Rv)}),y.moveToProtected(t,e,["polys","lineCells"]),y.algo(t,e,0,1),Ov(t,e)}const Ev=y.newInstance(ff,"vtkCubeSource");var rs={newInstance:Ev,extend:ff};const{vtkErrorMacro:no}=y;function Dv(t,e){e.classHierarchy.push("vtkImageDataOutlineFilter");const r={...t};t.requestData=(n,a)=>{const i=n[0];if(!i||!i.isA("vtkImageData")){no("Invalid or missing input");return}const s=i.getSpatialExtent();if(!s){no("Unable to fetch spatial extents of input image.");return}e._cubeSource.setBounds(s),e._cubeSource.setMatrix(i.getIndexToWorld()),a[0]=e._cubeSource.getOutputData()},t.getMTime=()=>Math.max(r.getMTime(),e._cubeSource.getMTime()),t.setGenerateFaces=e._cubeSource.setGenerateFaces,t.setGenerateLines=e._cubeSource.setGenerateLines,t.getGenerateFaces=e._cubeSource.getGenerateFaces,t.getGenerateLines=e._cubeSource.getGenerateLines}const Vv={};function gf(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Vv,r),y.obj(t,e),y.algo(t,e,1,1),e._cubeSource=rs.newInstance(),y.moveToProtected(t,e,["cubeSource","tmpOut"]),Dv(t,e)}const Lv=y.newInstance(gf,"vtkImageDataOutlineFilter");var Fv={newInstance:Lv,extend:gf};let as;function kv(t,e){e.classHierarchy.push("vtkAbstractTransform","vtkHomogeneousTransform","vtkTransform"),t.transformPoint=(r,n)=>(q(n,r,e.matrix),n),t.transformPoints=(r,n)=>{const a=new Float64Array(3),i=new Float64Array(3);for(let s=0;s<r.length;s+=3)a[0]=r[s],a[1]=r[s+1],a[2]=r[s+2],q(i,a,e.matrix),n[s]=i[0],n[s+1]=i[1],n[s+2]=i[2];return n},t.preMultiply=()=>{t.setPreMultiplyFlag(!0)},t.postMultiply=()=>{t.setPreMultiplyFlag(!1)},t.transformMatrix=(r,n)=>(e.preMultiplyFlag?ae(n,e.matrix,r):ae(n,r,e.matrix),n),t.transformMatrices=(r,n)=>{const a=new Float64Array(16),i=new Float64Array(16),s=e.preMultiplyFlag?()=>ae(i,e.matrix,a):()=>ae(i,a,e.matrix);for(let o=0;o<r.length;o+=16){for(let c=0;c<16;++c)a[c]=r[o+c];s();for(let c=0;c<16;++c)n[o+c]=i[c]}return n},t.getInverse=()=>as({matrix:st.invertMatrix(Array.from(e.matrix),[],4),preMultiplyFlag:e.preMultiplyFlag})}const Nv={preMultiplyFlag:!1,matrix:[...Bi]};function lf(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Nv,r),y.obj(t,e),y.setGet(t,e,["preMultiplyFlag"]),y.setGetArray(t,e,["matrix"],16),kv(t,e)}as=y.newInstance(lf,"vtkTransform");var _v={newInstance:as,extend:lf};function Bt(t,e,r){return t?`${t.getMTime()}-${e}-${r}`:"0"}function is(t,e){return`${t.getMTime()}A${e.getMTime()}`}var Gv=`//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkImageResliceMapperVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

// all variables that represent positions or directions have a suffix
// indicating the coordinate system they are in. The possible values are
// MC - Model coordinates
// WC - World coordinates
// VC - View coordinates
// DC - Display coordinates
// TC - Texture coordinates

// frag position in VC
//VTK::PositionVC::Dec

// Texture coordinates
//VTK::TCoord::Dec

// picking support
//VTK::Picking::Dec

// camera and actor matrix values
//VTK::Camera::Dec

void main()
{
  //VTK::PositionVC::Impl

  //VTK::TCoord::Impl

  //VTK::Picking::Impl
}
`,Uv=`//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkImageResliceMapperFS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// Template for the gpu image mapper fragment shader

// VC position of this fragment
//VTK::PositionVC::Dec

// Texture coordinates
//VTK::TCoord::Dec

// picking support
//VTK::Picking::Dec

// handle coincident offsets
//VTK::Coincident::Dec

//VTK::ZBuffer::Dec

// the output of this shader
//VTK::Output::Dec

void main()
{
  // VC position of this fragment. This should not branch/return/discard.
  //VTK::PositionVC::Impl

  // Place any calls that require uniform flow (e.g. dFdx) here.
  //VTK::UniformFlow::Impl

  // Set gl_FragDepth here (gl_FragCoord.z by default)
  //VTK::Depth::Impl

  // Early depth peeling abort:
  //VTK::DepthPeeling::PreColor

  //VTK::TCoord::Impl

  if (gl_FragData[0].a <= 0.0)
    {
    discard;
    }

  //VTK::DepthPeeling::Impl

  //VTK::Picking::Impl

  // handle coincident offsets
  //VTK::Coincident::Impl

  //VTK::ZBuffer::Impl

  //VTK::RenderPassFragmentShader::Impl
}
`;const dn={NEAREST:0,LINEAR:1};var Bv={InterpolationType:dn};const{vtkErrorMacro:bt}=We;function ro(t,e,r){return e.identity(r),t.reduce((n,a,i)=>i===0?a?e.copy(n,a):e.identity(n):a?e.multiply(n,n,a):n,r)}function Wv(t,e){e.classHierarchy.push("vtkOpenGLImageResliceMapper");function r(a){[e._scalars,e._colorTransferFunc,e._pwFunc].forEach(i=>a.unregisterGraphicsResourceUser(i,t))}t.buildPass=a=>{if(a){e.currentRenderPass=null,e._openGLImageSlice=t.getFirstAncestorOfType("vtkOpenGLImageSlice"),e._openGLRenderer=t.getFirstAncestorOfType("vtkOpenGLRenderer");const i=e._openGLRenderer.getRenderable();e._openGLCamera=e._openGLRenderer.getViewNodeFor(i.getActiveCamera());const s=e._openGLRenderWindow;e._openGLRenderWindow=e._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),s&&!s.isDeleted()&&s!==e._openGLRenderWindow&&r(s),e.context=e._openGLRenderWindow.getContext(),e.tris.setOpenGLRenderWindow(e._openGLRenderWindow)}},t.translucentPass=(a,i)=>{a&&(e.currentRenderPass=i,t.render())},t.zBufferPass=a=>{a&&(e.haveSeenDepthRequest=!0,e.renderDepth=!0,t.render(),e.renderDepth=!1)},t.opaqueZBufferPass=a=>t.zBufferPass(a),t.opaquePass=a=>{a&&t.render()},t.getCoincidentParameters=(a,i)=>e.renderable.getResolveCoincidentTopology()==Ie.PolygonOffset?e.renderable.getCoincidentTopologyPolygonOffsetParameters():null,t.render=()=>{const a=e._openGLImageSlice.getRenderable(),i=e._openGLRenderer.getRenderable();t.renderPiece(i,a)},t.renderPiece=(a,i)=>{if(t.invokeEvent({type:"StartEvent"}),e.renderable.update(),e.currentInput=e.renderable.getInputData(),!e.currentInput){bt("No input!");return}t.updateResliceGeometry(),t.renderPieceStart(a,i),t.renderPieceDraw(a,i),t.renderPieceFinish(a,i),t.invokeEvent({type:"EndEvent"})},t.renderPieceStart=(a,i)=>{t.updateBufferObjects(a,i),i.getProperty().getInterpolationType()===dn.NEAREST?(e.openGLTexture.setMinificationFilter(j.NEAREST),e.openGLTexture.setMagnificationFilter(j.NEAREST),e.colorTexture.setMinificationFilter(j.NEAREST),e.colorTexture.setMagnificationFilter(j.NEAREST),e.pwfTexture.setMinificationFilter(j.NEAREST),e.pwfTexture.setMagnificationFilter(j.NEAREST)):(e.openGLTexture.setMinificationFilter(j.LINEAR),e.openGLTexture.setMagnificationFilter(j.LINEAR),e.colorTexture.setMinificationFilter(j.LINEAR),e.colorTexture.setMagnificationFilter(j.LINEAR),e.pwfTexture.setMinificationFilter(j.LINEAR),e.pwfTexture.setMagnificationFilter(j.LINEAR)),e.lastBoundBO=null},t.renderPieceDraw=(a,i)=>{const s=e.context;e.openGLTexture.activate(),e.colorTexture.activate(),e.pwfTexture.activate(),t.updateShaders(e.tris,a,i),s.drawArrays(s.TRIANGLES,0,e.tris.getCABO().getElementCount()),e.tris.getVAO().release(),e.openGLTexture.deactivate(),e.colorTexture.deactivate(),e.pwfTexture.deactivate()},t.renderPieceFinish=(a,i)=>{},t.updateBufferObjects=(a,i)=>{t.getNeedToRebuildBufferObjects(a,i)&&t.buildBufferObjects(a,i)},t.getNeedToRebuildBufferObjects=(a,i)=>{var s,o,c;return e.VBOBuildTime.getMTime()<t.getMTime()||e.VBOBuildTime.getMTime()<i.getMTime()||e.VBOBuildTime.getMTime()<e.renderable.getMTime()||e.VBOBuildTime.getMTime()<i.getProperty().getMTime()||e.VBOBuildTime.getMTime()<e.currentInput.getMTime()||e.VBOBuildTime.getMTime()<e.resliceGeom.getMTime()||!((s=e.openGLTexture)!=null&&s.getHandle())||!((o=e.colorTexture)!=null&&o.getHandle())||!((c=e.pwfTexture)!=null&&c.getHandle())},t.buildBufferObjects=(a,i)=>{var w,m,E,M;const s=e.currentInput;if(!s)return;const o=(w=s.getPointData())==null?void 0:w.getScalars();if(!o)return;const c=o.getNumberOfComponents();let u=is(s,o);const g=e._openGLRenderWindow.getGraphicsResourceForObject(o);if(!((m=g==null?void 0:g.oglObject)!=null&&m.getHandle())||(g==null?void 0:g.hash)!==u){e.openGLTexture=he.newInstance(),e.openGLTexture.setOpenGLRenderWindow(e._openGLRenderWindow);const D=s.getDimensions();e.openGLTexture.setOglNorm16Ext(e.context.getExtension("EXT_texture_norm16")),e.openGLTexture.resetFormatAndType(),e.openGLTexture.create3DFilterableFromDataArray(D[0],D[1],D[2],o),e._openGLRenderWindow.setGraphicsResourceForObject(o,e.openGLTexture,u),o!==e._scalars&&(e._openGLRenderWindow.registerGraphicsResourceUser(o,t),e._openGLRenderWindow.unregisterGraphicsResourceUser(e._scalars,t)),e._scalars=o}else e.openGLTexture=g.oglObject;const l=i.getProperty(),p=l.getIndependentComponents(),d=p?c:1,h=p?2*d:1,T=l.getRGBTransferFunction();u=Bt(T,p,d);const v=e._openGLRenderWindow.getGraphicsResourceForObject(T);if(!((E=v==null?void 0:v.oglObject)!=null&&E.getHandle())||(v==null?void 0:v.hash)!==u){const N=1024*h*3,G=new Uint8ClampedArray(N);if(e.colorTexture=he.newInstance(),e.colorTexture.setOpenGLRenderWindow(e._openGLRenderWindow),T){const _=new Float32Array(3072);for(let B=0;B<d;B++){const F=l.getRGBTransferFunction(B),z=F.getRange();if(F.getTable(z[0],z[1],1024,_,1),p)for(let U=0;U<1024*3;U++)G[B*1024*6+U]=255*_[U],G[B*1024*6+U+1024*3]=255*_[U];else for(let U=0;U<1024*3;U++)G[B*1024*6+U]=255*_[U]}e.colorTexture.resetFormatAndType(),e.colorTexture.create2DFromRaw(1024,h,3,J.UNSIGNED_CHAR,G)}else{for(let _=0;_<1024*3;++_)G[_]=255*_/((1024-1)*3),G[_+1]=255*_/((1024-1)*3),G[_+2]=255*_/((1024-1)*3);e.colorTexture.resetFormatAndType(),e.colorTexture.create2DFromRaw(1024,1,3,J.UNSIGNED_CHAR,G)}T&&(e._openGLRenderWindow.setGraphicsResourceForObject(T,e.colorTexture,u),T!==e._colorTransferFunc&&(e._openGLRenderWindow.registerGraphicsResourceUser(T,t),e._openGLRenderWindow.unregisterGraphicsResourceUser(e._colorTransferFunc,t)),e._colorTransferFunc=T)}else e.colorTexture=v.oglObject;const S=l.getPiecewiseFunction();u=Bt(S,p,d);const x=e._openGLRenderWindow.getGraphicsResourceForObject(S);if(!((M=x==null?void 0:x.oglObject)!=null&&M.getHandle())||(x==null?void 0:x.hash)!==u){const N=1024*h,G=new Uint8ClampedArray(N);if(e.pwfTexture=he.newInstance(),e.pwfTexture.setOpenGLRenderWindow(e._openGLRenderWindow),S){const _=new Float32Array(N),B=new Float32Array(1024);for(let F=0;F<d;++F){const z=l.getPiecewiseFunction(F);if(z===null)_.fill(1);else{const U=z.getRange();if(z.getTable(U[0],U[1],1024,B,1),p)for(let k=0;k<1024;k++)_[F*1024*2+k]=B[k],_[F*1024*2+k+1024]=B[k];else for(let k=0;k<1024;k++)_[F*1024*2+k]=B[k]}}e.pwfTexture.resetFormatAndType(),e.pwfTexture.create2DFromRaw(1024,h,1,J.FLOAT,_)}else G.fill(255),e.pwfTexture.resetFormatAndType(),e.pwfTexture.create2DFromRaw(1024,1,1,J.UNSIGNED_CHAR,G);S&&(e._openGLRenderWindow.setGraphicsResourceForObject(S,e.pwfTexture,u),S!==e._pwFunc&&(e._openGLRenderWindow.registerGraphicsResourceUser(S,t),e._openGLRenderWindow.unregisterGraphicsResourceUser(e._pwFunc,t)),e._pwFunc=S)}else e.pwfTexture=x.oglObject;const O=`${e.resliceGeom.getMTime()}A${e.renderable.getSlabThickness()}`;if(!e.tris.getCABO().getElementCount()||e.VBOBuildString!==O){const D=A.newInstance({numberOfComponents:3,values:e.resliceGeom.getPoints().getData()});D.setName("points");const N=A.newInstance({numberOfComponents:1,values:e.resliceGeom.getPolys().getData()}),G={points:D,cellOffset:0};if(e.renderable.getSlabThickness()>0){const _=e.resliceGeom.getPointData().getNormals();_?G.normals=_:bt("Slab mode requested without normals")}e.tris.getCABO().createVBO(N,"polys",me.SURFACE,G)}e.VBOBuildString=O,e.VBOBuildTime.modified()},t.updateShaders=(a,i,s)=>{if(e.lastBoundBO=a,t.getNeedToRebuildShaders(a,i,s)){const o={Vertex:null,Fragment:null,Geometry:null};t.buildShaders(o,i,s);const c=e._openGLRenderWindow.getShaderCache().readyShaderProgramArray(o.Vertex,o.Fragment,o.Geometry);c!==a.getProgram()&&(a.setProgram(c),a.getVAO().releaseGraphicsResources()),a.getShaderSourceTime().modified()}else e._openGLRenderWindow.getShaderCache().readyShaderProgram(a.getProgram());a.getVAO().bind(),t.setMapperShaderParameters(a,i,s),t.setCameraShaderParameters(a,i,s),t.setPropertyShaderParameters(a,i,s)},t.setMapperShaderParameters=(a,i,s)=>{const o=a.getProgram();if(a.getCABO().getElementCount()&&(e.VBOBuildTime.getMTime()>a.getAttributeUpdateTime().getMTime()||a.getShaderSourceTime().getMTime()>a.getAttributeUpdateTime().getMTime())){o.isUniformUsed("texture1")&&o.setUniformi("texture1",e.openGLTexture.getTextureUnit()),o.isAttributeUsed("vertexWC")&&(a.getVAO().addAttributeArray(o,a.getCABO(),"vertexWC",a.getCABO().getVertexOffset(),a.getCABO().getStride(),e.context.FLOAT,3,e.context.FALSE)||bt("Error setting vertexWC in shader VAO.")),o.isAttributeUsed("normalWC")&&(a.getVAO().addAttributeArray(o,a.getCABO(),"normalWC",a.getCABO().getNormalOffset(),a.getCABO().getStride(),e.context.FLOAT,3,e.context.FALSE)||bt("Error setting normalWC in shader VAO.")),o.isUniformUsed("slabThickness")&&o.setUniformf("slabThickness",e.renderable.getSlabThickness()),o.isUniformUsed("spacing")&&o.setUniform3fv("spacing",e.currentInput.getSpacing()),o.isUniformUsed("slabType")&&o.setUniformi("slabType",e.renderable.getSlabType()),o.isUniformUsed("slabType")&&o.setUniformi("slabType",e.renderable.getSlabType()),o.isUniformUsed("slabTrapezoid")&&o.setUniformi("slabTrapezoid",e.renderable.getSlabTrapezoidIntegration());const u=a.getCABO().getCoordShiftAndScaleEnabled()?a.getCABO().getInverseShiftAndScaleMatrix():null;if(o.isUniformUsed("WCTCMatrix")){const g=e.currentInput,f=g.getDimensions();Re(e.tmpMat4,g.getIndexToWorld()),ge(e.tmpMat4,e.tmpMat4,[-.5,-.5,-.5]),nn(e.tmpMat4,e.tmpMat4,f),je(e.tmpMat4,e.tmpMat4),u&&ae(e.tmpMat4,e.tmpMat4,u),o.setUniformMatrix("WCTCMatrix",e.tmpMat4)}o.isUniformUsed("vboScaling")&&o.setUniform3fv("vboScaling",a.getCABO().getCoordScale()??[1,1,1]),a.getAttributeUpdateTime().modified()}if(e.haveSeenDepthRequest&&a.getProgram().setUniformi("depthRequest",e.renderDepth?1:0),a.getProgram().isUniformUsed("coffset")){const c=t.getCoincidentParameters(i,s);a.getProgram().setUniformf("coffset",c.offset),a.getProgram().isUniformUsed("cfactor")&&a.getProgram().setUniformf("cfactor",c.factor)}},t.setCameraShaderParameters=(a,i,s)=>{const o=e._openGLCamera.getKeyMatrices(i),c=e._openGLImageSlice.getKeyMatrices(),g=a.getCABO().getCoordShiftAndScaleEnabled()?a.getCABO().getInverseShiftAndScaleMatrix():null,f=a.getProgram();f.isUniformUsed("MCPCMatrix")&&(X(e.tmpMat4),f.setUniformMatrix("MCPCMatrix",ro([o.wcpc,c.mcwc,g],Jn,e.tmpMat4))),f.isUniformUsed("MCVCMatrix")&&(X(e.tmpMat4),f.setUniformMatrix("MCVCMatrix",ro([o.wcvc,c.mcwc,g],Jn,e.tmpMat4)))},t.setPropertyShaderParameters=(a,i,s)=>{const o=a.getProgram(),c=s.getProperty(),u=c.getOpacity();o.setUniformf("opacity",u);const g=e.openGLTexture.getComponents(),f=c.getIndependentComponents();if(f)for(let h=0;h<g;++h)o.setUniformf(`mix${h}`,c.getComponentWeight(h));const l=e.openGLTexture.getVolumeInfo();for(let h=0;h<g;h++){let T=c.getColorWindow(),v=c.getColorLevel();const C=f?h:0,S=c.getRGBTransferFunction(C);if(S&&c.getUseLookupTableScalarRange()){const O=S.getRange();T=O[1]-O[0],v=.5*(O[1]+O[0])}const x=l.scale[h]/T,R=(l.offset[h]-v)/T+.5;o.setUniformf(`cshift${h}`,R),o.setUniformf(`cscale${h}`,x)}const p=e.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",p);for(let h=0;h<g;h++){let T=1,v=0;const C=f?h:0,S=c.getPiecewiseFunction(C);if(S){const x=S.getRange(),R=x[1]-x[0],O=.5*(x[0]+x[1]);T=l.scale[h]/R,v=(l.offset[h]-O)/R+.5}o.setUniformf(`pwfshift${h}`,v),o.setUniformf(`pwfscale${h}`,T)}const d=e.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d),o.setUniform4fv("backgroundColor",e.renderable.getBackgroundColor())},t.getNeedToRebuildShaders=(a,i,s)=>{var p;const o=e.openGLTexture.getComponents(),c=s.getProperty().getIndependentComponents(),u=e.renderable.getSlabThickness(),g=e.renderable.getSlabType(),f=e.renderable.getSlabTrapezoidIntegration();let l=!1;return(!e.currentRenderPass&&e.lastRenderPassShaderReplacement||e.currentRenderPass&&e.currentRenderPass.getShaderReplacement()!==e.lastRenderPassShaderReplacement)&&(l=!0),l||e.lastHaveSeenDepthRequest!==e.haveSeenDepthRequest||((p=a.getProgram())==null?void 0:p.getHandle())===0||e.lastTextureComponents!==o||e.lastIndependentComponents!==c||e.lastSlabThickness!==u||e.lastSlabType!==g||e.lastSlabTrapezoidIntegration!==f?(e.lastHaveSeenDepthRequest=e.haveSeenDepthRequest,e.lastTextureComponents=o,e.lastIndependentComponents=c,e.lastSlabThickness=u,e.lastSlabType=g,e.lastSlabTrapezoidIntegration=f,!0):!1},t.getShaderTemplate=(a,i,s)=>{a.Vertex=Gv,a.Fragment=Uv,a.Geometry=""},t.replaceShaderValues=(a,i,s)=>{if(t.replaceShaderTCoord(a,i,s),t.replaceShaderPositionVC(a,i,s),e.haveSeenDepthRequest){let o=a.Fragment;o=V.substitute(o,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,o=V.substitute(o,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,a.Fragment=o}t.replaceShaderCoincidentOffset(a,i,s)},t.replaceShaderTCoord=(a,i,s)=>{let o=a.Vertex;const c=a.Geometry;let u=a.Fragment;const g=["uniform mat4 WCTCMatrix;","out vec3 fragTexCoord;"],f=e.renderable.getSlabThickness();o=V.substitute(o,"//VTK::TCoord::Dec",g).result;const l=["fragTexCoord = (WCTCMatrix * vertexWC).xyz;"];o=V.substitute(o,"//VTK::TCoord::Impl",l).result;const p=e.openGLTexture.getComponents(),d=s.getProperty().getIndependentComponents();let h=["in vec3 fragTexCoord;","uniform highp sampler3D texture1;","uniform mat4 WCTCMatrix;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;"];if(d){for(let v=1;v<p;v++)h=h.concat([`uniform float cshift${v};`,`uniform float cscale${v};`,`uniform float pwfshift${v};`,`uniform float pwfscale${v};`]);switch(p){case 1:h=h.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:h=h.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:h=h.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:h=h.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:bt("Unsupported number of independent coordinates.")}}f>0&&(h=h.concat(["uniform vec3 spacing;","uniform float slabThickness;","uniform int slabType;","uniform int slabTrapezoid;","uniform vec3 vboScaling;"]),h=h.concat(["vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)","{","  vec4 retVal = vec4(1.0);","  if (slabType == 0) // min","  {","    retVal = min(currVal, valToComp);","  }","  else if (slabType == 1) // max","  {","    retVal = max(currVal, valToComp);","  }","  else if (slabType == 3) // sum","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  else // mean","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  return retVal;","}"])),u=V.substitute(u,"//VTK::TCoord::Dec",h).result;let T=["if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}","vec4 tvalue = texture(texture1, fragTexCoord);"];if(f>0&&(T=T.concat(["// Get the first and last samples","int numSlices = 1;","float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;","vec3 normalxspacing = scaling * normalWCVSOutput;","float distTraveled = length(normalxspacing);","int trapezoid = 0;","while (distTraveled < slabThickness * 0.5)","{","  distTraveled += length(normalxspacing);","  float fnumSlices = float(numSlices);","  if (distTraveled > slabThickness * 0.5)","  {","    // Before stepping outside the slab, sample at the boundaries","    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;","    trapezoid = slabTrapezoid;","  }","  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = texture(texture1, fragTCoordNeg);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = texture(texture1, fragTCoordPos);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","}","// Finally, if slab type is *mean*, divide the sum by the numSlices","if (slabType == 2)","{","  tvalue = tvalue / float(numSlices);","}"])),d){const v=["r","g","b","a"];for(let C=0;C<p;++C)T=T.concat([`vec3 tcolor${C} = mix${C} * texture2D(colorTexture1, vec2(tvalue.${v[C]} * cscale${C} + cshift${C}, height${C})).rgb;`,`float compWeight${C} = mix${C} * texture2D(pwfTexture1, vec2(tvalue.${v[C]} * pwfscale${C} + pwfshift${C}, height${C})).r;`]);switch(p){case 1:T=T.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:T=T.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:T=T.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:T=T.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:bt("Unsupported number of independent coordinates.")}}else switch(p){case 1:T=T.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:T=T.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:T=T.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:T=T.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}u=V.substitute(u,"//VTK::TCoord::Impl",T).result,a.Vertex=o,a.Fragment=u,a.Geometry=c},t.replaceShaderPositionVC=(a,i,s)=>{let o=a.Vertex;const c=a.Geometry;let u=a.Fragment;const g=e.renderable.getSlabThickness();let f=["attribute vec4 vertexWC;"];f=f.concat([`//${t.getMTime()}${e.resliceGeomUpdateString}`]),g>0&&(f=f.concat(["attribute vec3 normalWC;","varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),o=V.substitute(o,"//VTK::PositionVC::Dec",f).result;let l=["gl_Position = MCPCMatrix * vertexWC;"];g>0&&(l=l.concat(["normalWCVSOutput = normalWC;","vertexWCVSOutput = vertexWC;"])),o=V.substitute(o,"//VTK::PositionVC::Impl",l).result,o=V.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result;let p=[];g>0&&(p=p.concat(["varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),u=V.substitute(u,"//VTK::PositionVC::Dec",p).result,a.Vertex=o,a.Geometry=c,a.Fragment=u};function n(a){st.normalize(a);const i=[0,0,0];for(let s=0;s<3;++s){El(i),i[s]=1;const o=st.dot(a,i);if(o<-.999999||o>.999999)return[!0,s]}return[!1,2]}t.updateResliceGeometry=()=>{var f;let a="";const i=e.currentInput,s=i==null?void 0:i.getBounds();let o=!0,c=2;const u=e.renderable.getSlicePolyData(),g=e.renderable.getSlicePlane();if(u)a=a.concat(`PolyData${u.getMTime()}`);else if(g){a=a.concat(`Plane${g.getMTime()}`);const l=Ol();i&&(a=a.concat(`Image${i.getMTime()}`),ml(l,...i.getDirection()),nr(l,l));const p=[...g.getNormal()];bn(p,p,l),[o,c]=n(p)}else{const l=be.newInstance();l.setNormal(0,0,1);let p=[0,1,0,1,0,1];i&&(p=s),l.setOrigin(p[0],p[2],.5*(p[5]+p[4])),e.renderable.setSlicePlane(l),a=a.concat(`Plane${g==null?void 0:g.getMTime()}`),i&&(a=a.concat(`Image${i.getMTime()}`))}if(!e.resliceGeom||e.resliceGeomUpdateString!==a){if(u)e.resliceGeom||(e.resliceGeom=Be.newInstance()),e.resliceGeom.getPoints().setData(u.getPoints().getData(),3),e.resliceGeom.getPolys().setData(u.getPolys().getData(),1),e.resliceGeom.getPointData().setNormals(u.getPointData().getNormals());else if(g)if(o){const l=new Float32Array(12),p=i.worldToIndex(g.getOrigin(),[0,0,0]),d=[(c+1)%3,(c+2)%3].sort(),h=i.getSpatialExtent();let T=0;for(let R=0;R<2;++R)for(let O=0;O<2;++O)l[T+c]=p[c],l[T+d[0]]=h[2*d[0]+O],l[T+d[1]]=h[2*d[1]+R],T+=3;e.transform.setMatrix(i.getIndexToWorld()),e.transform.transformPoints(l,l);const v=new Uint16Array(8);v[0]=3,v[1]=0,v[2]=1,v[3]=3,v[4]=3,v[5]=0,v[6]=3,v[7]=2;const C=g.getNormal();st.normalize(C);const S=new Float32Array(12);for(let R=0;R<4;++R)S[3*R]=C[0],S[3*R+1]=C[1],S[3*R+2]=C[2];e.resliceGeom||(e.resliceGeom=Be.newInstance()),e.resliceGeom.getPoints().setData(l,3),e.resliceGeom.getPolys().setData(v,1);const x=A.newInstance({numberOfComponents:3,values:S,name:"Normals"});e.resliceGeom.getPointData().setNormals(x)}else{e.outlineFilter.setInputData(i),e.cutter.setInputConnection(e.outlineFilter.getOutputPort()),e.cutter.setCutFunction(g),e.lineToSurfaceFilter.setInputConnection(e.cutter.getOutputPort()),e.lineToSurfaceFilter.update(),e.resliceGeom||(e.resliceGeom=Be.newInstance());const l=e.lineToSurfaceFilter.getOutputData();e.resliceGeom.getPoints().setData(l.getPoints().getData(),3),e.resliceGeom.getPolys().setData(l.getPolys().getData(),1),e.resliceGeom.getPointData().setNormals(l.getPointData().getNormals());const p=g.getNormal(),d=e.resliceGeom.getNumberOfPoints();st.normalize(p);const h=new Float32Array(d*3);for(let v=0;v<d;++v)h[3*v]=p[0],h[3*v+1]=p[1],h[3*v+2]=p[2];const T=A.newInstance({numberOfComponents:3,values:h,name:"Normals"});e.resliceGeom.getPointData().setNormals(T)}else bt("Something went wrong.","A default slice plane should have been created in the beginning of","updateResliceGeometry.");e.resliceGeomUpdateString=a,(f=e.resliceGeom)==null||f.modified()}},t.setOpenGLTexture=a=>{a&&(e.openGLTexture=a,e._externalOpenGLTexture=!0)},t.delete=cr(()=>{e._openGLRenderWindow&&r(e._openGLRenderWindow)},t.delete)}const $v={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastTextureComponents:0,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,openGLTexture:null,colorTextureString:null,pwfTextureString:null,resliceGeom:null,resliceGeomUpdateString:null,tris:null,colorTexture:null,pwfTexture:null,_externalOpenGLTexture:!1};function zv(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,$v,r),De.extend(t,e,r),ut.implementReplaceShaderCoincidentOffset(t,e,r),ut.implementBuildShadersWithReplacements(t,e,r),e.tris=ft.newInstance(),e.openGLTexture=null,e.colorTexture=null,e.pwfTexture=null,e.VBOBuildTime={},xe(e.VBOBuildTime),e.tmpMat4=X(new Float64Array(16)),e.outlineFilter=Fv.newInstance(),e.outlineFilter.setGenerateFaces(!0),e.outlineFilter.setGenerateLines(!1),e.cubePolyData=Be.newInstance(),e.cutter=cf.newInstance(),e.lineToSurfaceFilter=dv.newInstance(),e.transform=_v.newInstance(),Ke(t,e,["openGLTexture"]),Wv(t,e)}const Hv=ye(zv,"vtkOpenGLImageResliceMapper");Oe("vtkImageResliceMapper",Hv);const jv={NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5};var ss={SlicingMode:jv};const{vtkErrorMacro:on}=We,{SlicingMode:_e}=ss;function bv(t){const e=t.split(`
`),r=[];for(let n=0;n<e.length;++n){const a=e[n].trim();a.length>0&&r.push(a)}return r}function Kv(t,e){e.classHierarchy.push("vtkOpenGLImageMapper");function r(n){e.openGLTexture.releaseGraphicsResources(n),[e._colorTransferFunc,e._pwFunc,e._labelOutlineThicknessArray].forEach(a=>n.unregisterGraphicsResourceUser(a,t))}t.buildPass=n=>{if(n){e.currentRenderPass=null,e.openGLImageSlice=t.getFirstAncestorOfType("vtkOpenGLImageSlice"),e._openGLRenderer=t.getFirstAncestorOfType("vtkOpenGLRenderer");const a=e._openGLRenderWindow;e._openGLRenderWindow=e._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),a&&!a.isDeleted()&&a!==e._openGLRenderWindow&&r(a),e.context=e._openGLRenderWindow.getContext(),e.tris.setOpenGLRenderWindow(e._openGLRenderWindow);const i=e._openGLRenderer.getRenderable();e.openGLCamera=e._openGLRenderer.getViewNodeFor(i.getActiveCamera()),e.renderable.isA("vtkImageMapper")&&e.renderable.getSliceAtFocalPoint()&&e.renderable.setSliceFromCamera(i.getActiveCamera())}},t.translucentPass=(n,a)=>{n&&(e.currentRenderPass=a,t.render())},t.zBufferPass=n=>{n&&(e.haveSeenDepthRequest=!0,e.renderDepth=!0,t.render(),e.renderDepth=!1)},t.opaqueZBufferPass=n=>t.zBufferPass(n),t.opaquePass=n=>{n&&t.render()},t.getCoincidentParameters=(n,a)=>e.renderable.getResolveCoincidentTopology()==Ie.PolygonOffset?e.renderable.getCoincidentTopologyPolygonOffsetParameters():null,t.render=()=>{const n=e.openGLImageSlice.getRenderable(),a=e._openGLRenderer.getRenderable();t.renderPiece(a,n)},t.getShaderTemplate=(n,a,i)=>{n.Vertex=es,n.Fragment=ts,n.Geometry=""},t.replaceShaderValues=(n,a,i)=>{let s=n.Vertex,o=n.Fragment;s=V.substitute(s,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,s=V.substitute(s,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result,s=V.substitute(s,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result,s=V.substitute(s,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;const c=e.openGLTexture.getComponents(),u=i.getProperty().getIndependentComponents();let g=["varying vec2 tcoordVCVSOutput;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D texture1;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform sampler2D labelOutlineTexture1;","uniform float opacity;","uniform float outlineOpacity;"];if(u){for(let l=1;l<c;l++)g=g.concat([`uniform float cshift${l};`,`uniform float cscale${l};`,`uniform float pwfshift${l};`,`uniform float pwfscale${l};`]);switch(c){case 1:g=g.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:g=g.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:on("Unsupported number of independent coordinates.")}}if(o=V.substitute(o,"//VTK::TCoord::Dec",g).result,i.getProperty().getUseLabelOutline()===!0&&(o=V.substitute(o,"//VTK::LabelOutline::Dec",["uniform int outlineThickness;","uniform float vpWidth;","uniform float vpHeight;","uniform float vpOffsetX;","uniform float vpOffsetY;","uniform mat4 PCWCMatrix;","uniform mat4 vWCtoIDX;","uniform ivec3 imageDimensions;","uniform int sliceAxis;"]).result,o=V.substitute(o,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result,o=V.substitute(o,"//VTK::LabelOutlineHelperFunction",["#ifdef vtkImageLabelOutlineOn","vec3 fragCoordToIndexSpace(vec4 fragCoord) {","  vec4 pcPos = vec4(","    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,","    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,","    (fragCoord.z - 0.5) * 2.0,","    1.0);","","  vec4 worldCoord = PCWCMatrix * pcPos;","  vec4 vertex = (worldCoord/worldCoord.w);","","  vec3 index = (vWCtoIDX * vertex).xyz;","","  // half voxel fix for labelmapOutline","  return (index + vec3(0.5)) / vec3(imageDimensions);","}","vec2 getSliceCoords(vec3 coord, int axis) {","  if (axis == 0) return coord.yz;","  if (axis == 1) return coord.xz;","  if (axis == 2) return coord.xy;","}","#endif"]).result),u){const l=["r","g","b","a"];let p=["vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"];for(let d=0;d<c;d++)p=p.concat([`vec3 tcolor${d} = mix${d} * texture2D(colorTexture1, vec2(tvalue.${l[d]} * cscale${d} + cshift${d}, height${d})).rgb;`,`float compWeight${d} = mix${d} * texture2D(pwfTexture1, vec2(tvalue.${l[d]} * pwfscale${d} + pwfshift${d}, height${d})).r;`]);switch(c){case 1:p=p.concat(["gl_FragData[0] = vec4(tcolor0.rgb, opacity);"]);break;case 2:p=p.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:p=p.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:p=p.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:on("Unsupported number of independent coordinates.")}o=V.substitute(o,"//VTK::TCoord::Impl",p).result}else switch(c){case 1:o=V.substitute(o,"//VTK::TCoord::Impl",[...bv(`
                #ifdef vtkImageLabelOutlineOn
                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord);
                  float centerValue = texture2D(texture1, getSliceCoords(centerPosIS, sliceAxis)).r;
                  bool pixelOnBorder = false;
                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;
                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;
                  float opacityToUse = scalarOpacity * opacity;
                  int segmentIndex = int(centerValue * 255.0);
                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;
                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;
                  int actualThickness = int(textureValue * 255.0);

                  if (segmentIndex == 0){
                    gl_FragData[0] = vec4(0.0, 0.0, 0.0, 0.0);
                    return;
                  }

                  for (int i = -actualThickness; i <= actualThickness; i++) {
                    for (int j = -actualThickness; j <= actualThickness; j++) {
                      if (i == 0 || j == 0) {
                        continue;
                      }
                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),
                        gl_FragCoord.y + float(j),
                        gl_FragCoord.z, gl_FragCoord.w);
                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);
                      float value = texture2D(texture1, getSliceCoords(neighborPosIS, sliceAxis)).r;
                      if (value != centerValue) {
                        pixelOnBorder = true;
                        break;
                      }
                    }
                    if (pixelOnBorder == true) {
                      break;
                    }
                  }
                  if (pixelOnBorder == true) {
                    gl_FragData[0] = vec4(tColor, outlineOpacity);
                  }
                  else {
                    gl_FragData[0] = vec4(tColor, opacityToUse);
                  }
                #else
                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;
                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;
                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;
                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);
                #endif
                `)]).result;break;case 2:o=V.substitute(o,"//VTK::TCoord::Impl",["vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","float intensity = tcolor.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"]).result;break;case 3:o=V.substitute(o,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]).result;break;default:o=V.substitute(o,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]).result}e.haveSeenDepthRequest&&(o=V.substitute(o,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,o=V.substitute(o,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=s,n.Fragment=o,t.replaceShaderClip(n,a,i),t.replaceShaderCoincidentOffset(n,a,i)},t.replaceShaderClip=(n,a,i)=>{let s=n.Vertex,o=n.Fragment;if(e.renderable.getNumberOfClippingPlanes()){let c=e.renderable.getNumberOfClippingPlanes();c>6&&(ne("OpenGL has a limit of 6 clipping planes"),c=6),s=V.substitute(s,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,s=V.substitute(s,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,o=V.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,o=V.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}n.Vertex=s,n.Fragment=o},t.getNeedToRebuildShaders=(n,a,i)=>{var u;const s=e.openGLTexture.getComponents(),o=i.getProperty().getIndependentComponents();let c=!1;return(!e.currentRenderPass&&e.lastRenderPassShaderReplacement||e.currentRenderPass&&e.currentRenderPass.getShaderReplacement()!==e.lastRenderPassShaderReplacement)&&(c=!0),c||e.lastHaveSeenDepthRequest!==e.haveSeenDepthRequest||((u=n.getProgram())==null?void 0:u.getHandle())===0||e.lastTextureComponents!==s||e.lastIndependentComponents!==o?(e.lastHaveSeenDepthRequest=e.haveSeenDepthRequest,e.lastTextureComponents=s,e.lastIndependentComponents=o,!0):!1},t.updateShaders=(n,a,i)=>{if(e.lastBoundBO=n,t.getNeedToRebuildShaders(n,a,i)){const s={Vertex:null,Fragment:null,Geometry:null};t.buildShaders(s,a,i);const o=e._openGLRenderWindow.getShaderCache().readyShaderProgramArray(s.Vertex,s.Fragment,s.Geometry);o!==n.getProgram()&&(n.setProgram(o),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else e._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),t.setMapperShaderParameters(n,a,i),t.setCameraShaderParameters(n,a,i),t.setPropertyShaderParameters(n,a,i)},t.setMapperShaderParameters=(n,a,i)=>{n.getCABO().getElementCount()&&(e.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),e.context.FLOAT,3,e.context.FALSE)||on("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),e.context.FLOAT,n.getCABO().getTCoordComponents(),e.context.FALSE)||on("Error setting tcoordMC in shader VAO.")),n.getAttributeUpdateTime().modified());const s=e.openGLTexture.getTextureUnit();n.getProgram().setUniformi("texture1",s);const o=e.openGLTexture.getComponents(),c=i.getProperty().getIndependentComponents();if(c)for(let d=0;d<o;d++)n.getProgram().setUniformf(`mix${d}`,i.getProperty().getComponentWeight(d));const u=e.openGLTexture.getShiftAndScale();for(let d=0;d<o;d++){let h=i.getProperty().getColorWindow(),T=i.getProperty().getColorLevel();const v=c?d:0,C=i.getProperty().getRGBTransferFunction(v);if(C&&i.getProperty().getUseLookupTableScalarRange()){const R=C.getRange();h=R[1]-R[0],T=.5*(R[1]+R[0])}const S=u.scale/h,x=(u.shift-T)/h+.5;n.getProgram().setUniformf(`cshift${d}`,x),n.getProgram().setUniformf(`cscale${d}`,S)}for(let d=0;d<o;d++){let h=1,T=0;const v=c?d:0,C=i.getProperty().getPiecewiseFunction(v);if(C){const S=C.getRange(),x=S[1]-S[0],R=.5*(S[0]+S[1]);h=u.scale/x,T=(u.shift-R)/x+.5}n.getProgram().setUniformf(`pwfshift${d}`,T),n.getProgram().setUniformf(`pwfscale${d}`,h)}if(e.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",e.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const d=t.getCoincidentParameters(a,i);n.getProgram().setUniformf("coffset",d.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",d.factor)}const g=e.colorTexture.getTextureUnit();n.getProgram().setUniformi("colorTexture1",g);const f=e.pwfTexture.getTextureUnit();n.getProgram().setUniformi("pwfTexture1",f);const l=e.labelOutlineThicknessTexture.getTextureUnit();if(n.getProgram().setUniformi("labelOutlineTexture1",l),e.renderable.getNumberOfClippingPlanes()){let d=e.renderable.getNumberOfClippingPlanes();d>6&&(ne("OpenGL has a limit of 6 clipping planes"),d=6);const T=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,v=T?Re(e.imagematinv,i.getMatrix()):i.getMatrix();T&&(se(v,v),ae(v,v,T),se(v,v)),se(e.imagemat,e.currentInput.getIndexToWorld()),ae(e.imagematinv,v,e.imagemat);const C=[];for(let S=0;S<d;S++){const x=[];e.renderable.getClippingPlaneInDataCoords(e.imagematinv,S,x);for(let R=0;R<4;R++)C.push(x[R])}n.getProgram().setUniformi("numClipPlanes",d),n.getProgram().setUniform4fv("clipPlanes",C)}if(i.getProperty().getUseLabelOutline()===!0){const d=i.getProperty().getLabelOutlineOpacity();n.getProgram().setUniformf("outlineOpacity",d)}},t.setCameraShaderParameters=(n,a,i)=>{const s=n.getProgram(),o=e.openGLImageSlice.getKeyMatrices(),c=e.currentInput,u=c.getIndexToWorld();ae(e.imagemat,o.mcwc,u);const g=e.openGLCamera.getKeyMatrices(a);if(ae(e.imagemat,g.wcpc,e.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const l=n.getCABO().getInverseShiftAndScaleMatrix();ae(e.imagemat,e.imagemat,l)}if(s.setUniformMatrix("MCPCMatrix",e.imagemat),i.getProperty().getUseLabelOutline()===!0){const l=c.getWorldToIndex(),p=c.getDimensions();let d=e.renderable.getClosestIJKAxis().ijkMode;d===_e.NONE&&(d=_e.K),s.setUniform3i("imageDimensions",p[0],p[1],p[2]),s.setUniformi("sliceAxis",d),s.setUniformMatrix("vWCtoIDX",l);const h=e.openGLCamera.getKeyMatrices(a);je(e.projectionToWorld,h.wcpc),e.openGLCamera.getKeyMatrices(a),s.setUniformMatrix("PCWCMatrix",e.projectionToWorld);const T=t.getRenderTargetSize();s.setUniformf("vpWidth",T[0]),s.setUniformf("vpHeight",T[1]);const v=t.getRenderTargetOffset();s.setUniformf("vpOffsetX",v[0]/T[0]),s.setUniformf("vpOffsetY",v[1]/T[1])}},t.setPropertyShaderParameters=(n,a,i)=>{const s=n.getProgram(),c=i.getProperty().getOpacity();s.setUniformf("opacity",c)},t.renderPieceStart=(n,a)=>{t.updateBufferObjects(n,a),e.lastBoundBO=null},t.renderPieceDraw=(n,a)=>{const i=e.context;e.openGLTexture.activate(),e.colorTexture.activate(),e.labelOutlineThicknessTexture.activate(),e.pwfTexture.activate(),e.tris.getCABO().getElementCount()&&(t.updateShaders(e.tris,n,a),i.drawArrays(i.TRIANGLES,0,e.tris.getCABO().getElementCount()),e.tris.getVAO().release()),e.openGLTexture.deactivate(),e.colorTexture.deactivate(),e.labelOutlineThicknessTexture.deactivate(),e.pwfTexture.deactivate()},t.renderPieceFinish=(n,a)=>{},t.renderPiece=(n,a)=>{if(t.invokeEvent({type:"StartEvent"}),e.renderable.update(),e.currentInput=e.renderable.getCurrentImage(),t.invokeEvent({type:"EndEvent"}),!e.currentInput){on("No input!");return}t.renderPieceStart(n,a),t.renderPieceDraw(n,a),t.renderPieceFinish(n,a)},t.computeBounds=(n,a)=>{if(!t.getInput()){xn(e.bounds);return}e.bounds=t.getInput().getBounds()},t.updateBufferObjects=(n,a)=>{t.getNeedToRebuildBufferObjects(n,a)&&t.buildBufferObjects(n,a)},t.getNeedToRebuildBufferObjects=(n,a)=>{var i,s,o,c;return e.VBOBuildTime.getMTime()<t.getMTime()||e.VBOBuildTime.getMTime()<a.getMTime()||e.VBOBuildTime.getMTime()<e.renderable.getMTime()||e.VBOBuildTime.getMTime()<a.getProperty().getMTime()||e.VBOBuildTime.getMTime()<e.currentInput.getMTime()||!((i=e.openGLTexture)!=null&&i.getHandle())||!((s=e.colorTexture)!=null&&s.getHandle())||!((o=e.labelOutlineThicknessTexture)!=null&&o.getHandle())||!((c=e.pwfTexture)!=null&&c.getHandle())},t.buildBufferObjects=(n,a)=>{var N,G,_,B;const i=e.currentInput;if(!i)return;const s=i.getPointData()&&i.getPointData().getScalars();if(!s)return;const o=s.getDataType(),c=s.getNumberOfComponents(),u=a.getProperty(),g=u.getInterpolationType(),f=u.getIndependentComponents(),l=f?c:1,p=f?2*l:1,d=u.getRGBTransferFunction(),h=Bt(d,f,l),T=e._openGLRenderWindow.getGraphicsResourceForObject(d);if(!((N=T==null?void 0:T.oglObject)!=null&&N.getHandle())||(T==null?void 0:T.hash)!==h){e.colorTexture=he.newInstance({resizable:!0}),e.colorTexture.setOpenGLRenderWindow(e._openGLRenderWindow);const F=1024,z=F*p*3,U=new Uint8ClampedArray(z);if(g===dn.NEAREST?(e.colorTexture.setMinificationFilter(j.NEAREST),e.colorTexture.setMagnificationFilter(j.NEAREST)):(e.colorTexture.setMinificationFilter(j.LINEAR),e.colorTexture.setMagnificationFilter(j.LINEAR)),d){const k=new Float32Array(F*3);for(let L=0;L<l;L++){const W=u.getRGBTransferFunction(L),H=W.getRange();if(W.getTable(H[0],H[1],F,k,1),f)for(let $=0;$<F*3;$++)U[L*F*6+$]=255*k[$],U[L*F*6+$+F*3]=255*k[$];else for(let $=0;$<F*3;$++)U[L*F*6+$]=255*k[$]}e.colorTexture.resetFormatAndType(),e.colorTexture.create2DFromRaw(F,p,3,J.UNSIGNED_CHAR,U)}else{for(let k=0;k<F*3;++k)U[k]=255*k/((F-1)*3),U[k+1]=255*k/((F-1)*3),U[k+2]=255*k/((F-1)*3);e.colorTexture.create2DFromRaw(F,1,3,J.UNSIGNED_CHAR,U)}d&&(e._openGLRenderWindow.setGraphicsResourceForObject(d,e.colorTexture,h),d!==e._colorTransferFunc&&(e._openGLRenderWindow.registerGraphicsResourceUser(d,t),e._openGLRenderWindow.unregisterGraphicsResourceUser(e._colorTransferFunc,t)),e._colorTransferFunc=d)}else e.colorTexture=T.oglObject;const C=u.getPiecewiseFunction(),S=Bt(C,f,l),x=e._openGLRenderWindow.getGraphicsResourceForObject(C);if(!((G=x==null?void 0:x.oglObject)!=null&&G.getHandle())||(x==null?void 0:x.hash)!==S){const z=1024*p,U=new Uint8ClampedArray(z);if(e.pwfTexture=he.newInstance({resizable:!0}),e.pwfTexture.setOpenGLRenderWindow(e._openGLRenderWindow),g===dn.NEAREST?(e.pwfTexture.setMinificationFilter(j.NEAREST),e.pwfTexture.setMagnificationFilter(j.NEAREST)):(e.pwfTexture.setMinificationFilter(j.LINEAR),e.pwfTexture.setMagnificationFilter(j.LINEAR)),C){const k=new Float32Array(z),L=new Float32Array(1024);for(let W=0;W<l;++W){const H=u.getPiecewiseFunction(W);if(H===null)k.fill(1);else{const $=H.getRange();if(H.getTable($[0],$[1],1024,L,1),f)for(let Q=0;Q<1024;Q++)k[W*1024*2+Q]=L[Q],k[W*1024*2+Q+1024]=L[Q];else for(let Q=0;Q<1024;Q++)k[W*1024*2+Q]=L[Q]}}e.pwfTexture.resetFormatAndType(),e.pwfTexture.create2DFromRaw(1024,p,1,J.FLOAT,k)}else U.fill(255),e.pwfTexture.create2DFromRaw(1024,1,1,J.UNSIGNED_CHAR,U);C&&(e._openGLRenderWindow.setGraphicsResourceForObject(C,e.pwfTexture,S),C!==e._pwFunc&&(e._openGLRenderWindow.registerGraphicsResourceUser(C,t),e._openGLRenderWindow.unregisterGraphicsResourceUser(e._pwFunc,t)),e._pwFunc=C)}else e.pwfTexture=x.oglObject;t.updatelabelOutlineThicknessTexture(a);const{ijkMode:O}=e.renderable.getClosestIJKAxis();let w=e.renderable.getSlice();O!==e.renderable.getSlicingMode()&&(w=e.renderable.getSliceAtPosition(w));const m=e.renderable.isA("vtkImageArrayMapper")?e.renderable.getSubSlice():Math.round(w),E=i.getExtent();let M;O===_e.I&&(M=m-E[0]),O===_e.J&&(M=m-E[2]),(O===_e.K||O===_e.NONE)&&(M=m-E[4]);const D=`${w}A${i.getMTime()}A${s.getMTime()}B${t.getMTime()}C${e.renderable.getSlicingMode()}D${a.getProperty().getInterpolationType()}`;if(e.VBOBuildString!==D){const F=i.getDimensions();e.openGLTexture||(e.openGLTexture=he.newInstance({resizable:!0})),e.openGLTexture.setOpenGLRenderWindow(e._openGLRenderWindow),e.openGLTexture.setOglNorm16Ext(e.context.getExtension("EXT_texture_norm16")),g===dn.NEAREST?(new Set([1,3,4]).has(c)&&o===J.UNSIGNED_CHAR&&!f&&e.openGLTexture.setGenerateMipmap(!0),e.openGLTexture.setMinificationFilter(j.NEAREST),e.openGLTexture.setMagnificationFilter(j.NEAREST)):(c===4&&o===J.UNSIGNED_CHAR&&!f?(e.openGLTexture.setGenerateMipmap(!0),e.openGLTexture.setMinificationFilter(j.LINEAR_MIPMAP_LINEAR)):e.openGLTexture.setMinificationFilter(j.LINEAR),e.openGLTexture.setMagnificationFilter(j.LINEAR)),e.openGLTexture.setWrapS(In.CLAMP_TO_EDGE),e.openGLTexture.setWrapT(In.CLAMP_TO_EDGE);const z=F[0]*F[1]*c,U=new Float32Array(12),k=new Float32Array(8);for(let Ne=0;Ne<4;Ne++)k[Ne*2]=Ne%2?1:0,k[Ne*2+1]=Ne>1?1:0;const L=[_e.X,_e.Y,_e.Z].includes(e.renderable.getSlicingMode())?w:m,W=i.getSpatialExtent(),H=s.getData();let $=null;if(O===_e.I){$=new H.constructor(F[2]*F[1]*c);let Ne=0;for(let $e=0;$e<F[2];$e++)for(let ie=0;ie<F[1];ie++){let te=(M+ie*F[0]+$e*F[0]*F[1])*c;Ne=($e*F[1]+ie)*c;const ze=te+c;for(;te<ze;)$[Ne++]=H[te++]}F[0]=F[1],F[1]=F[2],U[0]=L,U[1]=W[2],U[2]=W[4],U[3]=L,U[4]=W[3],U[5]=W[4],U[6]=L,U[7]=W[2],U[8]=W[5],U[9]=L,U[10]=W[3],U[11]=W[5]}else if(O===_e.J){$=new H.constructor(F[2]*F[0]*c);let Ne=0;for(let $e=0;$e<F[2];$e++)for(let ie=0;ie<F[0];ie++){let te=(ie+M*F[0]+$e*F[0]*F[1])*c;Ne=($e*F[0]+ie)*c;const ze=te+c;for(;te<ze;)$[Ne++]=H[te++]}F[1]=F[2],U[0]=W[0],U[1]=L,U[2]=W[4],U[3]=W[1],U[4]=L,U[5]=W[4],U[6]=W[0],U[7]=L,U[8]=W[5],U[9]=W[1],U[10]=L,U[11]=W[5]}else O===_e.K||O===_e.NONE?($=H.subarray(M*z,(M+1)*z),U[0]=W[0],U[1]=W[2],U[2]=L,U[3]=W[1],U[4]=W[2],U[5]=L,U[6]=W[0],U[7]=W[3],U[8]=L,U[9]=W[1],U[10]=W[3],U[11]=L):on("Reformat slicing not yet supported.");e.openGLTexture.resetFormatAndType(),e.openGLTexture.create2DFilterableFromRaw(F[0],F[1],c,s.getDataType(),$,(B=(_=e.renderable).getPreferSizeOverAccuracy)==null?void 0:B.call(_)),e.openGLTexture.activate(),e.openGLTexture.sendParameters(),e.openGLTexture.deactivate();const Q=A.newInstance({numberOfComponents:3,values:U});Q.setName("points");const Mt=A.newInstance({numberOfComponents:2,values:k});Mt.setName("tcoords");const Ve=new Uint16Array(8);Ve[0]=3,Ve[1]=0,Ve[2]=1,Ve[3]=3,Ve[4]=3,Ve[5]=0,Ve[6]=3,Ve[7]=2;const et=A.newInstance({numberOfComponents:1,values:Ve});e.tris.getCABO().createVBO(et,"polys",me.SURFACE,{points:Q,tcoords:Mt,cellOffset:0}),e.VBOBuildTime.modified(),e.VBOBuildString=D}},t.updatelabelOutlineThicknessTexture=n=>{var c;const a=n.getProperty().getLabelOutlineThicknessByReference(),i=e._openGLRenderWindow.getGraphicsResourceForObject(a),s=`${a.join("-")}`;if(!((c=i==null?void 0:i.oglObject)!=null&&c.getHandle())||(i==null?void 0:i.hash)!==s){const l=new Uint8Array(1024);for(let p=0;p<1024;++p){const d=typeof a[p]<"u"?a[p]:a[0];l[p]=d}e.labelOutlineThicknessTexture=he.newInstance({resizable:!1}),e.labelOutlineThicknessTexture.setOpenGLRenderWindow(e._openGLRenderWindow),e.labelOutlineThicknessTexture.resetFormatAndType(),e.labelOutlineThicknessTexture.setMinificationFilter(j.NEAREST),e.labelOutlineThicknessTexture.setMagnificationFilter(j.NEAREST),e.labelOutlineThicknessTexture.create2DFromRaw(1024,1,1,J.UNSIGNED_CHAR,l),a&&(e._openGLRenderWindow.setGraphicsResourceForObject(a,e.labelOutlineThicknessTexture,s),a!==e._labelOutlineThicknessArray&&(e._openGLRenderWindow.registerGraphicsResourceUser(a,t),e._openGLRenderWindow.unregisterGraphicsResourceUser(e._labelOutlineThicknessArray,t)),e._labelOutlineThicknessArray=a)}else e.labelOutlineThicknessTexture=i.oglObject},t.getRenderTargetSize=()=>{if(e._useSmallViewport)return[e._smallViewportWidth,e._smallViewportHeight];const{usize:n,vsize:a}=e._openGLRenderer.getTiledSizeAndOrigin();return[n,a]},t.getRenderTargetOffset=()=>{const{lowerLeftU:n,lowerLeftV:a}=e._openGLRenderer.getTiledSizeAndOrigin();return[n,a]},t.delete=cr(()=>{e._openGLRenderWindow&&r(e._openGLRenderWindow)},t.delete)}const Xv={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0};function Av(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Xv,r),De.extend(t,e,r),ut.implementReplaceShaderCoincidentOffset(t,e,r),ut.implementBuildShadersWithReplacements(t,e,r),e.tris=ft.newInstance(),e.imagemat=X(new Float64Array(16)),e.imagematinv=X(new Float64Array(16)),e.projectionToWorld=X(new Float64Array(16)),e.idxToView=X(new Float64Array(16)),e.idxNormalMatrix=ct(new Float64Array(9)),e.modelToView=X(new Float64Array(16)),e.projectionToView=X(new Float64Array(16)),Me(t,e,[]),e.VBOBuildTime={},xe(e.VBOBuildTime),Kv(t,e)}const Yv=ye(Av,"vtkOpenGLImageMapper");Oe("vtkAbstractImageMapper",Yv);const Kt={MAX:0,MIN:1,AVERAGE:2},{vtkErrorMacro:mr}=y;function qv(t,e){e.classHierarchy.push("vtkOpenGLImageCPRMapper");function r(n){[e._scalars,e._colorTransferFunc,e._pwFunc].forEach(a=>n.unregisterGraphicsResourceUser(a,t))}t.buildPass=n=>{if(n){e.currentRenderPass=null,e.openGLImageSlice=t.getFirstAncestorOfType("vtkOpenGLImageSlice"),e._openGLRenderer=t.getFirstAncestorOfType("vtkOpenGLRenderer");const a=e._openGLRenderWindow;e._openGLRenderWindow=e._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),a&&!a.isDeleted()&&a!==e._openGLRenderWindow&&r(a),e.context=e._openGLRenderWindow.getContext(),e.openGLCamera=e._openGLRenderer.getViewNodeFor(e._openGLRenderer.getRenderable().getActiveCamera()),e.tris.setOpenGLRenderWindow(e._openGLRenderWindow)}},t.opaquePass=(n,a)=>{n&&(e.currentRenderPass=a,t.render())},t.opaqueZBufferPass=n=>{n&&(e.haveSeenDepthRequest=!0,e.renderDepth=!0,t.render(),e.renderDepth=!1)},t.getCoincidentParameters=(n,a)=>e.renderable.getResolveCoincidentTopology()===Ie.PolygonOffset?e.renderable.getCoincidentTopologyPolygonOffsetParameters():null,t.render=()=>{const n=e.openGLImageSlice.getRenderable(),a=e._openGLRenderer.getRenderable();t.renderPiece(a,n)},t.renderPiece=(n,a)=>{t.invokeEvent({type:"StartEvent"}),e.renderable.update(),t.invokeEvent({type:"EndEvent"}),e.renderable.preRenderCheck()&&(e.currentImageDataInput=e.renderable.getInputData(0),e.currentCenterlineInput=e.renderable.getOrientedCenterline(),t.renderPieceStart(n,a),t.renderPieceDraw(n,a),t.renderPieceFinish(n,a))},t.renderPieceStart=(n,a)=>{t.updateBufferObjects(n,a)},t.renderPieceDraw=(n,a)=>{const i=e.context;e.volumeTexture.activate(),e.colorTexture.activate(),e.pwfTexture.activate(),e.tris.getCABO().getElementCount()&&(t.updateShaders(e.tris,n,a),i.drawArrays(i.TRIANGLES,0,e.tris.getCABO().getElementCount()),e.tris.getVAO().release()),e.volumeTexture.deactivate(),e.colorTexture.deactivate(),e.pwfTexture.deactivate()},t.renderPieceFinish=(n,a)=>{},t.updateBufferObjects=(n,a)=>{t.getNeedToRebuildBufferObjects(n,a)&&t.buildBufferObjects(n,a),a.getProperty().getInterpolationType()===dn.NEAREST?(e.volumeTexture.setMinificationFilter(j.NEAREST),e.volumeTexture.setMagnificationFilter(j.NEAREST),e.colorTexture.setMinificationFilter(j.NEAREST),e.colorTexture.setMagnificationFilter(j.NEAREST),e.pwfTexture.setMinificationFilter(j.NEAREST),e.pwfTexture.setMagnificationFilter(j.NEAREST)):(e.volumeTexture.setMinificationFilter(j.LINEAR),e.volumeTexture.setMagnificationFilter(j.LINEAR),e.colorTexture.setMinificationFilter(j.LINEAR),e.colorTexture.setMagnificationFilter(j.LINEAR),e.pwfTexture.setMinificationFilter(j.LINEAR),e.pwfTexture.setMagnificationFilter(j.LINEAR))},t.getNeedToRebuildBufferObjects=(n,a)=>{var s;const i=e.VBOBuildTime.getMTime();return i<t.getMTime()||i<e.renderable.getMTime()||i<a.getMTime()||i<e.currentImageDataInput.getMTime()||i<e.currentCenterlineInput.getMTime()||!((s=e.volumeTexture)!=null&&s.getHandle())},t.buildBufferObjects=(n,a)=>{var m,E,M,D;const i=e.currentImageDataInput,s=e.currentCenterlineInput,o=(m=i==null?void 0:i.getPointData())==null?void 0:m.getScalars();if(!o)return;const c=e._openGLRenderWindow.getGraphicsResourceForObject(o),u=is(i,o);if(!((E=c==null?void 0:c.oglObject)!=null&&E.getHandle())||(c==null?void 0:c.hash)!==u){e.volumeTexture=he.newInstance(),e.volumeTexture.setOpenGLRenderWindow(e._openGLRenderWindow);const N=i.getDimensions();e.volumeTexture.setOglNorm16Ext(e.context.getExtension("EXT_texture_norm16")),e.volumeTexture.resetFormatAndType(),e.volumeTexture.create3DFilterableFromDataArray(N[0],N[1],N[2],o,e.renderable.getPreferSizeOverAccuracy()),e._openGLRenderWindow.setGraphicsResourceForObject(o,e.volumeTexture,u),o!==e._scalars&&(e._openGLRenderWindow.registerGraphicsResourceUser(o,t),e._openGLRenderWindow.unregisterGraphicsResourceUser(e._scalars,t)),e._scalars=o}else e.volumeTexture=c.oglObject;const f=o.getNumberOfComponents(),l=a.getProperty(),p=l.getIndependentComponents(),d=p?f:1,h=p?2*d:1,T=l.getRGBTransferFunction(),v=Bt(T,p,d),C=e._openGLRenderWindow.getGraphicsResourceForObject(T);if(!((M=C==null?void 0:C.oglObject)!=null&&M.getHandle())||(C==null?void 0:C.hash)!==v){const G=1024*h*3,_=new Uint8ClampedArray(G);if(e.colorTexture=he.newInstance(),e.colorTexture.setOpenGLRenderWindow(e._openGLRenderWindow),T){const B=new Float32Array(3072);for(let F=0;F<d;F++){const z=l.getRGBTransferFunction(F),U=z.getRange();if(z.getTable(U[0],U[1],1024,B,1),p)for(let k=0;k<1024*3;k++)_[F*1024*6+k]=255*B[k],_[F*1024*6+k+1024*3]=255*B[k];else for(let k=0;k<1024*3;k++)_[F*1024*6+k]=255*B[k]}e.colorTexture.resetFormatAndType(),e.colorTexture.create2DFromRaw(1024,h,3,J.UNSIGNED_CHAR,_)}else{for(let B=0;B<1024*3;++B)_[B]=255*B/((1024-1)*3),_[B+1]=255*B/((1024-1)*3),_[B+2]=255*B/((1024-1)*3);e.colorTexture.resetFormatAndType(),e.colorTexture.create2DFromRaw(1024,1,3,J.UNSIGNED_CHAR,_)}T&&(e._openGLRenderWindow.setGraphicsResourceForObject(T,e.colorTexture,v),T!==e._colorTransferFunc&&(e._openGLRenderWindow.registerGraphicsResourceUser(T,t),e._openGLRenderWindow.unregisterGraphicsResourceUser(e._colorTransferFunc,t)),e._colorTransferFunc=T)}else e.colorTexture=C.oglObject;const x=l.getPiecewiseFunction(),R=Bt(x,p,d),O=e._openGLRenderWindow.getGraphicsResourceForObject(x);if(!((D=O==null?void 0:O.oglObject)!=null&&D.getHandle())||(O==null?void 0:O.hash)!==R){const G=1024*h,_=new Uint8ClampedArray(G);if(e.pwfTexture=he.newInstance(),e.pwfTexture.setOpenGLRenderWindow(e._openGLRenderWindow),x){const B=new Float32Array(G),F=new Float32Array(1024);for(let z=0;z<d;++z){const U=l.getPiecewiseFunction(z);if(U===null)B.fill(1);else{const k=U.getRange();if(U.getTable(k[0],k[1],1024,F,1),p)for(let L=0;L<1024;L++)B[z*1024*2+L]=F[L],B[z*1024*2+L+1024]=F[L];else for(let L=0;L<1024;L++)B[z*1024*2+L]=F[L]}}e.pwfTexture.resetFormatAndType(),e.pwfTexture.create2DFromRaw(1024,h,1,J.FLOAT,B)}else _.fill(255),e.pwfTexture.resetFormatAndType(),e.pwfTexture.create2DFromRaw(1024,1,1,J.UNSIGNED_CHAR,_);x&&(e._openGLRenderWindow.setGraphicsResourceForObject(x,e.pwfTexture,R),x!==e._pwFunc&&(e._openGLRenderWindow.registerGraphicsResourceUser(x,t),e._openGLRenderWindow.unregisterGraphicsResourceUser(e._pwFunc,t)),e._pwFunc=x)}else e.pwfTexture=O.oglObject;if(e.VBOBuildTime.getMTime()<e.renderable.getMTime()||e.VBOBuildTime.getMTime()<s.getMTime()){const N=s.getNumberOfPoints(),G=N<=1?0:N-1,_=s.getDistancesToFirstPoint(),B=e.renderable.getHeight(),F=4*G,z=new Float32Array(3*F),U=e.renderable.getWidth();for(let ie=0,te=0;ie<G;++ie)z.set([0,B-_[ie],0],te),te+=3,z.set([U,B-_[ie],0],te),te+=3,z.set([U,B-_[ie+1],0],te),te+=3,z.set([0,B-_[ie+1],0],te),te+=3;const k=A.newInstance({numberOfComponents:3,values:z});k.setName("points");const L=new Uint16Array(5*G);for(let ie=0,te=0,ze=0;ie<G;++ie)L.set([4,ze+3,ze+2,ze+1,ze],te),te+=5,ze+=4;const W=A.newInstance({numberOfComponents:1,values:L}),H=s.getPoints(),$=new Float32Array(3*F),Q=new Array(3),Mt=new Array(3);for(let ie=0,te=0;ie<G;++ie)H.getPoint(ie,Q),H.getPoint(ie+1,Mt),$.set(Q,te),te+=3,$.set(Q,te),te+=3,$.set(Mt,te),te+=3,$.set(Mt,te),te+=3;const Ve=A.newInstance({numberOfComponents:3,values:$,name:"centerlinePosition"}),et=new Float32Array(F);for(let ie=0,te=0;ie<G;++ie)et.set([0,1,3,2],te),te+=4;const Ne=A.newInstance({numberOfComponents:1,values:et,name:"quadIndex"}),$e=[Ve,Ne];if(!e.renderable.getUseUniformOrientation()){const ie=e.renderable.getOrientedCenterline().getOrientations()??[],te=new Float32Array(4*F),ze=new Float32Array(4*F);for(let Mn=0;Mn<G;++Mn){const dl=ie[Mn],Tl=ie[Mn+1];for(let Ea=0;Ea<4;++Ea){const ws=4*(Ea+4*Mn);te.set(dl,ws),ze.set(Tl,ws)}}const pl=A.newInstance({numberOfComponents:4,values:te,name:"centerlineTopOrientation"}),hl=A.newInstance({numberOfComponents:4,values:ze,name:"centerlineBotOrientation"});$e.push(pl,hl)}e.tris.getCABO().createVBO(W,"polys",me.SURFACE,{points:k,customAttributes:$e}),e.VBOBuildTime.modified()}},t.getNeedToRebuildShaders=(n,a,i)=>{const s=e.volumeTexture.getComponents(),o=i.getProperty().getIndependentComponents(),c=!!e.renderable.getCenterPoint(),u=e.renderable.getUseUniformOrientation(),g=e.renderable.isProjectionEnabled()&&e.renderable.getProjectionMode();return n.getProgram()===0||e.lastUseCenterPoint!==c||e.lastUseUniformOrientation!==u||e.lastProjectionMode!==g||e.lastHaveSeenDepthRequest!==e.haveSeenDepthRequest||e.lastTextureComponents!==s||e.lastIndependentComponents!==o?(e.lastUseCenterPoint=c,e.lastUseUniformOrientation=u,e.lastProjectionMode=g,e.lastHaveSeenDepthRequest=e.haveSeenDepthRequest,e.lastTextureComponents=s,e.lastIndependentComponents=o,!0):!1},t.buildShaders=(n,a,i)=>{t.getShaderTemplate(n,a,i),t.replaceShaderValues(n,a,i)},t.replaceShaderValues=(n,a,i)=>{let s=n.Vertex,o=n.Fragment;const c=["vec3 applyQuaternionToVec(vec4 q, vec3 v) {","  float uvx = q.y * v.z - q.z * v.y;","  float uvy = q.z * v.x - q.x * v.z;","  float uvz = q.x * v.y - q.y * v.x;","  float uuvx = q.y * uvz - q.z * uvy;","  float uuvy = q.z * uvx - q.x * uvz;","  float uuvz = q.x * uvy - q.y * uvx;","  float w2 = q.w * 2.0;","  uvx *= w2;","  uvy *= w2;","  uvz *= w2;","  uuvx *= 2.0;","  uuvy *= 2.0;","  uuvz *= 2.0;","  return vec3(v.x + uvx + uuvx, v.y + uvy + uuvy, v.z + uvz + uuvz);","}"];s=V.substitute(s,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,s=V.substitute(s,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result;const u=["attribute vec3 centerlinePosition;","attribute float quadIndex;","uniform float width;","out vec2 quadOffsetVSOutput;","out vec3 centerlinePosVSOutput;"],g=e.renderable.isProjectionEnabled(),f=e.renderable.getUseUniformOrientation();f?(u.push("out vec3 samplingDirVSOutput;","uniform vec4 centerlineOrientation;","uniform vec3 tangentDirection;",...c),g&&u.push("out vec3 projectionDirVSOutput;","uniform vec3 bitangentDirection;")):u.push("out vec4 centerlineTopOrientationVSOutput;","out vec4 centerlineBotOrientationVSOutput;","attribute vec4 centerlineTopOrientation;","attribute vec4 centerlineBotOrientation;"),s=V.substitute(s,"//VTK::Color::Dec",u).result;const l=["quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);","centerlinePosVSOutput = centerlinePosition;"];f?(l.push("samplingDirVSOutput = applyQuaternionToVec(centerlineOrientation, tangentDirection);"),g&&l.push("projectionDirVSOutput = applyQuaternionToVec(centerlineOrientation, bitangentDirection);")):l.push("centerlineTopOrientationVSOutput = centerlineTopOrientation;","centerlineBotOrientationVSOutput = centerlineBotOrientation;"),s=V.substitute(s,"//VTK::Color::Impl",l).result;const p=e.volumeTexture.getComponents(),d=i.getProperty().getIndependentComponents();let h=["uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates","in vec2 quadOffsetVSOutput;","in vec3 centerlinePosVSOutput;","uniform highp sampler3D volumeTexture;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;"];g&&h.push("uniform vec3 volumeSizeMC;","uniform int projectionSlabNumberOfSamples;","uniform float projectionConstantOffset;","uniform float projectionStepLength;"),f?(h.push("in vec3 samplingDirVSOutput;"),g&&h.push("in vec3 projectionDirVSOutput;")):(h.push("uniform vec3 tangentDirection;","in vec4 centerlineTopOrientationVSOutput;","in vec4 centerlineBotOrientationVSOutput;",...c),g&&h.push("uniform vec3 bitangentDirection;"));const T=e.renderable.getCenterPoint();if(T&&h.push("uniform vec3 globalCenterPoint;"),d){for(let C=1;C<p;C++)h=h.concat([`uniform float cshift${C};`,`uniform float cscale${C};`,`uniform float pwfshift${C};`,`uniform float pwfscale${C};`]);switch(p){case 1:h=h.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:h=h.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:h=h.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:h=h.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:mr("Unsupported number of independent coordinates.")}}o=V.substitute(o,"//VTK::TCoord::Dec",h).result;let v=[];if(f?(v.push("vec3 samplingDirection = samplingDirVSOutput;"),g&&v.push("vec3 projectionDirection = projectionDirVSOutput;")):(v.push("vec4 q0 = centerlineBotOrientationVSOutput;","vec4 q1 = centerlineTopOrientationVSOutput;","float qCosAngle = dot(q0, q1);","vec4 interpolatedOrientation;","if (qCosAngle > 0.999 || qCosAngle < -0.999) {","  // Use LERP instead of SLERP when the two quaternions are close or opposite","  interpolatedOrientation = normalize(mix(q0, q1, quadOffsetVSOutput.y));","} else {","  float omega = acos(qCosAngle);","  interpolatedOrientation = normalize(sin((1.0 - quadOffsetVSOutput.y) * omega) * q0 + sin(quadOffsetVSOutput.y * omega) * q1);","}","vec3 samplingDirection = applyQuaternionToVec(interpolatedOrientation, tangentDirection);"),g&&v.push("vec3 projectionDirection = applyQuaternionToVec(interpolatedOrientation, bitangentDirection);")),T?v.push("float baseOffset = dot(samplingDirection, globalCenterPoint - centerlinePosVSOutput);","float horizontalOffset = quadOffsetVSOutput.x + baseOffset;"):v.push("float horizontalOffset = quadOffsetVSOutput.x;"),v.push("vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * samplingDirection;","vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;","if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}"),g){const C=e.renderable.getProjectionMode();switch(C){case Kt.MIN:v.push("const vec4 initialProjectionTextureValue = vec4(1.0);");break;case Kt.MAX:case Kt.AVERAGE:default:v.push("const vec4 initialProjectionTextureValue = vec4(0.0);");break}switch(v.push("vec3 projectionScaledDirection = projectionDirection / volumeSizeMC;","vec3 projectionStep = projectionStepLength * projectionScaledDirection;","vec3 projectionStartPosition = volumePosTC + projectionConstantOffset * projectionScaledDirection;","vec4 tvalue = initialProjectionTextureValue;","for (int projectionSampleIdx = 0; projectionSampleIdx < projectionSlabNumberOfSamples; ++projectionSampleIdx) {","  vec3 projectionSamplePosition = projectionStartPosition + float(projectionSampleIdx) * projectionStep;","  vec4 sampledTextureValue = texture(volumeTexture, projectionSamplePosition);"),C){case Kt.MAX:v.push("  tvalue = max(tvalue, sampledTextureValue);");break;case Kt.MIN:v.push("  tvalue = min(tvalue, sampledTextureValue);");break;case Kt.AVERAGE:default:v.push("  tvalue = tvalue + sampledTextureValue;");break}v.push("}"),C===Kt.AVERAGE&&v.push("tvalue = tvalue / float(projectionSlabNumberOfSamples);")}else v.push("vec4 tvalue = texture(volumeTexture, volumePosTC);");if(d){const C=["r","g","b","a"];for(let S=0;S<p;++S)v=v.concat([`vec3 tcolor${S} = mix${S} * texture2D(colorTexture1, vec2(tvalue.${C[S]} * cscale${S} + cshift${S}, height${S})).rgb;`,`float compWeight${S} = mix${S} * texture2D(pwfTexture1, vec2(tvalue.${C[S]} * pwfscale${S} + pwfshift${S}, height${S})).r;`]);switch(p){case 1:v=v.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:v=v.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:v=v.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:v=v.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:mr("Unsupported number of independent coordinates.")}}else switch(p){case 1:v=v.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:v=v.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:v=v.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:v=v.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}o=V.substitute(o,"//VTK::TCoord::Impl",v).result,e.haveSeenDepthRequest&&(o=V.substitute(o,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,o=V.substitute(o,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=s,n.Fragment=o,t.replaceShaderClip(n,a,i),t.replaceShaderCoincidentOffset(n,a,i)},t.replaceShaderClip=(n,a,i)=>{let s=n.Vertex,o=n.Fragment;if(e.renderable.getNumberOfClippingPlanes()){let c=e.renderable.getNumberOfClippingPlanes();c>6&&(y.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),c=6),s=V.substitute(s,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,s=V.substitute(s,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,o=V.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,o=V.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}n.Vertex=s,n.Fragment=o},t.getShaderTemplate=(n,a,i)=>{n.Vertex=es,n.Fragment=ts,n.Geometry=""},t.setMapperShaderParameters=(n,a,i)=>{const s=n.getProgram(),o=n.getCABO();o.getElementCount()&&(e.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(s.isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(s,o,"vertexMC",o.getVertexOffset(),o.getStride(),e.context.FLOAT,3,e.context.FALSE)||mr("Error setting vertexMC in shader VAO.")),n.getCABO().getCustomData().forEach(p=>{p&&s.isAttributeUsed(p.name)&&!n.getVAO().addAttributeArray(s,o,p.name,p.offset,o.getStride(),e.context.FLOAT,p.components,e.context.FALSE)&&mr(`Error setting ${p.name} in shader VAO.`)}),n.getAttributeUpdateTime().modified());const c=e.volumeTexture.getTextureUnit();if(s.setUniformi("volumeTexture",c),s.setUniformf("width",e.renderable.getWidth()),n.getProgram().setUniform4fv("backgroundColor",e.renderable.getBackgroundColor()),s.isUniformUsed("tangentDirection")){const p=e.renderable.getTangentDirection();n.getProgram().setUniform3fArray("tangentDirection",p)}if(s.isUniformUsed("bitangentDirection")){const p=e.renderable.getBitangentDirection();n.getProgram().setUniform3fArray("bitangentDirection",p)}if(s.isUniformUsed("centerlineOrientation")){const p=e.renderable.getUniformOrientation();n.getProgram().setUniform4fv("centerlineOrientation",p)}if(s.isUniformUsed("globalCenterPoint")){const p=e.renderable.getCenterPoint();s.setUniform3fArray("globalCenterPoint",p)}if(e.renderable.isProjectionEnabled()){const p=e.currentImageDataInput,d=p.getSpacing(),h=p.getDimensions(),T=e.renderable.getProjectionSlabThickness(),v=e.renderable.getProjectionSlabNumberOfSamples(),C=Dl([],d,h);s.setUniform3fArray("volumeSizeMC",C),s.setUniformi("projectionSlabNumberOfSamples",v);const S=-.5*T;s.setUniformf("projectionConstantOffset",S);const x=T/(v-1);s.setUniformf("projectionStepLength",x)}const u=e.currentImageDataInput,g=u.getWorldToIndex(),f=Go(new Float32Array(16),_o([],u.getDimensions())),l=Vl(f,f,g);if(s.setUniformMatrix("MCTCMatrix",l),e.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",e.renderDepth?1:0),e.renderable.getNumberOfClippingPlanes()){let p=e.renderable.getNumberOfClippingPlanes();p>6&&(y.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),p=6);const h=o.getCoordShiftAndScaleEnabled()?o.getInverseShiftAndScaleMatrix():null,T=h?Re(e.imagematinv,i.getMatrix()):i.getMatrix();h&&(se(T,T),ae(T,T,h),se(T,T)),se(e.imagemat,e.currentImageDataInput.getIndexToWorld()),ae(e.imagematinv,T,e.imagemat);const v=[];for(let C=0;C<p;C++){const S=[];e.renderable.getClippingPlaneInDataCoords(e.imagematinv,C,S);for(let x=0;x<4;x++)v.push(S[x])}s.setUniformi("numClipPlanes",p),s.setUniform4fv("clipPlanes",v)}if(s.isUniformUsed("coffset")){const p=t.getCoincidentParameters(a,i);s.setUniformf("coffset",p.offset),s.isUniformUsed("cfactor")&&s.setUniformf("cfactor",p.factor)}},t.setCameraShaderParameters=(n,a,i)=>{const s=e.openGLImageSlice.getKeyMatrices().mcwc,o=e.openGLCamera.getKeyMatrices(a).wcpc;if(ae(e.imagemat,o,s),n.getCABO().getCoordShiftAndScaleEnabled()){const c=n.getCABO().getInverseShiftAndScaleMatrix();ae(e.imagemat,e.imagemat,c)}n.getProgram().setUniformMatrix("MCPCMatrix",e.imagemat)},t.setPropertyShaderParameters=(n,a,i)=>{const s=n.getProgram(),o=i.getProperty(),c=o.getOpacity();s.setUniformf("opacity",c);const u=e.volumeTexture.getComponents(),g=o.getIndependentComponents();if(g)for(let d=0;d<u;++d)s.setUniformf(`mix${d}`,o.getComponentWeight(d));const f=e.volumeTexture.getVolumeInfo();for(let d=0;d<u;d++){let h=o.getColorWindow(),T=o.getColorLevel();const v=g?d:0,C=o.getRGBTransferFunction(v);if(C&&o.getUseLookupTableScalarRange()){const R=C.getRange();h=R[1]-R[0],T=.5*(R[1]+R[0])}const S=f.scale[d]/h,x=(f.offset[d]-T)/h+.5;s.setUniformf(`cshift${d}`,x),s.setUniformf(`cscale${d}`,S)}const l=e.colorTexture.getTextureUnit();s.setUniformi("colorTexture1",l);for(let d=0;d<u;d++){let h=1,T=0;const v=g?d:0,C=o.getPiecewiseFunction(v);if(C){const S=C.getRange(),x=S[1]-S[0],R=.5*(S[0]+S[1]);h=f.scale[d]/x,T=(f.offset[d]-R)/x+.5}s.setUniformf(`pwfshift${d}`,T),s.setUniformf(`pwfscale${d}`,h)}const p=e.pwfTexture.getTextureUnit();s.setUniformi("pwfTexture1",p)},t.updateShaders=(n,a,i)=>{if(t.getNeedToRebuildShaders(n,a,i)){const s={Vertex:null,Fragment:null,Geometry:null};t.buildShaders(s,a,i);const o=e._openGLRenderWindow.getShaderCache().readyShaderProgramArray(s.Vertex,s.Fragment,s.Geometry);o!==n.getProgram()&&(n.setProgram(o),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else e._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),t.setMapperShaderParameters(n,a,i),t.setCameraShaderParameters(n,a,i),t.setPropertyShaderParameters(n,a,i)},t.delete=y.chain(()=>{e._openGLRenderWindow&&r(e._openGLRenderWindow)},t.delete)}const Zv={currentRenderPass:null,volumeTexture:null,colorTexture:null,pwfTexture:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};function Pv(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Zv,r),De.extend(t,e,r),ut.implementReplaceShaderCoincidentOffset(t,e,r),y.algo(t,e,2,0),e.tris=ft.newInstance(),e.volumeTexture=null,e.colorTexture=null,e.pwfTexture=null,e.imagemat=X(new Float64Array(16)),e.imagematinv=X(new Float64Array(16)),e.VBOBuildTime={},y.obj(e.VBOBuildTime,{mtime:0}),qv(t,e)}const Jv=y.newInstance(Pv,"vtkOpenGLImageCPRMapper");Oe("vtkImageCPRMapper",Jv);function Qv(t,e){e.classHierarchy.push("vtkOpenGLImageSlice"),t.buildPass=r=>{if(!(!e.renderable||!e.renderable.getVisibility())&&r){if(!e.renderable)return;e._openGLRenderWindow=t.getLastAncestorOfType("vtkOpenGLRenderWindow"),e._openGLRenderer=t.getFirstAncestorOfType("vtkOpenGLRenderer"),e.context=e._openGLRenderWindow.getContext(),t.prepareNodes(),t.addMissingNode(e.renderable.getMapper()),t.removeUnusedNodes()}},t.traverseZBufferPass=r=>{!e.renderable||!e.renderable.getNestedVisibility()||e._openGLRenderer.getSelector()&&!e.renderable.getNestedPickable()||(t.apply(r,!0),e.children.forEach(n=>{n.traverse(r)}),t.apply(r,!1))},t.traverseOpaqueZBufferPass=r=>t.traverseOpaquePass(r),t.traverseOpaquePass=r=>{!e.renderable||!e.renderable.getNestedVisibility()||!e.renderable.getIsOpaque()||e._openGLRenderer.getSelector()&&!e.renderable.getNestedPickable()||(t.apply(r,!0),e.children.forEach(n=>{n.traverse(r)}),t.apply(r,!1))},t.traverseTranslucentPass=r=>{!e.renderable||!e.renderable.getNestedVisibility()||e.renderable.getIsOpaque()||e._openGLRenderer.getSelector()&&!e.renderable.getNestedPickable()||(t.apply(r,!0),e.children.forEach(n=>{n.traverse(r)}),t.apply(r,!1))},t.queryPass=(r,n)=>{if(r){if(!e.renderable||!e.renderable.getVisibility())return;e.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},t.zBufferPass=(r,n)=>t.opaquePass(r,n),t.opaqueZBufferPass=(r,n)=>t.opaquePass(r,n),t.opaquePass=(r,n)=>{r&&e.context.depthMask(!0)},t.translucentPass=(r,n)=>{e.context.depthMask(!r)},t.getKeyMatrices=()=>(e.renderable.getMTime()>e.keyMatrixTime.getMTime()&&(Re(e.keyMatrices.mcwc,e.renderable.getMatrix()),se(e.keyMatrices.mcwc,e.keyMatrices.mcwc),e.keyMatrixTime.modified()),e.keyMatrices)}const Iv={context:null,keyMatrixTime:null,keyMatrices:null};function ey(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Iv,r),De.extend(t,e,r),e.keyMatrixTime={},xe(e.keyMatrixTime,{mtime:0}),e.keyMatrices={mcwc:X(new Float64Array(16))},Me(t,e,["context"]),Qv(t,e)}const ty=ye(ey,"vtkOpenGLImageSlice");Oe("vtkImageSlice",ty);function ny(t,e){e.classHierarchy.push("vtkOpenGLVolume"),t.buildPass=r=>{!e.renderable||!e.renderable.getVisibility()||r&&(e._openGLRenderWindow=t.getLastAncestorOfType("vtkOpenGLRenderWindow"),e._openGLRenderer=t.getFirstAncestorOfType("vtkOpenGLRenderer"),e.context=e._openGLRenderWindow.getContext(),t.prepareNodes(),t.addMissingNode(e.renderable.getMapper()),t.removeUnusedNodes())},t.queryPass=(r,n)=>{if(r){if(!e.renderable||!e.renderable.getVisibility())return;n.incrementVolumeCount()}},t.traverseVolumePass=r=>{!e.renderable||!e.renderable.getNestedVisibility()||e._openGLRenderer.getSelector()&&!e.renderable.getNestedPickable()||(t.apply(r,!0),e.children[0].traverse(r),t.apply(r,!1))},t.volumePass=r=>{!e.renderable||!e.renderable.getVisibility()||e.context.depthMask(!r)},t.getKeyMatrices=()=>(e.renderable.getMTime()>e.keyMatrixTime.getMTime()&&(e.renderable.computeMatrix(),Re(e.MCWCMatrix,e.renderable.getMatrix()),se(e.MCWCMatrix,e.MCWCMatrix),e.renderable.getIsIdentity()?ct(e.normalMatrix):(pa(e.normalMatrix,e.MCWCMatrix),nr(e.normalMatrix,e.normalMatrix),mi(e.normalMatrix,e.normalMatrix)),e.keyMatrixTime.modified()),{mcwc:e.MCWCMatrix,normalMatrix:e.normalMatrix})}const ry={};function ay(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,ry,r),De.extend(t,e,r),e.keyMatrixTime={},xe(e.keyMatrixTime,{mtime:0}),e.normalMatrix=new Float64Array(9),e.MCWCMatrix=new Float64Array(16),Me(t,e,["context"]),ny(t,e)}const iy=ye(ay,"vtkOpenGLVolume");Oe("vtkVolume",iy);function sy(t,e){e.classHierarchy.push("vtkFramebuffer"),t.getBothMode=()=>e.context.FRAMEBUFFER,t.saveCurrentBindingsAndBuffers=r=>{const n=typeof r<"u"?r:t.getBothMode();t.saveCurrentBindings(n),t.saveCurrentBuffers(n)},t.saveCurrentBindings=r=>{if(!e.context){ne("you must set the OpenGLRenderWindow before calling saveCurrentBindings");return}const n=e.context;e.previousDrawBinding=n.getParameter(e.context.FRAMEBUFFER_BINDING),e.previousActiveFramebuffer=e._openGLRenderWindow.getActiveFramebuffer()},t.saveCurrentBuffers=r=>{},t.restorePreviousBindingsAndBuffers=r=>{const n=typeof r<"u"?r:t.getBothMode();t.restorePreviousBindings(n),t.restorePreviousBuffers(n)},t.restorePreviousBindings=r=>{if(!e.context){ne("you must set the OpenGLRenderWindow before calling restorePreviousBindings");return}const n=e.context;n.bindFramebuffer(n.FRAMEBUFFER,e.previousDrawBinding),e._openGLRenderWindow.setActiveFramebuffer(e.previousActiveFramebuffer)},t.restorePreviousBuffers=r=>{},t.bind=function(){let n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:null;n===null&&(n=e.context.FRAMEBUFFER),e.context.bindFramebuffer(n,e.glFramebuffer);for(let a=0;a<e.colorBuffers.length;a++)e.colorBuffers[a].bind();e._openGLRenderWindow.setActiveFramebuffer(t)},t.create=(r,n)=>{if(!e.context){ne("you must set the OpenGLRenderWindow before calling create");return}e.glFramebuffer=e.context.createFramebuffer(),e.glFramebuffer.width=r,e.glFramebuffer.height=n},t.setColorBuffer=function(r){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0;const a=e.context;if(!a){ne("you must set the OpenGLRenderWindow before calling setColorBuffer");return}let i=a.COLOR_ATTACHMENT0;if(n>0)if(e._openGLRenderWindow.getWebgl2())i+=n;else{ne("Using multiple framebuffer attachments requires WebGL 2");return}e.colorBuffers[n]=r,a.framebufferTexture2D(a.FRAMEBUFFER,i,a.TEXTURE_2D,r.getHandle(),0)},t.removeColorBuffer=function(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;const n=e.context;if(!n){ne("you must set the OpenGLRenderWindow before calling removeColorBuffer");return}let a=n.COLOR_ATTACHMENT0;if(r>0)if(e._openGLRenderWindow.getWebgl2())a+=r;else{ne("Using multiple framebuffer attachments requires WebGL 2");return}n.framebufferTexture2D(n.FRAMEBUFFER,a,n.TEXTURE_2D,null,0),e.colorBuffers=e.colorBuffers.splice(r,1)},t.setDepthBuffer=r=>{if(!e.context){ne("you must set the OpenGLRenderWindow before calling setDepthBuffer");return}if(e._openGLRenderWindow.getWebgl2()){const n=e.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,r.getHandle(),0)}else ne("Attaching depth buffer textures to fbo requires WebGL 2")},t.removeDepthBuffer=()=>{if(!e.context){ne("you must set the OpenGLRenderWindow before calling removeDepthBuffer");return}if(e._openGLRenderWindow.getWebgl2()){const r=e.context;r.framebufferTexture2D(r.FRAMEBUFFER,r.DEPTH_ATTACHMENT,r.TEXTURE_2D,null,0)}else ne("Attaching depth buffer textures to framebuffers requires WebGL 2")},t.getGLFramebuffer=()=>e.glFramebuffer,t.setOpenGLRenderWindow=r=>{e._openGLRenderWindow!==r&&(t.releaseGraphicsResources(),e._openGLRenderWindow=r,e.context=null,r&&(e.context=e._openGLRenderWindow.getContext()))},t.releaseGraphicsResources=()=>{e.glFramebuffer&&e.context.deleteFramebuffer(e.glFramebuffer)},t.getSize=()=>e.glFramebuffer==null?null:[e.glFramebuffer.width,e.glFramebuffer.height],t.populateFramebuffer=()=>{if(!e.context){ne("you must set the OpenGLRenderWindow before calling populateFrameBuffer");return}t.bind();const r=e.context,n=he.newInstance();n.setOpenGLRenderWindow(e._openGLRenderWindow),n.setMinificationFilter(j.LINEAR),n.setMagnificationFilter(j.LINEAR),n.create2DFromRaw(e.glFramebuffer.width,e.glFramebuffer.height,4,J.UNSIGNED_CHAR,null),t.setColorBuffer(n),e.depthTexture=r.createRenderbuffer(),r.bindRenderbuffer(r.RENDERBUFFER,e.depthTexture),r.renderbufferStorage(r.RENDERBUFFER,r.DEPTH_COMPONENT16,e.glFramebuffer.width,e.glFramebuffer.height),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.DEPTH_ATTACHMENT,r.RENDERBUFFER,e.depthTexture)},t.getColorTexture=()=>e.colorBuffers[0]}const oy={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function pf(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,oy,r),xe(t,e),e.colorBuffers&&ne("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead."),e.colorBuffers=[],sr(t,e,["colorBuffers"]),sy(t,e)}const cy=ye(pf,"vtkFramebuffer");var Ma={newInstance:cy,extend:pf};const di={NEAREST:0,LINEAR:1,FAST_LINEAR:2},hf={FRACTIONAL:0,PROPORTIONAL:1},br={CUSTOM:0,ADDITIVE:1,COLORIZE:2};var df={InterpolationType:di,OpacityMode:hf,ColorMixPreset:br};const Kr={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5,LABELMAP_EDGE_PROJECTION_BLEND:6},uy={OFF:0,NORMALIZED:1,RAW:2};var fy={BlendMode:Kr,FilterMode:uy},gy=`//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkPolyDataVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

attribute vec4 vertexDC;

varying vec3 vertexVCVSOutput;
uniform mat4 PCVCMatrix;

uniform float dcxmin;
uniform float dcxmax;
uniform float dcymin;
uniform float dcymax;

void main()
{
  // dcsmall is the device coords reduced to the
  // x y area covered by the volume
  vec4 dcsmall = vec4(
    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),
    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),
    vertexDC.z,
    vertexDC.w);
  vec4 vcpos = PCVCMatrix * dcsmall;
  vertexVCVSOutput = vcpos.xyz/vcpos.w;
  gl_Position = dcsmall;
}
`,ly=`//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkVolumeFS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// Template for the volume mappers fragment shader

// the output of this shader
//VTK::Output::Dec

varying vec3 vertexVCVSOutput;

// first declare the settings from the mapper
// that impact the code paths in here

// always set vtkNumComponents 1,2,3,4
//VTK::NumComponents

// possibly define vtkTrilinearOn
//VTK::TrilinearOn

// possibly define UseIndependentComponents
//VTK::IndependentComponentsOn

// possibly define vtkCustomComponentsColorMix
//VTK::CustomComponentsColorMixOn

// possibly define any "proportional" components
//VTK::vtkProportionalComponents

// possibly define any components that are forced to nearest interpolation
//VTK::vtkForceNearestComponents

// Define the blend mode to use
#define vtkBlendMode //VTK::BlendMode

// Possibly define vtkImageLabelOutlineOn
//VTK::ImageLabelOutlineOn

// Possibly define vtkLabelEdgeProjectionOn
//VTK::LabelEdgeProjectionOn


#ifdef vtkImageLabelOutlineOn
  uniform float outlineOpacity;
  uniform float vpWidth;
  uniform float vpHeight;
  uniform float vpOffsetX;
  uniform float vpOffsetY;
  uniform mat4 PCWCMatrix;
  uniform mat4 vWCtoIDX;

  const int MAX_SEGMENT_INDEX = 256; // Define as per expected maximum
  // bool seenSegmentsByOriginalPos[MAX_SEGMENT_INDEX];
  #define MAX_SEGMENTS 256
  #define UINT_SIZE 32
  #define BITMASK_SIZE ((MAX_SEGMENTS + UINT_SIZE - 1) / UINT_SIZE)

  uint bitmask[BITMASK_SIZE];

  // Set the corresponding bit in the bitmask
  void setBit(int segmentIndex) {
    int index = segmentIndex / UINT_SIZE;
    int bitIndex = segmentIndex % UINT_SIZE;
    bitmask[index] |= 1u << bitIndex;
  }

  // Check if a bit is set in the bitmask
  bool isBitSet(int segmentIndex) {
    int index = segmentIndex / UINT_SIZE;
    int bitIndex = segmentIndex % UINT_SIZE;
    return ((bitmask[index] & (1u << bitIndex)) != 0u);
  }
#endif

// define vtkLightComplexity
//VTK::LightComplexity
#if vtkLightComplexity > 0
uniform float vSpecularPower;
uniform float vAmbient;
uniform float vDiffuse;
uniform float vSpecular;
//VTK::Light::Dec
#endif

//VTK::VolumeShadowOn
//VTK::SurfaceShadowOn
//VTK::localAmbientOcclusionOn
//VTK::LAO::Dec
//VTK::VolumeShadow::Dec

// define vtkComputeNormalFromOpacity
//VTK::vtkComputeNormalFromOpacity

// possibly define vtkGradientOpacityOn
//VTK::GradientOpacityOn
#ifdef vtkGradientOpacityOn
uniform float goscale0;
uniform float goshift0;
uniform float gomin0;
uniform float gomax0;
#ifdef UseIndependentComponents
#if vtkNumComponents > 1
uniform float goscale1;
uniform float goshift1;
uniform float gomin1;
uniform float gomax1;
#if vtkNumComponents > 2
uniform float goscale2;
uniform float goshift2;
uniform float gomin2;
uniform float gomax2;
#if vtkNumComponents > 3
uniform float goscale3;
uniform float goshift3;
uniform float gomin3;
uniform float gomax3;
#endif
#endif
#endif
#endif
#endif

// if you want to see the raw tiled
// data in webgl1 uncomment the following line
// #define debugtile

// camera values
uniform float camThick;
uniform float camNear;
uniform float camFar;
uniform int cameraParallel;

// values describing the volume geometry
uniform vec3 vOriginVC;
uniform vec3 vSpacing;
uniform ivec3 volumeDimensions; // 3d texture dimensions
uniform vec3 vPlaneNormal0;
uniform float vPlaneDistance0;
uniform vec3 vPlaneNormal1;
uniform float vPlaneDistance1;
uniform vec3 vPlaneNormal2;
uniform float vPlaneDistance2;
uniform vec3 vPlaneNormal3;
uniform float vPlaneDistance3;
uniform vec3 vPlaneNormal4;
uniform float vPlaneDistance4;
uniform vec3 vPlaneNormal5;
uniform float vPlaneDistance5;

//VTK::ClipPlane::Dec

// opacity and color textures
uniform sampler2D otexture;
uniform float oshift0;
uniform float oscale0;
uniform sampler2D ctexture;
uniform float cshift0;
uniform float cscale0;

#if vtkNumComponents >= 2
uniform float oshift1;
uniform float oscale1;
uniform float cshift1;
uniform float cscale1;
#endif
#if vtkNumComponents >= 3
uniform float oshift2;
uniform float oscale2;
uniform float cshift2;
uniform float cscale2;
#endif
#if vtkNumComponents >= 4
uniform float oshift3;
uniform float oscale3;
uniform float cshift3;
uniform float cscale3;
#endif

// jitter texture
uniform sampler2D jtexture;
uniform sampler2D ttexture;


// some 3D texture values
uniform float sampleDistance;
uniform vec3 vVCToIJK;
uniform vec3 volumeSpacings; // spacing in the world coorindates


// the heights defined below are the locations
// for the up to four components of the tfuns
// the tfuns have a height of 2XnumComps pixels so the
// values are computed to hit the middle of the two rows
// for that component
#ifdef UseIndependentComponents
#if vtkNumComponents == 1
uniform float mix0;
#define height0 0.5
#endif
#if vtkNumComponents == 2
uniform float mix0;
uniform float mix1;
#define height0 0.25
#define height1 0.75
#endif
#if vtkNumComponents == 3
uniform float mix0;
uniform float mix1;
uniform float mix2;
#define height0 0.17
#define height1 0.5
#define height2 0.83
#endif
#if vtkNumComponents == 4
uniform float mix0;
uniform float mix1;
uniform float mix2;
uniform float mix3;
#define height0 0.125
#define height1 0.375
#define height2 0.625
#define height3 0.875
#endif
#endif

uniform vec4 ipScalarRangeMin;
uniform vec4 ipScalarRangeMax;

// declaration for intermixed geometry
//VTK::ZBuffer::Dec

//=======================================================================
// global and custom variables (a temporary section before photorealistics rendering module is complete)
vec3 rayDirVC;
float sampleDistanceISVS;
float sampleDistanceIS;

#define SQRT3    1.7321
#define INV4PI   0.0796
#define EPSILON  0.001
#define PI       3.1415
#define PI2      9.8696

//=======================================================================
// Webgl2 specific version of functions
#if __VERSION__ == 300

uniform highp sampler3D texture1;

vec4 getTextureValue(vec3 pos)
{
  vec4 tmp = texture(texture1, pos);

  #if defined(vtkComponent0ForceNearest) || \\
      defined(vtkComponent1ForceNearest) || \\
      defined(vtkComponent2ForceNearest) || \\
      defined(vtkComponent3ForceNearest)
    vec3 nearestPos = (floor(pos * vec3(volumeDimensions)) + 0.5) / vec3(volumeDimensions);
    vec4 nearestValue = texture(texture1, nearestPos);
    #ifdef vtkComponent0ForceNearest
      tmp[0] = nearestValue[0];
    #endif
    #ifdef vtkComponent1ForceNearest
      tmp[1] = nearestValue[1];
    #endif
    #ifdef vtkComponent2ForceNearest
      tmp[2] = nearestValue[2];
    #endif
    #ifdef vtkComponent3ForceNearest
      tmp[3] = nearestValue[3];
    #endif
  #endif

  #ifndef UseIndependentComponents
    #if vtkNumComponents == 1
      tmp.a = tmp.r;
    #endif
    #if vtkNumComponents == 2
      tmp.a = tmp.g;
    #endif
    #if vtkNumComponents == 3
      tmp.a = length(tmp.rgb);
    #endif
  #endif

  return tmp;
}

//=======================================================================
// WebGL1 specific version of functions
#else

uniform sampler2D texture1;

uniform float texWidth;
uniform float texHeight;
uniform int xreps;
uniform int xstride;
uniform int ystride;

// if computing trilinear values from multiple z slices
#ifdef vtkTrilinearOn
vec4 getTextureValue(vec3 ijk)
{
  float zoff = 1.0/float(volumeDimensions.z);
  vec4 val1 = getOneTextureValue(ijk);
  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));

  float indexZ = float(volumeDimensions)*ijk.z;
  float zmix =  indexZ - floor(indexZ);

  return mix(val1, val2, zmix);
}

vec4 getOneTextureValue(vec3 ijk)
#else // nearest or fast linear
vec4 getTextureValue(vec3 ijk)
#endif
{
  vec3 tdims = vec3(volumeDimensions);

#ifdef debugtile
  vec2 tpos = vec2(ijk.x, ijk.y);
  vec4 tmp = texture2D(texture1, tpos);
  tmp.a = 1.0;

#else
  int z = int(ijk.z * tdims.z);
  int yz = z / xreps;
  int xz = z - yz*xreps;

  int tileWidth = volumeDimensions.x/xstride;
  int tileHeight = volumeDimensions.y/ystride;

  xz *= tileWidth;
  yz *= tileHeight;

  float ni = float(xz) + (ijk.x*float(tileWidth));
  float nj = float(yz) + (ijk.y*float(tileHeight));

  vec2 tpos = vec2(ni/texWidth, nj/texHeight);

  vec4 tmp = texture2D(texture1, tpos);

#if vtkNumComponents == 1
  tmp.a = tmp.r;
#endif
#if vtkNumComponents == 2
  tmp.g = tmp.a;
#endif
#if vtkNumComponents == 3
  tmp.a = length(tmp.rgb);
#endif
#endif

  return tmp;
}

// End of Webgl1 specific code
//=======================================================================
#endif

//=======================================================================
// transformation between VC and IS space

// convert vector position from idx to vc
#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)
vec3 IStoVC(vec3 posIS){
  vec3 posVC = posIS / vVCToIJK;
  return posVC.x * vPlaneNormal0 +
         posVC.y * vPlaneNormal2 +
         posVC.z * vPlaneNormal4 +
         vOriginVC;
}

// convert vector position from vc to idx
vec3 VCtoIS(vec3 posVC){
  posVC = posVC - vOriginVC;
  posVC = vec3(
    dot(posVC, vPlaneNormal0),
    dot(posVC, vPlaneNormal2),
    dot(posVC, vPlaneNormal4));
  return posVC * vVCToIJK;
}
#endif

//Rotate vector to view coordinate
#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)
void rotateToViewCoord(inout vec3 dirIS){
  dirIS.xyz =
    dirIS.x * vPlaneNormal0 +
    dirIS.y * vPlaneNormal2 +
    dirIS.z * vPlaneNormal4;
}

//Rotate vector to idx coordinate
vec3 rotateToIDX(vec3 dirVC){
  vec3 dirIS;
  dirIS.xyz = vec3(
    dot(dirVC, vPlaneNormal0),
    dot(dirVC, vPlaneNormal2),
    dot(dirVC, vPlaneNormal4));
  return dirIS;
}
#endif

//=======================================================================
// Given a normal compute the gradient opacity factors
float computeGradientOpacityFactor(
  float normalMag, float goscale, float goshift, float gomin, float gomax)
{
  return clamp(normalMag * goscale + goshift, gomin, gomax);
}

//=======================================================================
// compute the normal and gradient magnitude for a position, uses forward difference
#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)
  #ifdef vtkClippingPlanesOn
    void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)
    {
      vec3 g1VC[3];
      for (int i = 0; i < 3; ++i)
      {
        g1VC[i] = IStoVC(texPos[i]);
      }
      vec3 posVC = IStoVC(pos);
      for (int i = 0; i < clip_numPlanes; ++i)
      {
        for (int j = 0; j < 3; ++j)
        {
          if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)
          {
            g1[j] = 0.0;
          }
        }
      }
    }
  #endif

  #ifdef vtkComputeNormalFromOpacity
    vec4 computeDensityNormal(vec3 opacityUCoords[2], float opactityTextureHeight, float gradientOpacity) {
      vec3 opacityG1, opacityG2;
      opacityG1.x = texture2D(otexture, vec2(opacityUCoords[0].x, opactityTextureHeight)).r;
      opacityG1.y = texture2D(otexture, vec2(opacityUCoords[0].y, opactityTextureHeight)).r;
      opacityG1.z = texture2D(otexture, vec2(opacityUCoords[0].z, opactityTextureHeight)).r;
      opacityG2.x = texture2D(otexture, vec2(opacityUCoords[1].x, opactityTextureHeight)).r;
      opacityG2.y = texture2D(otexture, vec2(opacityUCoords[1].y, opactityTextureHeight)).r;
      opacityG2.z = texture2D(otexture, vec2(opacityUCoords[1].z, opactityTextureHeight)).r;
      opacityG1.xyz *= gradientOpacity;
      opacityG2.xyz *= gradientOpacity;

      vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);
      // divide by spacing
      opacityG.xyz /= vSpacing;
      opacityG.w = length(opacityG.xyz);
      // rotate to View Coords
      rotateToViewCoord(opacityG.xyz);
      if (!all(equal(opacityG.xyz, vec3(0.0)))) {
        return vec4(normalize(opacityG.xyz),opacityG.w);
      } else {
        return vec4(0.0);
      }
    }

    vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2], const int opacityComponent)
    {
      vec3 xvec = vec3(tstep.x, 0.0, 0.0);
      vec3 yvec = vec3(0.0, tstep.y, 0.0);
      vec3 zvec = vec3(0.0, 0.0, tstep.z);
      vec3 texPosPVec[3];
      texPosPVec[0] = pos + xvec;
      texPosPVec[1] = pos + yvec;
      texPosPVec[2] = pos + zvec;
      vec3 texPosNVec[3];
      texPosNVec[0] = pos - xvec;
      texPosNVec[1] = pos - yvec;
      texPosNVec[2] = pos - zvec;
      vec3 g1, g2;

      scalarInterp[0].x = getTextureValue(texPosPVec[0])[opacityComponent];
      scalarInterp[0].y = getTextureValue(texPosPVec[1])[opacityComponent];
      scalarInterp[0].z = getTextureValue(texPosPVec[2])[opacityComponent];
      scalarInterp[1].x = getTextureValue(texPosNVec[0])[opacityComponent];
      scalarInterp[1].y = getTextureValue(texPosNVec[1])[opacityComponent];
      scalarInterp[1].z = getTextureValue(texPosNVec[2])[opacityComponent];

      #ifdef vtkClippingPlanesOn
        adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);
        adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);
      #endif
      vec4 result;
      result.x = scalarInterp[0].x - scalarInterp[1].x;
      result.y = scalarInterp[0].y - scalarInterp[1].y;
      result.z = scalarInterp[0].z - scalarInterp[1].z;
      // divide by spacing
      result.xyz /= vSpacing;
      result.w = length(result.xyz);
      // rotate to View Coords
      rotateToViewCoord(result.xyz);
      if (length(result.xyz) > 0.0) {
        return vec4(normalize(result.xyz),result.w);
      } else {
        return vec4(0.0);
      }
    }
  #endif

  // only works with dependent components
  vec4 computeNormal(vec3 pos, vec3 tstep)
  {
    vec3 xvec = vec3(tstep.x, 0.0, 0.0);
    vec3 yvec = vec3(0.0, tstep.y, 0.0);
    vec3 zvec = vec3(0.0, 0.0, tstep.z);
    vec3 texPosPVec[3];
    texPosPVec[0] = pos + xvec;
    texPosPVec[1] = pos + yvec;
    texPosPVec[2] = pos + zvec;
    vec3 texPosNVec[3];
    texPosNVec[0] = pos - xvec;
    texPosNVec[1] = pos - yvec;
    texPosNVec[2] = pos - zvec;
    vec3 g1, g2;
    g1.x = getTextureValue(texPosPVec[0]).a;
    g1.y = getTextureValue(texPosPVec[1]).a;
    g1.z = getTextureValue(texPosPVec[2]).a;
    g2.x = getTextureValue(texPosNVec[0]).a;
    g2.y = getTextureValue(texPosNVec[1]).a;
    g2.z = getTextureValue(texPosNVec[2]).a;
    #ifdef vtkClippingPlanesOn
      adjustClippedVoxelValues(pos, texPosPVec, g1);
      adjustClippedVoxelValues(pos, texPosNVec, g2);
    #endif
    vec4 result;
    result = vec4(g1 - g2, -1.0);
    // divide by spacing
    result.xyz /= vSpacing;
    result.w = length(result.xyz);
    if (result.w > 0.0){
      // rotate to View Coords
      rotateToViewCoord(result.xyz);
      return vec4(normalize(result.xyz),result.w);
    } else {
      return vec4(0.0);
    }
  }
#endif


#ifdef vtkImageLabelOutlineOn
  vec4 fragCoordToPCPos(vec4 fragCoord) {
    return vec4(
      (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,
      (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,
      (fragCoord.z - 0.5) * 2.0,
      1.0);
  }

  vec4 pcPosToWorldCoord(vec4 pcPos) {
    return PCWCMatrix * pcPos;
  }

  vec3 fragCoordToIndexSpace(vec4 fragCoord) {
    vec4 pcPos = fragCoordToPCPos(fragCoord);
    vec4 worldCoord = pcPosToWorldCoord(pcPos);
    vec4 vertex = (worldCoord / worldCoord.w);

    vec3 index = (vWCtoIDX * vertex).xyz;

    // half voxel fix for labelmapOutline
    return (index + vec3(0.5)) / vec3(volumeDimensions);
  }

  vec3 fragCoordToWorld(vec4 fragCoord) {
    vec4 pcPos = fragCoordToPCPos(fragCoord);
    vec4 worldCoord = pcPosToWorldCoord(pcPos);
    return worldCoord.xyz;
  }
#endif

//=======================================================================
// compute the normals and gradient magnitudes for a position
// for independent components
mat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)
{
  mat4 result;
  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;
  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;
  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;

  // divide by spacing
  distX /= vSpacing.x;
  distY /= vSpacing.y;
  distZ /= vSpacing.z;

  mat3 rot;
  rot[0] = vPlaneNormal0;
  rot[1] = vPlaneNormal2;
  rot[2] = vPlaneNormal4;

#if !defined(vtkComponent0Proportional)
  result[0].xyz = vec3(distX.r, distY.r, distZ.r);
  result[0].a = length(result[0].xyz);
  result[0].xyz *= rot;
  if (result[0].w > 0.0)
  {
    result[0].xyz /= result[0].w;
  }
#endif

// optionally compute the 2nd component
#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)
  result[1].xyz = vec3(distX.g, distY.g, distZ.g);
  result[1].a = length(result[1].xyz);
  result[1].xyz *= rot;
  if (result[1].w > 0.0)
  {
    result[1].xyz /= result[1].w;
  }
#endif

// optionally compute the 3rd component
#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)
  result[2].xyz = vec3(distX.b, distY.b, distZ.b);
  result[2].a = length(result[2].xyz);
  result[2].xyz *= rot;
  if (result[2].w > 0.0)
  {
    result[2].xyz /= result[2].w;
  }
#endif

// optionally compute the 4th component
#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)
  result[3].xyz = vec3(distX.a, distY.a, distZ.a);
  result[3].a = length(result[3].xyz);
  result[3].xyz *= rot;
  if (result[3].w > 0.0)
  {
    result[3].xyz /= result[3].w;
  }
#endif

  return result;
}

//=======================================================================
// global shadow - secondary ray
#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)
float random()
{
  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);
  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;
  uint pcg_state = floatBitsToUint(jitter);
  uint state = pcg_state;
  pcg_state = pcg_state * uint(747796405) + uint(2891336453);
  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);
  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;
}
#endif

#ifdef VolumeShadowOn
// henyey greenstein phase function
float phase_function(float cos_angle)
{
  // divide by 2.0 instead of 4pi to increase intensity
  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;
}

// Computes the intersection between a ray and a box
struct Hit
{
  float tmin;
  float tmax;
};

struct Ray
{
  vec3 origin;
  vec3 dir;
  vec3 invDir;
};

bool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)
{
  vec3 tbot = r.invDir * (boundMin - r.origin);
  vec3 ttop = r.invDir * (boundMax - r.origin);
  vec3 tmin = min(ttop, tbot);
  vec3 tmax = max(ttop, tbot);
  vec2 t = max(tmin.xx, tmin.yz);
  float t0 = max(t.x, t.y);
  t = min(tmax.xx, tmax.yz);
  float t1 = min(t.x, t.y);
  hit.tmin = t0;
  hit.tmax = t1;
  return t1 > max(t0,0.0);
}

// As BBoxIntersect requires the inverse of the ray coords,
// this function is used to avoid numerical issues
void safe_0_vector(inout Ray ray)
{
  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;
  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;
  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;
}

float volume_shadow(vec3 posIS, vec3 lightDirNormIS)
{
  float shadow = 1.0;
  float opacity = 0.0;

  // modify sample distance with a random number between 1.5 and 3.0
  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());
  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;

  // in case the first sample near surface has a very tiled light ray, we need to offset start position
  posIS += sampleDistanceISVS_jitter * lightDirNormIS;

  // compute the start and end points for the ray
  Ray ray;
  Hit hit;
  ray.origin = posIS;
  ray.dir = lightDirNormIS;
  safe_0_vector(ray);
  ray.invDir = 1.0/ray.dir;

  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))
  {
    return 1.0;
  }
  float maxdist = hit.tmax;

  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach
  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);
  maxdist = min(maxdist,maxgi);
  if(maxdist < EPSILON) {
    return 1.0;
  }

  float current_dist = 0.0;
  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);
  float clamped_step = 0.0;

  vec4 scalar = vec4(0.0);
  while(current_dist < maxdist)
  {
#ifdef vtkClippingPlanesOn
    vec3 posVC = IStoVC(posIS);
    for (int i = 0; i < clip_numPlanes; ++i)
    {
      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)
      {
        current_dist = maxdist;
      }
    }
#endif
    scalar = getTextureValue(posIS);
    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;
    #if defined(vtkGradientOpacityOn) && !defined(UseIndependentComponents)
      vec4 normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));
      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);
    #endif
    shadow *= 1.0 - opacity;

    // optimization: early termination
    if (shadow < EPSILON){
      return 0.0;
    }

    clamped_step = min(maxdist - current_dist, current_step);
    posIS += clamped_step * lightDirNormIS;
    current_dist += current_step;
  }

  return shadow;
}

vec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)
{
  vec3 vertLight = vec3(0.0);
  vec3 secondary_contrib = vec3(0.0);
  // here we assume only positional light, no effect of cones
  for (int i = 0; i < lightNum; i++)
  {
    #if(vtkLightComplexity==3)
      if (lightPositional[i] == 1){
        vertLight = lightPositionVC[i] - IStoVC(posIS);
      }else{
        vertLight = - lightDirectionVC[i];
      }
    #else
      vertLight = - lightDirectionVC[i];
    #endif
    // here we assume achromatic light, only intensity
    float dDotL = dot(viewDirectionVC, normalize(vertLight));
    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity
    float phase_attenuation = 0.5;
    if (abs(anisotropy) > EPSILON){
      phase_attenuation = phase_function(dDotL);
    }
    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));
    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;
    secondary_contrib += tColor * vAmbient;
  }
  return secondary_contrib;
}
#endif

//=======================================================================
// local ambient occlusion
#ifdef localAmbientOcclusionOn
vec3 sample_direction_uniform(int i)
{
  float rand = random() * 0.5;
  float theta = PI2 * (kernelSample[i][0] + rand);
  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;
  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));
}

// return a matrix that transform startDir into z axis; startDir should be normalized
mat3 zBaseRotationalMatrix(vec3 startDir){
  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));
  float cosA = startDir.z;
  float k = 1.0 / (1.0 + cosA);
  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,
              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,
              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);
  return matrix;
}

float computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){
  // apply LAO only at selected locations, otherwise return full brightness
  if (normal.w > 0.0 && op > 0.05){
    float total_transmittance = 0.0;
    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));
    vec3 currPos, randomDirStep;
    float weight, transmittance, opacity;
    for (int i = 0; i < kernelSize; i++)
    {
      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;
      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));
      currPos = posIS;
      transmittance = 1.0;
      for (int j = 0; j < kernelRadius ; j++){
        currPos += randomDirStep;
        // check if it's at clipping plane, if so return full brightness
        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){
          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;
          #ifdef vtkGradientOpacityOn
             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);
          #endif
          transmittance *= 1.0 - opacity;
        }
        else{
          break;
        }
      }
      total_transmittance += transmittance / float(kernelRadius) * weight;

      // early termination if fully translucent
      if (total_transmittance > 1.0 - EPSILON){
        return 1.0;
      }
    }
    // average transmittance and reduce variance
    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);
  } else {
    return 1.0;
  }
}
#endif

//=======================================================================
// surface light contribution
#if vtkLightComplexity > 0
  void applyLighting(inout vec3 tColor, vec4 normal)
  {
    vec3 diffuse = vec3(0.0, 0.0, 0.0);
    vec3 specular = vec3(0.0, 0.0, 0.0);
    float df, sf = 0.0;
    for (int i = 0; i < lightNum; i++){
        df = abs(dot(normal.rgb, -lightDirectionVC[i]));
        diffuse += df * lightColor[i];
        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);
        specular += sf * lightColor[i];
    }
    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;
  }
  #ifdef SurfaceShadowOn
  #if vtkLightComplexity < 3
    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)
    {
      // everything in VC
      vec3 diffuse = vec3(0.0);
      vec3 specular = vec3(0.0);
      #ifdef localAmbientOcclusionOn
        vec3 ambient = vec3(0.0);
      #endif
      vec3 vertLightDirection;
      for (int i = 0; i < lightNum; i++){
        float ndotL,vdotR;
        vertLightDirection = lightDirectionVC[i];
        ndotL = dot(normal.xyz, vertLightDirection);
        if (ndotL < 0.0 && twoSidedLighting)
        {
          ndotL = -ndotL;
        }
        if (ndotL > 0.0)
        {
          diffuse += ndotL * lightColor[i];
          //specular
          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
          if (vdotR > 0.0)
          {
            specular += pow(vdotR, vSpecularPower) * lightColor[i];
          }
        }
        #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
        #endif
      }
      #ifdef localAmbientOcclusionOn
        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;
      #else
        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;
      #endif
    }
  #else
    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)
    {
      // everything in VC
      vec3 diffuse = vec3(0.0);
      vec3 specular = vec3(0.0);
      #ifdef localAmbientOcclusionOn
        vec3 ambient = vec3(0.0);
      #endif
      vec3 vertLightDirection;
      for (int i = 0; i < lightNum; i++){
        float distance,attenuation,ndotL,vdotR;
        vec3 lightDir;
        if (lightPositional[i] == 1){
          lightDir = lightDirectionVC[i];
          vertLightDirection = posVC - lightPositionVC[i];
          distance = length(vertLightDirection);
          vertLightDirection = normalize(vertLightDirection);
          attenuation = 1.0 / (lightAttenuation[i].x
                              + lightAttenuation[i].y * distance
                              + lightAttenuation[i].z * distance * distance);
          // per OpenGL standard cone angle is 90 or less for a spot light
          if (lightConeAngle[i] <= 90.0){
            float coneDot = dot(vertLightDirection, lightDir);
            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone
              attenuation = attenuation * pow(coneDot, lightExponent[i]);
            }
            else {
              attenuation = 0.0;
            }
          }
          ndotL = dot(normal.xyz, vertLightDirection);
          if (ndotL < 0.0 && twoSidedLighting)
          {
            ndotL = -ndotL;
          }
          if (ndotL > 0.0)
          {
            diffuse += ndotL * attenuation * lightColor[i];
            //specular
            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
            if (vdotR > 0.0)
            {
              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];
            }
          }
          #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
          #endif
        } else {
          vertLightDirection = lightDirectionVC[i];
          ndotL = dot(normal.xyz, vertLightDirection);
          if (ndotL < 0.0 && twoSidedLighting)
          {
            ndotL = -ndotL;
          }
          if (ndotL > 0.0)
          {
            diffuse += ndotL * lightColor[i];
            //specular
            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
            if (vdotR > 0.0)
            {
              specular += pow(vdotR, vSpecularPower) * lightColor[i];
            }
          }
          #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
          #endif
        }
      }
      #ifdef localAmbientOcclusionOn
        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;
      #else
        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;
      #endif
    }
  #endif
  #endif
#endif

// LAO of surface shadows and volume shadows only work with dependent components
vec3 applyAllLightning(vec3 tColor, float alpha, vec3 posIS, vec4 normalLight) {
  #if vtkLightComplexity > 0
    // surface shadows if needed
    #ifdef SurfaceShadowOn
      #if vtkLightComplexity < 3
        vec3 tColorS = applyLightingDirectional(posIS, vec4(tColor, alpha), normalLight);
      #else
        vec3 tColorS = applyLightingPositional(posIS, vec4(tColor, alpha), normalLight, IStoVC(posIS));
      #endif
    #endif

    // volume shadows if needed
    #ifdef VolumeShadowOn
      vec3 tColorVS = applyShadowRay(tColor, posIS, rayDirVC);
    #endif

    // merge
    #ifdef VolumeShadowOn
      #ifdef SurfaceShadowOn
        // surface shadows + volumetric shadows
        float vol_coef = volumetricScatteringBlending * (1.0 - alpha / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);
        tColor = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;
      #else
        // volumetric shadows only
        tColor = tColorVS;
      #endif
    #else
      #ifdef SurfaceShadowOn
        // surface shadows only
        tColor = tColorS;
      #else
        // no shadows
        applyLighting(tColor, normal3);
      #endif
    #endif
  #endif
  return tColor;
}

  
vec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)
{

// If labeloutline and not the edge labelmap, since in the edge labelmap blend
// we need the underlying data to sample through
#if defined(vtkImageLabelOutlineOn) && !defined(vtkLabelEdgeProjectionOn)
  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space
  vec4 centerValue = getTextureValue(centerPosIS);
  bool pixelOnBorder = false;
  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));

  // Get alpha of segment from opacity function.
  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;

  int segmentIndex = int(centerValue.r * 255.0);
  
  // Use texture sampling for outlineThickness
  float textureCoordinate = float(segmentIndex - 1) / 1024.0;
  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;

  int actualThickness = int(textureValue * 255.0);


  // If it is the background (segment index 0), we should quickly bail out. 
  // Previously, this was determined by tColor.a, which was incorrect as it
  // prevented the outline from appearing when the fill is 0.
  if (segmentIndex == 0){
    return vec4(0, 0, 0, 0);
  }

  // Only perform outline check on fragments rendering voxels that aren't invisible.
  // Saves a bunch of needless checks on the background.
  // TODO define epsilon when building shader?
  for (int i = -actualThickness; i <= actualThickness; i++) {
    for (int j = -actualThickness; j <= actualThickness; j++) {
      if (i == 0 || j == 0) {
        continue;
      }

      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),
        gl_FragCoord.y + float(j),
        gl_FragCoord.z, gl_FragCoord.w);

      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);
      vec4 value = getTextureValue(neighborPosIS);

      // If any of my neighbours are not the same value as I
      // am, this means I am on the border of the segment.
      // We can break the loops
      if (any(notEqual(value, centerValue))) {
        pixelOnBorder = true;
        break;
      }
    }

    if (pixelOnBorder == true) {
      break;
    }
  }

  // If I am on the border, I am displayed at full opacity
  if (pixelOnBorder == true) {
    tColor.a = outlineOpacity;
  }

  return tColor;

#else
  // compute the normal and gradient magnitude if needed
  // We compute it as a vec4 if possible otherwise a mat4

  #ifdef UseIndependentComponents

    // sample textures
    vec3 tColor0 = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0)).rgb;
    float pwfValue0 = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;

    #if vtkNumComponents > 1
      vec3 tColor1 = texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;
      float pwfValue1 = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;

      #if vtkNumComponents > 2
        vec3 tColor2 = texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;
        float pwfValue2 = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;

        #if vtkNumComponents > 3
          vec3 tColor3 = texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;
          float pwfValue3 = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;
        #endif
      #endif
    #endif

    #if !defined(vtkCustomComponentsColorMix)
      // default path for component color mix

      // compute the normal vectors as needed
      #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)
        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
      #endif

      // compute gradient opacity factors as needed
      vec4 goFactor = vec4(1.0, 1.0 ,1.0 ,1.0);
      #if defined(vtkGradientOpacityOn)
        #if !defined(vtkComponent0Proportional)
          goFactor.x =
            computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);
        #endif
        #if vtkNumComponents > 1
          #if !defined(vtkComponent1Proportional)
            goFactor.y =
              computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);
          #endif
          #if vtkNumComponents > 2
            #if !defined(vtkComponent2Proportional)
              goFactor.z =
                computeGradientOpacityFactor(normalMat[2].a, goscale2, goshift2, gomin2, gomax2);
            #endif
            #if vtkNumComponents > 3
              #if !defined(vtkComponent3Proportional)
                goFactor.w =
                  computeGradientOpacityFactor(normalMat[3].a, goscale3, goshift3, gomin3, gomax3);
              #endif
            #endif
          #endif
        #endif
      #endif

      // process color and opacity for each component
      #if !defined(vtkComponent0Proportional)
        float alpha = goFactor.x*mix0*pwfValue0;
        #if vtkLightComplexity > 0
          applyLighting(tColor0, normalMat[0]);
        #endif
      #else
        tColor0 *= pwfValue0;
        float alpha = mix(pwfValue0, 1.0, (1.0 - mix0));
      #endif

      #if vtkNumComponents > 1
        #if !defined(vtkComponent1Proportional)
          alpha += goFactor.y*mix1*pwfValue1;
          #if vtkLightComplexity > 0
            applyLighting(tColor1, normalMat[1]);
          #endif
        #else
          tColor1 *= pwfValue1;
          alpha *= mix(pwfValue1, 1.0, (1.0 - mix1));
        #endif

        #if vtkNumComponents > 2
          #if !defined(vtkComponent2Proportional)
            alpha += goFactor.z*mix2*pwfValue2;
            #if vtkLightComplexity > 0
              applyLighting(tColor2, normalMat[2]);
            #endif
          #else
            tColor2 *= pwfValue2;
            alpha *= mix(pwfValue2, 1.0, (1.0 - mix2));
          #endif
        #endif

        #if vtkNumComponents > 3
          #if !defined(vtkComponent3Proportional)
            alpha += goFactor.w*mix3*pwfValue3;
            #if vtkLightComplexity > 0
              applyLighting(tColor3, normalMat[3]);
            #endif
          #else
            tColor3 *= pwfValue3;
            alpha *= mix(pwfValue3, 1.0, (1.0 - mix3));
          #endif
        #endif
      #endif

      // perform final independent blend
      vec3 tColor = mix0 * tColor0;
      #if vtkNumComponents > 1
        tColor += mix1 * tColor1;
        #if vtkNumComponents > 2
          tColor += mix2 * tColor2;
          #if vtkNumComponents > 3
            tColor += mix3 * tColor3;
          #endif
        #endif
      #endif

      return vec4(tColor, alpha);
    #else
      /*
       * Mix the color information from all the independent components to get a single rgba output
       * Gradient opactity factors and normals are not computed
       *
       * You can compute these using:
       * - computeMat4Normal: always available, compute normal only for non proportional components, used by default independent component mix
       * - computeDensityNormal & computeNormalForDensity: available if ((LightComplexity > 0) || GradientOpacityOn) && ComputeNormalFromOpacity),
       *                                                   used by dependent component color mix, see code for Additive preset in OpenGl/VolumeMapper
       * - computeGradientOpacityFactor: always available, used in a lot of places
       *
       * Using applyAllLightning() is advised for shading but some features don't work well with it (volume shadows, LAO)
       * mix0, mix1, ... are defined for each component that is used and correspond to the componentWeight
       */
      //VTK::CustomComponentsColorMix::Impl
    #endif
  #else
    // dependent components

    // compute normal if needed
    #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)
      // use component 3 of the opacity texture as getTextureValue() sets alpha to the opacity value
      #ifdef vtkComputeNormalFromOpacity
        vec3 scalarInterp[2];
        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp, 3);
      #else
        vec4 normal0 = computeNormal(posIS, tstep);
      #endif
    #endif

    // compute gradient opacity factor enabled
    #if defined(vtkGradientOpacityOn)
      float gradientOpacity = computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);
    #else
      const float gradientOpacity = 1.0;
    #endif

    // get color and opacity
    #if vtkNumComponents == 1
      vec3 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5)).rgb;
      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;
      if (alpha < EPSILON){
        return vec4(0.0);
      }
    #endif
    #if vtkNumComponents == 2
      vec3 tColor = vec3(tValue.r * cscale0 + cshift0);
      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;
    #endif
    #if vtkNumComponents == 3
      vec3 tColor;
      tColor.r = tValue.r * cscale0 + cshift0;
      tColor.g = tValue.g * cscale1 + cshift1;
      tColor.b = tValue.b * cscale2 + cshift2;
      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;
    #endif
    #if vtkNumComponents == 4
      vec3 tColor;
      tColor.r = tValue.r * cscale0 + cshift0;
      tColor.g = tValue.g * cscale1 + cshift1;
      tColor.b = tValue.b * cscale2 + cshift2;
      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;
    #endif

    // lighting
    #if (vtkLightComplexity > 0)
      #ifdef vtkComputeNormalFromOpacity
        vec4 normalLight;
        if (!all(equal(normal0, vec4(0.0)))) {
          scalarInterp[0] = scalarInterp[0] * oscale0 + oshift0;
          scalarInterp[1] = scalarInterp[1] * oscale0 + oshift0;
          normalLight = computeDensityNormal(scalarInterp, 0.5, gradientOpacity);
          if (all(equal(normalLight, vec4(0.0)))) {
            normalLight = normal0;
          }
        }
      #else
        vec4 normalLight = normal0;
      #endif
      tColor = applyAllLightning(tColor, alpha, posIS, normalLight);
    #endif

    return vec4(tColor, alpha);
  #endif // dependent
#endif
}

bool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {
  bool withinRange = false;
  #if vtkNumComponents == 1
    if (val.r >= min.r && val.r <= max.r) {
      withinRange = true;
    }
  #else
    #ifdef UseIndependentComponents
      #if vtkNumComponents == 2
        if (val.r >= min.r && val.r <= max.r &&
            val.g >= min.g && val.g <= max.g) {
          withinRange = true;
        }
      #else
        if (all(greaterThanEqual(val, ipScalarRangeMin)) &&
            all(lessThanEqual(val, ipScalarRangeMax))) {
          withinRange = true;
        }
      #endif
    #endif
  #endif
  return withinRange;
}

#if vtkBlendMode == 6 
bool checkOnEdgeForNeighbor(int i, int j, int s, vec3 stepIS) {
    vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i), gl_FragCoord.y + float(j), gl_FragCoord.z, gl_FragCoord.w);
    vec3 originalNeighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);

    bool justSawIt = false;

    vec3 neighborPosIS = originalNeighborPosIS;

    float stepsTraveled = 0.0;


    // float neighborValue;
    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {
        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));
        vec4 texValue = texelFetch(texture1, texCoord, 0);

        if (int(texValue.g) == s) {
            justSawIt = true;
            break;
        }
        neighborPosIS += stepIS;
    }

    if (justSawIt){
      return false;
    }

   
    neighborPosIS = originalNeighborPosIS;
    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {
        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));
        vec4 texValue = texelFetch(texture1, texCoord, 0);

        if (int(texValue.g) == s) {
            justSawIt = true;
            break;
        }
        neighborPosIS -= stepIS;
    }


    if (!justSawIt) {
        // onedge
        vec3 tColorSegment = texture2D(ctexture, vec2(float(s) * cscale1 + cshift1, height1)).rgb;
        float pwfValueSegment = texture2D(otexture, vec2(float(s) * oscale1 + oshift1, height1)).r;
        gl_FragData[0] = vec4(tColorSegment, pwfValueSegment);
        return true;
    }

    // not on edge
    return false;
}

#endif


//=======================================================================
// Apply the specified blend mode operation along the ray's path.
//
void applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)
{
  vec3 tstep = 1.0/tdims;

  // start slightly inside and apply some jitter
  vec3 delta = endIS - posIS;
  vec3 stepIS = normalize(delta)*sampleDistanceIS;
  float raySteps = length(delta)/sampleDistanceIS;

  // Initialize arrays to false
  // avoid 0.0 jitter
  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;
  float stepsTraveled = jitter;

  // local vars for the loop
  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);
  vec4 tValue;
  vec4 tColor;

  // if we have less than one step then pick the middle point
  // as our value
  // if (raySteps <= 1.0)
  // {
  //   posIS = (posIS + endIS)*0.5;
  // }

  // Perform initial step at the volume boundary
  // compute the scalar
  tValue = getTextureValue(posIS);
  
  #if vtkBlendMode == 6 
    if (raySteps <= 1.0)
    {
      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);
      return;
    }

    vec4 value = tValue;
    posIS += (jitter*stepIS);
    vec3 maxPosIS = posIS; // Store the position of the max value
    int segmentIndex = int(value.g);
    bool originalPosHasSeenNonZero = false;

    uint bitmask = 0u;

    if (segmentIndex != 0) {
      // Tried using the segment index in an boolean array but reading 
      // from the array by dynamic indexing was horrondously slow
      // so use bit masking instead and assign 1 to the bit corresponding to the segment index
      // and later check if the bit is set via bit operations
      setBit(segmentIndex);
    }
    
    // Sample along the ray until MaximumSamplesValue,
    // ending slightly inside the total distance
    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      // If we have reached the last step, break
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);
      segmentIndex = int(tValue.g);

      if (segmentIndex != 0) {
        originalPosHasSeenNonZero = true;
        setBit(segmentIndex);
      }

      if (tValue.r > value.r) {
        value =  tValue; // Update the max value
        maxPosIS = posIS; // Update the position where max occurred
      }

      // Otherwise, continue along the ray
      stepsTraveled++;
      posIS += stepIS;
    }

    // Perform the last step along the ray using the
    // residual distance
    posIS = endIS;
    tValue = getTextureValue(posIS);

    if (tValue.r > value.r) {
      value = tValue; // Update the max value
      maxPosIS = posIS; // Update the position where max occurred
    }  

    // If we have not seen any non-zero segments, we can return early
    // and grab color from the actual center value first component (image)
    if (!originalPosHasSeenNonZero) {
      gl_FragData[0] = getColorForValue(value, maxPosIS, tstep);
      return;
    }

    // probably we can make this configurable but for now we will use the same
    // sample distance as the original sample distance
    float neighborSampleDistanceIS = sampleDistanceIS;

    vec3 neighborRayStepsIS = stepIS;
    float neighborRaySteps = raySteps;
    bool shouldLookInAllNeighbors = false;

    float minVoxelSpacing = min(volumeSpacings[0], min(volumeSpacings[1], volumeSpacings[2]));
    vec4 base = vec4(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);

    vec4 baseXPlus = vec4(gl_FragCoord.x + 1.0, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);
    vec4 baseYPlus = vec4(gl_FragCoord.x, gl_FragCoord.y + 1.0, gl_FragCoord.z, gl_FragCoord.w);

    vec3 baseWorld = fragCoordToWorld(base);
    vec3 baseXPlusWorld = fragCoordToWorld(baseXPlus);
    vec3 baseYPlusWorld = fragCoordToWorld(baseYPlus);

    float XPlusDiff = length(baseXPlusWorld - baseWorld);
    float YPlusDiff = length(baseYPlusWorld - baseWorld);

    float minFragSpacingWorld = min(XPlusDiff, YPlusDiff);

    for (int s = 1; s < MAX_SEGMENT_INDEX; s++) {
      // bail out quickly if the segment index has not 
      // been seen by the center segment
      if (!isBitSet(s)) {
       continue;
      }

      // Use texture sampling for outlineThickness so that we can have 
      // per segment thickness
      float textureCoordinate = float(s - 1) / 1024.0;
      float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;

      int actualThickness = int(textureValue * 255.0);

      // check the extreme points in the neighborhood since there is a better
      // chance of finding the edge there, so that we can bail out 
      // faster if we find the edge
      bool onEdge =
          checkOnEdgeForNeighbor(-actualThickness, -actualThickness, s, stepIS) ||
          checkOnEdgeForNeighbor(actualThickness, actualThickness, s, stepIS) ||
          checkOnEdgeForNeighbor(actualThickness, -actualThickness, s, stepIS) ||
          checkOnEdgeForNeighbor(-actualThickness, +actualThickness, s, stepIS);

      if (onEdge) {
        return;
      }

      // since the next step is computationally expensive, we need to perform
      // some optimizations to avoid it if possible. One of the optimizations
      // is to check the whether the minimum of the voxel spacing is greater than 
      // the 2 * the thickness of the outline segment. If that is the case
      // then we can safely skip the next step since we can be sure that the
      // the previous 4 checks on the extreme points would caught the entirety 
      // of the all the fragments inside. i.e., this happens when we zoom out, 
      if (minVoxelSpacing > (2.0 * float(actualThickness) - 1.0) * minFragSpacingWorld) {
        continue;
      }
      
      // Loop through the rest, skipping the processed extremes and the center
      for (int i = -actualThickness; i <= actualThickness; i++) {
            for (int j = -actualThickness; j <= actualThickness; j++) {
                if (i == 0 && j == 0) continue; // Skip the center
                if (abs(i) == actualThickness && abs(j) == actualThickness) continue; // Skip corners
                if (checkOnEdgeForNeighbor(i, j, s, stepIS )) {
                    return;
                }
          }
      }
    }

    vec3 tColor0 = texture2D(ctexture, vec2(value.r * cscale0 + cshift0, height0)).rgb;
    float pwfValue0 = texture2D(otexture, vec2(value.r * oscale0 + oshift0, height0)).r;
    gl_FragData[0] = vec4(tColor0, pwfValue0);
  #endif
  #if vtkBlendMode == 0 // COMPOSITE_BLEND
    // now map through opacity and color
    tColor = getColorForValue(tValue, posIS, tstep);

    // handle very thin volumes
    if (raySteps <= 1.0)
    {
      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);
      gl_FragData[0] = tColor;
      return;
    }

    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);
    color = vec4(tColor.rgb*tColor.a, tColor.a);
    posIS += (jitter*stepIS);

    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // now map through opacity and color
      tColor = getColorForValue(tValue, posIS, tstep);

      float mix = (1.0 - color.a);

      // this line should not be needed but nvidia seems to not handle
      // the break correctly on windows/chrome 58 angle
      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));

      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;
      stepsTraveled++;
      posIS += stepIS;
      if (color.a > 0.99) { color.a = 1.0; break; }
    }

    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)
    {
      posIS = endIS;

      // compute the scalar
      tValue = getTextureValue(posIS);

      // now map through opacity and color
      tColor = getColorForValue(tValue, posIS, tstep);
      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);

      float mix = (1.0 - color.a);
      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;
    }

    gl_FragData[0] = vec4(color.rgb/color.a, color.a);
  #endif
  #if vtkBlendMode == 1 || vtkBlendMode == 2
    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND
    // Find maximum/minimum intensity along the ray.

    // Define the operation we will use (min or max)
    #if vtkBlendMode == 1
    #define OP max
    #else
    #define OP min
    #endif

    // If the clipping range is shorter than the sample distance
    // we can skip the sampling loop along the ray.
    if (raySteps <= 1.0)
    {
      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);
      return;
    }

    vec4 value = tValue;
    posIS += (jitter*stepIS);

    // Sample along the ray until MaximumSamplesValue,
    // ending slightly inside the total distance
    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      // If we have reached the last step, break
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // Update the maximum value if necessary
      value = OP(tValue, value);

      // Otherwise, continue along the ray
      stepsTraveled++;
      posIS += stepIS;
    }

    // Perform the last step along the ray using the
    // residual distance
    posIS = endIS;
    tValue = getTextureValue(posIS);
    value = OP(tValue, value);

    // Now map through opacity and color
    gl_FragData[0] = getColorForValue(value, posIS, tstep);
  #endif
  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND
    vec4 sum = vec4(0.);

    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
      sum += tValue;
    }

    if (raySteps <= 1.0) {
      gl_FragData[0] = getColorForValue(sum, posIS, tstep);
      return;
    }

    posIS += (jitter*stepIS);

    // Sample along the ray until MaximumSamplesValue,
    // ending slightly inside the total distance
    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      // If we have reached the last step, break
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.
      // Notes:
      // - We are comparing all values in the texture to see if any of them
      //   are outside of the scalar range. In the future we might want to allow
      //   scalar ranges for each component.
      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
        // Sum the values across each step in the path
        sum += tValue;
      }
      stepsTraveled++;
      posIS += stepIS;
    }

    // Perform the last step along the ray using the
    // residual distance
    posIS = endIS;

    // compute the scalar
    tValue = getTextureValue(posIS);

    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation
    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
      sum += tValue;

      stepsTraveled++;
    }

    #if vtkBlendMode == 3 // Average
      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);
    #endif

    gl_FragData[0] = getColorForValue(sum, posIS, tstep);
  #endif
  #if vtkBlendMode == 5 // RADON
    float normalizedRayIntensity = 1.0;

    // handle very thin volumes
    if (raySteps <= 1.0)
    {
      tValue = getTextureValue(posIS);
      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;
      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));
      return;
    }

    posIS += (jitter*stepIS);

    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar value
      tValue = getTextureValue(posIS);

      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity
      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;

      posIS += stepIS;
      stepsTraveled++;
    }

    // map normalizedRayIntensity to color
    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));

  #endif
}

//=======================================================================
// Compute a new start and end point for a given ray based
// on the provided bounded clipping plane (aka a rectangle)
void getRayPointIntersectionBounds(
  vec3 rayPos, vec3 rayDir,
  vec3 planeDir, float planeDist,
  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,
  float vSize1, float vSize2)
{
  float result = dot(rayDir, planeDir);
  if (abs(result) < 1e-6)
  {
    return;
  }
  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;
  vec3 xposVC = rayPos + rayDir*result;
  vec3 vxpos = xposVC - vOriginVC;
  vec2 vpos = vec2(
    dot(vxpos, vPlaneX),
    dot(vxpos, vPlaneY));

  // on some apple nvidia systems this does not work
  // if (vpos.x < 0.0 || vpos.x > vSize1 ||
  //     vpos.y < 0.0 || vpos.y > vSize2)
  // even just
  // if (vpos.x < 0.0 || vpos.y < 0.0)
  // fails
  // so instead we compute a value that represents in and out
  //and then compute the return using this value
  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds
  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out

  tbounds = mix(
   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value
   tbounds, // out value
   check);  // 0 in 1 out
}

//=======================================================================
// given a
// - ray direction (rayDir)
// - starting point (vertexVCVSOutput)
// - bounding planes of the volume
// - optionally depth buffer values
// - far clipping plane
// compute the start/end distances of the ray we need to cast
vec2 computeRayDistances(vec3 rayDir, vec3 tdims)
{
  vec2 dists = vec2(100.0*camFar, -1.0);

  vec3 vSize = vSpacing*tdims;

  // all this is in View Coordinates
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,
    vSize.y, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,
    vSize.y, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,
    vSize.x, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,
    vSize.x, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,
    vSize.x, vSize.y);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,
    vSize.x, vSize.y);

  //VTK::ClipPlane::Impl

  // do not go behind front clipping plane
  dists.x = max(0.0,dists.x);

  // do not go PAST far clipping plane
  float farDist = -camThick/rayDir.z;
  dists.y = min(farDist,dists.y);

  // Do not go past the zbuffer value if set
  // This is used for intermixing opaque geometry
  //VTK::ZBuffer::Impl

  return dists;
}

//=======================================================================
// Compute the index space starting position (pos) and end
// position
//
void computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)
{
  // compute starting and ending values in volume space
  pos = vertexVCVSOutput + dists.x*rayDir;
  pos = pos - vOriginVC;
  // convert to volume basis and origin
  pos = vec3(
    dot(pos, vPlaneNormal0),
    dot(pos, vPlaneNormal2),
    dot(pos, vPlaneNormal4));

  endPos = vertexVCVSOutput + dists.y*rayDir;
  endPos = endPos - vOriginVC;
  endPos = vec3(
    dot(endPos, vPlaneNormal0),
    dot(endPos, vPlaneNormal2),
    dot(endPos, vPlaneNormal4));

  float delta = length(endPos - pos);

  pos *= vVCToIJK;
  endPos *= vVCToIJK;

  float delta2 = length(endPos - pos);
  sampleDistanceIS = sampleDistance*delta2/delta;
  #ifdef VolumeShadowOn
    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;
  #endif
}

void main()
{

  if (cameraParallel == 1)
  {
    // Camera is parallel, so the rayDir is just the direction of the camera.
    rayDirVC = vec3(0.0, 0.0, -1.0);
  } else {
    // camera is at 0,0,0 so rayDir for perspective is just the vc coord
    rayDirVC = normalize(vertexVCVSOutput);
  }

  vec3 tdims = vec3(volumeDimensions);

  // compute the start and end points for the ray
  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);

  // do we need to composite? aka does the ray have any length
  // If not, bail out early
  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)
  {
    discard;
  }

  // IS = Index Space
  vec3 posIS;
  vec3 endIS;
  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);

  // Perform the blending operation along the ray
  applyBlend(posIS, endIS, tdims);
}
`;const{vtkWarningMacro:py,vtkErrorMacro:Ba}=We;function hy(t){switch(t){case br.CUSTOM:return"//VTK::CustomColorMix";case br.ADDITIVE:return`
        // compute normals
        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)
          vec3 scalarInterp0[2];
          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);
          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;
          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;
          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);

          vec3 scalarInterp1[2];
          vec4 normalLight1 = computeNormalForDensity(posIS, tstep, scalarInterp1, 1);
          scalarInterp1[0] = scalarInterp1[0] * oscale1 + oshift1;
          scalarInterp1[1] = scalarInterp1[1] * oscale1 + oshift1;
          normalLight1 = computeDensityNormal(scalarInterp1, height1, 1.0);
        #else
          vec4 normalLight0 = normalMat[0];
          vec4 normalLight1 = normalMat[1];
        #endif

        // compute opacities
        float opacity0 = pwfValue0;
        float opacity1 = pwfValue1;
        #ifdef vtkGradientOpacityOn
          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);
          opacity0 *= gof0;
          float gof1 = computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);
          opacity1 *= gof1;
        #endif
        float opacitySum = opacity0 + opacity1;
        if (opacitySum <= 0.0) {
          return vec4(0.0);
        }

        // mix the colors and opacities
        tColor0 = applyAllLightning(tColor0, opacity0, posIS, normalLight0);
        tColor1 = applyAllLightning(tColor1, opacity1, posIS, normalLight1);
        vec3 mixedColor = (opacity0 * tColor0 + opacity1 * tColor1) / opacitySum;
        return vec4(mixedColor, min(1.0, opacitySum));
`;case br.COLORIZE:return`
        // compute normals
        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)
          vec3 scalarInterp0[2];
          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);
          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;
          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;
          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);
        #else
          vec4 normalLight0 = normalMat[0];
        #endif

        // compute opacities
        float opacity0 = pwfValue0;
        #ifdef vtkGradientOpacityOn
          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);
          opacity0 *= gof0;
        #endif

        // mix the colors and opacities
        vec3 color = tColor0 * mix(vec3(1.0), tColor1, pwfValue1);
        color = applyAllLightning(color, opacity0, posIS, normalLight0);
        return vec4(color, opacity0);
`;default:return null}}function dy(t,e){e.classHierarchy.push("vtkOpenGLVolumeMapper");function r(a){[e._scalars,e._scalarOpacityFunc,e._colorTransferFunc,e._labelOutlineThicknessArray].forEach(i=>a.unregisterGraphicsResourceUser(i,t))}t.buildPass=()=>{e.zBufferTexture=null},t.zBufferPass=(a,i)=>{if(a){const s=i.getZBufferTexture();s!==e.zBufferTexture&&(e.zBufferTexture=s)}},t.opaqueZBufferPass=(a,i)=>t.zBufferPass(a,i),t.volumePass=(a,i)=>{if(a){const s=e._openGLRenderWindow;e._openGLRenderWindow=t.getLastAncestorOfType("vtkOpenGLRenderWindow"),s&&!s.isDeleted()&&s!==e._openGLRenderWindow&&r(s),e.context=e._openGLRenderWindow.getContext(),e.tris.setOpenGLRenderWindow(e._openGLRenderWindow),e.jitterTexture.setOpenGLRenderWindow(e._openGLRenderWindow),e.framebuffer.setOpenGLRenderWindow(e._openGLRenderWindow),e.openGLVolume=t.getFirstAncestorOfType("vtkOpenGLVolume");const o=e.openGLVolume.getRenderable();e._openGLRenderer=t.getFirstAncestorOfType("vtkOpenGLRenderer");const c=e._openGLRenderer.getRenderable();e.openGLCamera=e._openGLRenderer.getViewNodeFor(c.getActiveCamera()),t.renderPiece(c,o)}},t.getShaderTemplate=(a,i,s)=>{a.Vertex=gy,a.Fragment=ly,a.Geometry=""},t.useIndependentComponents=a=>{var u,g;const i=a.getIndependentComponents(),s=e.currentInput,o=(g=(u=s==null?void 0:s.getPointData())==null?void 0:u.getScalars())==null?void 0:g.getNumberOfComponents(),c=a.getColorMixPreset();return i&&o>=2||!!c},t.replaceShaderValues=(a,i,s)=>{const o=s.getProperty();let c=a.Fragment;o.getInterpolationType()===di.LINEAR&&(c=V.substitute(c,"//VTK::TrilinearOn","#define vtkTrilinearOn").result),t.isLabelmapOutlineRequired(s)===!0&&(c=V.substitute(c,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result),e.renderable.getBlendMode()===Kr.LABELMAP_EDGE_PROJECTION_BLEND&&(c=V.substitute(c,"//VTK::LabelEdgeProjectionOn","#define vtkLabelEdgeProjectionOn").result);const l=e.scalarTexture.getComponents();c=V.substitute(c,"//VTK::NumComponents",`#define vtkNumComponents ${l}`).result;const p=t.useIndependentComponents(o);p&&(c=V.substitute(c,"//VTK::IndependentComponentsOn","#define UseIndependentComponents").result);const d=[],h=[];for(let w=0;w<l;w++)o.getOpacityMode(w)===hf.PROPORTIONAL&&d.push(`#define vtkComponent${w}Proportional`),o.getForceNearestInterpolation(w)&&h.push(`#define vtkComponent${w}ForceNearest`);c=V.substitute(c,"//VTK::vtkProportionalComponents",d.join(`
`)).result,c=V.substitute(c,"//VTK::vtkForceNearestComponents",h.join(`
`)).result;const T=o.getColorMixPreset(),v=hy(T);v&&(c=V.substitute(c,"//VTK::CustomComponentsColorMixOn","#define vtkCustomComponentsColorMix").result,c=V.substitute(c,"//VTK::CustomComponentsColorMix::Impl",v).result);const C=e.currentInput.getSpatialExtent(),S=e.currentInput.getSpacing(),x=new Float64Array(3);oe(x,(C[1]-C[0])*S[0],(C[3]-C[2])*S[1],(C[5]-C[4])*S[2]);const R=jn(x)/t.getCurrentSampleDistance(i);c=V.substitute(c,"//VTK::MaximumSamplesValue",`${Math.ceil(R)}`).result,c=V.substitute(c,"//VTK::LightComplexity",`#define vtkLightComplexity ${e.lightComplexity}`).result,e.lightComplexity>0&&(e.renderable.getVolumetricScatteringBlending()>0&&(c=V.substitute(c,"//VTK::VolumeShadowOn","#define VolumeShadowOn").result),e.renderable.getVolumetricScatteringBlending()<1&&(c=V.substitute(c,"//VTK::SurfaceShadowOn","#define SurfaceShadowOn").result),e.renderable.getLocalAmbientOcclusion()&&o.getAmbient()>0&&(c=V.substitute(c,"//VTK::localAmbientOcclusionOn","#define localAmbientOcclusionOn").result));const O=p?l:1;e.gopacity=!1;for(let w=0;!e.gopacity&&w<O;++w)e.gopacity||(e.gopacity=o.getUseGradientOpacity(w));e.gopacity&&(c=V.substitute(c,"//VTK::GradientOpacityOn","#define vtkGradientOpacityOn").result),e.renderable.getComputeNormalFromOpacity()&&(c=V.substitute(c,"//VTK::vtkComputeNormalFromOpacity","#define vtkComputeNormalFromOpacity").result),e.zBufferTexture!==null&&(c=V.substitute(c,"//VTK::ZBuffer::Dec",["uniform sampler2D zBufferTexture;","uniform float vpZWidth;","uniform float vpZHeight;"]).result,c=V.substitute(c,"//VTK::ZBuffer::Impl",["vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));","float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;","zdepth = zdepth * 2.0 - 1.0;","if (cameraParallel == 0) {","zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}","else {",`zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}
`,"zdepth = -zdepth/rayDir.z;","dists.y = min(zdepth,dists.y);"]).result),c=V.substitute(c,"//VTK::BlendMode",`${e.renderable.getBlendMode()}`).result,a.Fragment=c,t.replaceShaderLight(a,i,s),t.replaceShaderClippingPlane(a,i,s)},t.replaceShaderLight=(a,i,s)=>{if(e.lightComplexity===0)return;let o=a.Fragment,c=0;i.getLights().forEach(u=>{u.getSwitch()&&(c+=1)}),o=V.substitute(o,"//VTK::Light::Dec",["uniform int lightNum;","uniform bool twoSidedLighting;",`uniform vec3 lightColor[${c}];`,`uniform vec3 lightDirectionVC[${c}]; // normalized`,`uniform vec3 lightHalfAngleVC[${c}];`,"//VTK::Light::Dec"],!1).result,e.lightComplexity===3&&(o=V.substitute(o,"//VTK::Light::Dec",[`uniform vec3 lightPositionVC[${c}];`,`uniform vec3 lightAttenuation[${c}];`,`uniform float lightConeAngle[${c}];`,`uniform float lightExponent[${c}];`,`uniform int lightPositional[${c}];`],!1).result),e.renderable.getVolumetricScatteringBlending()>0&&(o=V.substitute(o,"//VTK::VolumeShadow::Dec",["uniform float volumetricScatteringBlending;","uniform float giReach;","uniform float volumeShadowSamplingDistFactor;","uniform float anisotropy;","uniform float anisotropy2;"],!1).result),e.renderable.getLocalAmbientOcclusion()&&s.getProperty().getAmbient()>0&&(o=V.substitute(o,"//VTK::LAO::Dec",["uniform int kernelRadius;",`uniform vec2 kernelSample[${e.renderable.getLAOKernelRadius()}];`,"uniform int kernelSize;"],!1).result),a.Fragment=o},t.replaceShaderClippingPlane=(a,i,s)=>{let o=a.Fragment;if(e.renderable.getClippingPlanes().length>0){const c=e.renderable.getClippingPlanes().length;o=V.substitute(o,"//VTK::ClipPlane::Dec",["uniform vec3 vClipPlaneNormals[6];","uniform float vClipPlaneDistances[6];","uniform vec3 vClipPlaneOrigins[6];","uniform int clip_numPlanes;","//VTK::ClipPlane::Dec","#define vtkClippingPlanesOn"],!1).result,o=V.substitute(o,"//VTK::ClipPlane::Impl",[`for(int i = 0; i < ${c}; i++) {`,"  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);","  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];","  if (rayDirRatio == 0.0)","  {","    if (equationResult < 0.0) dists.x = dists.y;","    continue;","  }","  float result = -1.0 * equationResult / rayDirRatio;","  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);","  else dists.x = max(dists.x, result);","}","//VTK::ClipPlane::Impl"],!1).result}a.Fragment=o};const n=(a,i)=>{let s=0;a.getProperty().getShade()&&e.renderable.getBlendMode()===Kr.COMPOSITE_BLEND&&(s=0,e.numberOfLights=0,i.forEach(o=>{o.getSwitch()>0&&(e.numberOfLights++,s===0&&(s=1)),s===1&&(e.numberOfLights>1||o.getIntensity()!==1||!o.lightTypeIsHeadLight())&&(s=2),s<3&&o.getPositional()&&(s=3)})),s!==e.lightComplexity&&(e.lightComplexity=s,t.modified())};t.getNeedToRebuildShaders=(a,i,s)=>{var v;const o=s.getProperty();n(s,i.getLights());const c=e.scalarTexture.getComponents(),u=[],g=[];for(let C=0;C<c;C++)u.push(o.getOpacityMode(C)),g.push(o.getForceNearestInterpolation(C));const f=e.currentInput.getSpatialExtent(),l=e.currentInput.getSpacing(),p=new Float64Array(3);oe(p,(f[1]-f[0])*l[0],(f[3]-f[2])*l[1],(f[5]-f[4])*l[2]);const d=jn(p)/t.getCurrentSampleDistance(i),h=!!e.zBufferTexture,T={iComps:o.getIndependentComponents(),colorMixPreset:o.getColorMixPreset(),interpolationType:o.getInterpolationType(),useLabelOutline:t.isLabelmapOutlineRequired(s),numComp:c,maxSamples:d,useGradientOpacity:o.getUseGradientOpacity(0),blendMode:e.renderable.getBlendMode(),hasZBufferTexture:h,opacityModes:u,forceNearestInterps:g};return((v=a.getProgram())==null?void 0:v.getHandle())===0||a.getShaderSourceTime().getMTime()<t.getMTime()||a.getShaderSourceTime().getMTime()<e.renderable.getMTime()||!e.previousState||!No(e.previousState,T)?(e.previousState=T,!0):!1},t.updateShaders=(a,i,s)=>{if(t.getNeedToRebuildShaders(a,i,s)){const o={Vertex:null,Fragment:null,Geometry:null};t.buildShaders(o,i,s);const c=e._openGLRenderWindow.getShaderCache().readyShaderProgramArray(o.Vertex,o.Fragment,o.Geometry);c!==a.getProgram()&&(a.setProgram(c),a.getVAO().releaseGraphicsResources()),a.getShaderSourceTime().modified()}else e._openGLRenderWindow.getShaderCache().readyShaderProgram(a.getProgram());a.getVAO().bind(),t.setMapperShaderParameters(a,i,s),t.setCameraShaderParameters(a,i,s),t.setPropertyShaderParameters(a,i,s),t.getClippingPlaneShaderParameters(a,i,s)},t.setMapperShaderParameters=(a,i,s)=>{var g;const o=a.getProgram();a.getCABO().getElementCount()&&(e.VBOBuildTime.getMTime()>a.getAttributeUpdateTime().getMTime()||a.getShaderSourceTime().getMTime()>a.getAttributeUpdateTime().getMTime())&&(o.isAttributeUsed("vertexDC")&&(a.getVAO().addAttributeArray(o,a.getCABO(),"vertexDC",a.getCABO().getVertexOffset(),a.getCABO().getStride(),e.context.FLOAT,3,e.context.FALSE)||Ba("Error setting vertexDC in shader VAO.")),a.getAttributeUpdateTime().modified()),o.setUniformi("texture1",e.scalarTexture.getTextureUnit()),o.setUniformf("sampleDistance",t.getCurrentSampleDistance(i));const c=e.scalarTexture.getVolumeInfo(),u=e.renderable.getIpScalarRange();if((g=c==null?void 0:c.dataComputedScale)!=null&&g.length){const f=[],l=[];for(let p=0;p<4;p++)f[p]=u[0]*c.dataComputedScale[p]+c.dataComputedOffset[p],l[p]=u[1]*c.dataComputedScale[p]+c.dataComputedOffset[p],f[p]=(f[p]-c.offset[p])/c.scale[p],l[p]=(l[p]-c.offset[p])/c.scale[p];o.setUniform4f("ipScalarRangeMin",f[0],f[1],f[2],f[3]),o.setUniform4f("ipScalarRangeMax",l[0],l[1],l[2],l[3])}if(e.zBufferTexture!==null){o.setUniformi("zBufferTexture",e.zBufferTexture.getTextureUnit());const f=e._useSmallViewport?[e._smallViewportWidth,e._smallViewportHeight]:e._openGLRenderWindow.getFramebufferSize();o.setUniformf("vpZWidth",f[0]),o.setUniformf("vpZHeight",f[1])}},t.setCameraShaderParameters=(a,i,s)=>{const o=e.openGLCamera.getKeyMatrices(i),c=e.openGLVolume.getKeyMatrices();ae(e.modelToView,o.wcvc,c.mcwc);const u=a.getProgram(),g=e.openGLCamera.getRenderable(),f=g.getClippingRange();u.setUniformf("camThick",f[1]-f[0]),u.setUniformf("camNear",f[0]),u.setUniformf("camFar",f[1]);const l=e.currentInput.getBounds(),p=e.currentInput.getDimensions(),d=new Float64Array(3),h=new Float64Array(3);let T=1,v=-1,C=1,S=-1;for(let F=0;F<8;++F){if(oe(d,l[F%2],l[2+Math.floor(F/2)%2],l[4+Math.floor(F/4)]),q(d,d,e.modelToView),!g.getParallelProjection()){Ct(h,d);const z=-f[0]/d[2];Ll(d,h,z)}q(d,d,o.vcpc),T=Math.min(d[0],T),v=Math.max(d[0],v),C=Math.min(d[1],C),S=Math.max(d[1],S)}u.setUniformf("dcxmin",T),u.setUniformf("dcxmax",v),u.setUniformf("dcymin",C),u.setUniformf("dcymax",S),u.isUniformUsed("cameraParallel")&&u.setUniformi("cameraParallel",g.getParallelProjection());const x=e.currentInput.getSpatialExtent(),R=e.currentInput.getSpacing(),O=new Float64Array(3);oe(O,(x[1]-x[0])*R[0],(x[3]-x[2])*R[1],(x[5]-x[4])*R[2]),u.setUniform3f("vSpacing",R[0],R[1],R[2]),oe(d,x[0],x[2],x[4]),e.currentInput.indexToWorldVec3(d,d),q(d,d,e.modelToView),u.setUniform3f("vOriginVC",d[0],d[1],d[2]);const w=e.currentInput.getIndexToWorld();ae(e.idxToView,e.modelToView,w),Za(e.idxNormalMatrix,o.normalMatrix,c.normalMatrix),Za(e.idxNormalMatrix,e.idxNormalMatrix,e.currentInput.getDirectionByReference());const m=jn(O)/t.getCurrentSampleDistance(i);m>e.renderable.getMaximumSamplesPerRay()&&py(`The number of steps required ${Math.ceil(m)} is larger than the
        specified maximum number of steps ${e.renderable.getMaximumSamplesPerRay()}.
        Please either change the
        volumeMapper sampleDistance or its maximum number of samples.`);const E=new Float64Array(3);if(oe(E,1,1,1),Fl(E,E,O),u.setUniform3f("vVCToIJK",E[0],E[1],E[2]),u.setUniform3i("volumeDimensions",p[0],p[1],p[2]),u.setUniform3f("volumeSpacings",R[0],R[1],R[2]),!e._openGLRenderWindow.getWebgl2()){const F=e.scalarTexture.getVolumeInfo();u.setUniformf("texWidth",e.scalarTexture.getWidth()),u.setUniformf("texHeight",e.scalarTexture.getHeight()),u.setUniformi("xreps",F.xreps),u.setUniformi("xstride",F.xstride),u.setUniformi("ystride",F.ystride)}const M=new Float64Array(3),D=new Float64Array(3);for(let F=0;F<6;++F){switch(F){case 1:oe(M,-1,0,0),oe(D,x[0],x[2],x[4]);break;case 2:oe(M,0,1,0),oe(D,x[1],x[3],x[5]);break;case 3:oe(M,0,-1,0),oe(D,x[0],x[2],x[4]);break;case 4:oe(M,0,0,1),oe(D,x[1],x[3],x[5]);break;case 5:oe(M,0,0,-1),oe(D,x[0],x[2],x[4]);break;case 0:default:oe(M,1,0,0),oe(D,x[1],x[3],x[5]);break}bn(M,M,e.idxNormalMatrix),q(D,D,e.idxToView);const z=-1*qa(D,M);u.setUniform3f(`vPlaneNormal${F}`,M[0],M[1],M[2]),u.setUniformf(`vPlaneDistance${F}`,z)}if(t.isLabelmapOutlineRequired(s)){const z=e.currentInput.getWorldToIndex();u.setUniformMatrix("vWCtoIDX",z);const U=i.getActiveCamera(),[k,L]=U.getClippingRange(),W=U.getDistance();U.setClippingRange(W,W+.1);const H=e.openGLCamera.getKeyMatrices(i);je(e.projectionToWorld,H.wcpc),U.setClippingRange(k,L),e.openGLCamera.getKeyMatrices(i),u.setUniformMatrix("PCWCMatrix",e.projectionToWorld);const $=t.getRenderTargetSize();u.setUniformf("vpWidth",$[0]),u.setUniformf("vpHeight",$[1]);const Q=t.getRenderTargetOffset();u.setUniformf("vpOffsetX",Q[0]/$[0]),u.setUniformf("vpOffsetY",Q[1]/$[1])}if(je(e.projectionToView,o.vcpc),u.setUniformMatrix("PCVCMatrix",e.projectionToView),e.lightComplexity===0)return;let N=0;const G=[],_=[],B=[];if(i.getLights().forEach(F=>{if(F.getSwitch()>0){const U=F.getColor(),k=F.getIntensity();G[0+N*3]=U[0]*k,G[1+N*3]=U[1]*k,G[2+N*3]=U[2]*k;const L=F.getDirection();oe(M,L[0],L[1],L[2]),bn(M,M,o.normalMatrix),Ct(M,M),_[0+N*3]=M[0],_[1+N*3]=M[1],_[2+N*3]=M[2],B[0+N*3]=-.5*M[0],B[1+N*3]=-.5*M[1],B[2+N*3]=-.5*(M[2]-1),N++}}),u.setUniformi("twoSidedLighting",i.getTwoSidedLighting()),u.setUniformi("lightNum",N),u.setUniform3fv("lightColor",G),u.setUniform3fv("lightDirectionVC",_),u.setUniform3fv("lightHalfAngleVC",B),e.lightComplexity===3){N=0;const F=[],z=[],U=[],k=[],L=[];i.getLights().forEach(W=>{if(W.getSwitch()>0){const $=W.getAttenuationValues();z[0+N*3]=$[0],z[1+N*3]=$[1],z[2+N*3]=$[2],k[N]=W.getExponent(),U[N]=W.getConeAngle(),L[N]=W.getPositional();const Q=W.getTransformedPosition();q(Q,Q,e.modelToView),F[0+N*3]=Q[0],F[1+N*3]=Q[1],F[2+N*3]=Q[2],N+=1}}),u.setUniform3fv("lightPositionVC",F),u.setUniform3fv("lightAttenuation",z),u.setUniformfv("lightConeAngle",U),u.setUniformfv("lightExponent",k),u.setUniformiv("lightPositional",L)}if(e.renderable.getVolumetricScatteringBlending()>0&&(u.setUniformf("giReach",e.renderable.getGlobalIlluminationReach()),u.setUniformf("volumetricScatteringBlending",e.renderable.getVolumetricScatteringBlending()),u.setUniformf("volumeShadowSamplingDistFactor",e.renderable.getVolumeShadowSamplingDistFactor()),u.setUniformf("anisotropy",e.renderable.getAnisotropy()),u.setUniformf("anisotropy2",e.renderable.getAnisotropy()**2)),e.renderable.getLocalAmbientOcclusion()&&s.getProperty().getAmbient()>0){const F=e.renderable.getLAOKernelSize();u.setUniformi("kernelSize",F);const z=[];for(let U=0;U<F;U++)z[U*2]=Math.random()*.5,z[U*2+1]=Math.random()*.5;u.setUniform2fv("kernelSample",z),u.setUniformi("kernelRadius",e.renderable.getLAOKernelRadius())}},t.setPropertyShaderParameters=(a,i,s)=>{const o=a.getProgram();o.setUniformi("ctexture",e.colorTexture.getTextureUnit()),o.setUniformi("otexture",e.opacityTexture.getTextureUnit()),o.setUniformi("jtexture",e.jitterTexture.getTextureUnit()),o.setUniformi("ttexture",e.labelOutlineThicknessTexture.getTextureUnit());const c=e.scalarTexture.getVolumeInfo(),u=s.getProperty(),g=e.scalarTexture.getComponents(),f=t.useIndependentComponents(u);if(f)for(let p=0;p<g;p++)o.setUniformf(`mix${p}`,s.getProperty().getComponentWeight(p));for(let p=0;p<g;p++){const d=f?p:0,h=c.scale[p],v=u.getScalarOpacity(d).getRange(),C=h/(v[1]-v[0]),S=(c.offset[p]-v[0])/(v[1]-v[0]);o.setUniformf(`oshift${p}`,S),o.setUniformf(`oscale${p}`,C);const R=u.getRGBTransferFunction(d).getRange(),O=(c.offset[p]-R[0])/(R[1]-R[0]),w=h/(R[1]-R[0]);o.setUniformf(`cshift${p}`,O),o.setUniformf(`cscale${p}`,w)}if(e.gopacity)if(f)for(let p=0;p<g;++p){const d=c.scale[p];if(u.getUseGradientOpacity(p)){const T=u.getGradientOpacityMinimumOpacity(p),v=u.getGradientOpacityMaximumOpacity(p);o.setUniformf(`gomin${p}`,T),o.setUniformf(`gomax${p}`,v);const C=[u.getGradientOpacityMinimumValue(p),u.getGradientOpacityMaximumValue(p)];o.setUniformf(`goscale${p}`,d*(v-T)/(C[1]-C[0])),o.setUniformf(`goshift${p}`,-C[0]*(v-T)/(C[1]-C[0])+T)}else o.setUniformf(`gomin${p}`,1),o.setUniformf(`gomax${p}`,1),o.setUniformf(`goscale${p}`,0),o.setUniformf(`goshift${p}`,1)}else{const p=c.scale[g-1],d=u.getGradientOpacityMinimumOpacity(0),h=u.getGradientOpacityMaximumOpacity(0);o.setUniformf("gomin0",d),o.setUniformf("gomax0",h);const T=[u.getGradientOpacityMinimumValue(0),u.getGradientOpacityMaximumValue(0)];o.setUniformf("goscale0",p*(h-d)/(T[1]-T[0])),o.setUniformf("goshift0",-T[0]*(h-d)/(T[1]-T[0])+d)}if(t.isLabelmapOutlineRequired(s)===!0){const p=s.getProperty().getLabelOutlineOpacity();o.setUniformf("outlineOpacity",p)}e.lightComplexity>0&&(o.setUniformf("vAmbient",u.getAmbient()),o.setUniformf("vDiffuse",u.getDiffuse()),o.setUniformf("vSpecular",u.getSpecular()),o.setUniformf("vSpecularPower",u.getSpecularPower()))},t.getClippingPlaneShaderParameters=(a,i,s)=>{if(e.renderable.getClippingPlanes().length>0){const o=e.openGLCamera.getKeyMatrices(i),c=[],u=[],g=[],f=e.renderable.getClippingPlanes(),l=f.length;for(let d=0;d<l;++d){const h=f[d].getNormal(),T=f[d].getOrigin();bn(h,h,o.normalMatrix),q(T,T,o.wcvc);const v=-1*qa(T,h);c.push(h[0]),c.push(h[1]),c.push(h[2]),u.push(v),g.push(T[0]),g.push(T[1]),g.push(T[2])}const p=a.getProgram();p.setUniform3fv("vClipPlaneNormals",c),p.setUniformfv("vClipPlaneDistances",u),p.setUniform3fv("vClipPlaneOrigins",g),p.setUniformi("clip_numPlanes",l)}},t.delete=cr(()=>{e._animationRateSubscription&&(e._animationRateSubscription.unsubscribe(),e._animationRateSubscription=null)},()=>{e._openGLRenderWindow&&r(e._openGLRenderWindow)},t.delete),t.getRenderTargetSize=()=>{if(e._useSmallViewport)return[e._smallViewportWidth,e._smallViewportHeight];const{usize:a,vsize:i}=e._openGLRenderer.getTiledSizeAndOrigin();return[a,i]},t.getRenderTargetOffset=()=>{const{lowerLeftU:a,lowerLeftV:i}=e._openGLRenderer.getTiledSizeAndOrigin();return[a,i]},t.getCurrentSampleDistance=a=>{const i=a.getVTKWindow().getInteractor(),s=e.renderable.getSampleDistance();if(i.isAnimating()){const o=e.renderable.getInteractionSampleDistanceFactor();return s*o}return s},t.renderPieceStart=(a,i)=>{const s=a.getVTKWindow().getInteractor();if(e._lastScale||(e._lastScale=e.renderable.getInitialInteractionScale()),e._useSmallViewport=!1,s.isAnimating()&&e._lastScale>1.5&&(e._useSmallViewport=!0),e._animationRateSubscription||(e._animationRateSubscription=s.onAnimationFrameRateUpdate(()=>{if(e.renderable.getAutoAdjustSampleDistances()){const c=s.getRecentAnimationFrameRate(),u=s.getDesiredUpdateRate()/c;(u>1.15||u<.85)&&(e._lastScale*=u),e._lastScale>400&&(e._lastScale=400),e._lastScale<1.5&&(e._lastScale=1.5)}else e._lastScale=e.renderable.getImageSampleDistance()*e.renderable.getImageSampleDistance()})),e._useSmallViewport){const c=e._openGLRenderWindow.getFramebufferSize(),u=1/Math.sqrt(e._lastScale);if(e._smallViewportWidth=Math.ceil(u*c[0]),e._smallViewportHeight=Math.ceil(u*c[1]),e._smallViewportHeight>c[1]&&(e._smallViewportHeight=c[1]),e._smallViewportWidth>c[0]&&(e._smallViewportWidth=c[0]),e.framebuffer.saveCurrentBindingsAndBuffers(),e.framebuffer.getGLFramebuffer()===null)e.framebuffer.create(c[0],c[1]),e.framebuffer.populateFramebuffer();else{const f=e.framebuffer.getSize();(!f||f[0]!==c[0]||f[1]!==c[1])&&(e.framebuffer.create(c[0],c[1]),e.framebuffer.populateFramebuffer())}e.framebuffer.bind();const g=e.context;g.clearColor(0,0,0,0),g.colorMask(!0,!0,!0,!0),g.clear(g.COLOR_BUFFER_BIT),g.viewport(0,0,e._smallViewportWidth,e._smallViewportHeight),e.fvp=[e._smallViewportWidth/c[0],e._smallViewportHeight/c[1]]}e.context.disable(e.context.DEPTH_TEST),t.updateBufferObjects(a,i),i.getProperty().getInterpolationType()===di.NEAREST?(e.scalarTexture.setMinificationFilter(j.NEAREST),e.scalarTexture.setMagnificationFilter(j.NEAREST)):(e.scalarTexture.setMinificationFilter(j.LINEAR),e.scalarTexture.setMagnificationFilter(j.LINEAR)),e.zBufferTexture!==null&&e.zBufferTexture.activate()},t.renderPieceDraw=(a,i)=>{const s=e.context;e.scalarTexture.activate(),e.opacityTexture.activate(),e.labelOutlineThicknessTexture.activate(),e.colorTexture.activate(),e.jitterTexture.activate(),t.updateShaders(e.tris,a,i),s.drawArrays(s.TRIANGLES,0,e.tris.getCABO().getElementCount()),e.tris.getVAO().release(),e.scalarTexture.deactivate(),e.colorTexture.deactivate(),e.opacityTexture.deactivate(),e.labelOutlineThicknessTexture.deactivate(),e.jitterTexture.deactivate()},t.renderPieceFinish=(a,i)=>{if(e.zBufferTexture!==null&&e.zBufferTexture.deactivate(),e._useSmallViewport){if(e.framebuffer.restorePreviousBindingsAndBuffers(),e.copyShader===null){e.copyShader=e._openGLRenderWindow.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","uniform vec2 tfactor;","varying vec2 tcoord;","void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"].join(`
`),["//VTK::System::Dec","//VTK::Output::Dec","uniform sampler2D texture1;","varying vec2 tcoord;","void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"].join(`
`),"");const u=e.copyShader;e.copyVAO=Ui.newInstance(),e.copyVAO.setOpenGLRenderWindow(e._openGLRenderWindow),e.tris.getCABO().bind(),e.copyVAO.addAttributeArray(u,e.tris.getCABO(),"vertexDC",e.tris.getCABO().getVertexOffset(),e.tris.getCABO().getStride(),e.context.FLOAT,3,e.context.FALSE)||Ba("Error setting vertexDC in copy shader VAO.")}else e._openGLRenderWindow.getShaderCache().readyShaderProgram(e.copyShader);const s=e._openGLRenderWindow.getFramebufferSize();e.context.viewport(0,0,s[0],s[1]);const o=e.framebuffer.getColorTexture();o.activate(),e.copyShader.setUniformi("texture",o.getTextureUnit()),e.copyShader.setUniform2f("tfactor",e.fvp[0],e.fvp[1]);const c=e.context;c.blendFuncSeparate(c.ONE,c.ONE_MINUS_SRC_ALPHA,c.ONE,c.ONE_MINUS_SRC_ALPHA),e.context.drawArrays(e.context.TRIANGLES,0,e.tris.getCABO().getElementCount()),o.deactivate(),c.blendFuncSeparate(c.SRC_ALPHA,c.ONE_MINUS_SRC_ALPHA,c.ONE,c.ONE_MINUS_SRC_ALPHA)}},t.renderPiece=(a,i)=>{if(t.invokeEvent({type:"StartEvent"}),e.renderable.update(),e.currentInput=e.renderable.getInputData(),t.invokeEvent({type:"EndEvent"}),!e.currentInput){Ba("No input!");return}t.renderPieceStart(a,i),t.renderPieceDraw(a,i),t.renderPieceFinish(a,i)},t.computeBounds=(a,i)=>{if(!t.getInput()){xn(e.Bounds);return}e.bounds=t.getInput().getBounds()},t.updateBufferObjects=(a,i)=>{t.getNeedToRebuildBufferObjects(a,i)&&t.buildBufferObjects(a,i)},t.getNeedToRebuildBufferObjects=(a,i)=>{var s,o,c;return e.VBOBuildTime.getMTime()<t.getMTime()||e.VBOBuildTime.getMTime()<i.getMTime()||e.VBOBuildTime.getMTime()<e.renderable.getMTime()||e.VBOBuildTime.getMTime()<i.getProperty().getMTime()||e.VBOBuildTime.getMTime()<e.currentInput.getMTime()||!((s=e.scalarTexture)!=null&&s.getHandle())||!((o=e.colorTexture)!=null&&o.getHandle())||!((c=e.labelOutlineThicknessTexture)!=null&&c.getHandle())},t.buildBufferObjects=(a,i)=>{var R,O;const s=e.currentInput;if(!s)return;const o=s.getPointData()&&s.getPointData().getScalars();if(!o)return;const c=i.getProperty();if(!e.jitterTexture.getHandle()){const w=new Uint8Array(1024);for(let m=0;m<32*32;++m)w[m]=255*Math.random();e.jitterTexture.setMinificationFilter(j.LINEAR),e.jitterTexture.setMagnificationFilter(j.LINEAR),e.jitterTexture.create2DFromRaw(32,32,1,J.UNSIGNED_CHAR,w)}const u=o.getNumberOfComponents(),g=t.useIndependentComponents(c),f=g?u:1,l=c.getScalarOpacity(),p=e._openGLRenderWindow.getGraphicsResourceForObject(l);let d=Bt(l,g,f);if(!(p!=null&&p.oglObject)||p.hash!==d){e.opacityTexture=he.newInstance(),e.opacityTexture.setOpenGLRenderWindow(e._openGLRenderWindow);const w=1024,m=w*2*f,E=new Float32Array(m),M=new Float32Array(w);for(let D=0;D<f;++D){const N=c.getScalarOpacity(D),G=t.getCurrentSampleDistance(a)/c.getScalarOpacityUnitDistance(D),_=N.getRange();N.getTable(_[0],_[1],w,M,1);for(let B=0;B<w;++B)E[D*w*2+B]=1-(1-M[B])**G,E[D*w*2+B+w]=E[D*w*2+B]}if(e.opacityTexture.resetFormatAndType(),e.opacityTexture.setMinificationFilter(j.LINEAR),e.opacityTexture.setMagnificationFilter(j.LINEAR),e._openGLRenderWindow.getWebgl2()||e.context.getExtension("OES_texture_float")&&e.context.getExtension("OES_texture_float_linear"))e.opacityTexture.create2DFromRaw(w,2*f,1,J.FLOAT,E);else{const D=new Uint8ClampedArray(m);for(let N=0;N<m;++N)D[N]=255*E[N];e.opacityTexture.create2DFromRaw(w,2*f,1,J.UNSIGNED_CHAR,D)}l&&(e._openGLRenderWindow.setGraphicsResourceForObject(l,e.opacityTexture,d),l!==e._scalarOpacityFunc&&(e._openGLRenderWindow.registerGraphicsResourceUser(l,t),e._openGLRenderWindow.unregisterGraphicsResourceUser(e._scalarOpacityFunc,t)),e._scalarOpacityFunc=l)}else e.opacityTexture=p.oglObject;const T=c.getRGBTransferFunction();d=Bt(T,g,f);const v=e._openGLRenderWindow.getGraphicsResourceForObject(T);if(!((R=v==null?void 0:v.oglObject)!=null&&R.getHandle())||(v==null?void 0:v.hash)!==d){e.colorTexture=he.newInstance(),e.colorTexture.setOpenGLRenderWindow(e._openGLRenderWindow);const w=1024,m=w*2*f*3,E=new Uint8ClampedArray(m),M=new Float32Array(w*3);for(let D=0;D<f;++D){const N=c.getRGBTransferFunction(D),G=N.getRange();N.getTable(G[0],G[1],w,M,1);for(let _=0;_<w*3;++_)E[D*w*6+_]=255*M[_],E[D*w*6+_+w*3]=255*M[_]}e.colorTexture.resetFormatAndType(),e.colorTexture.setMinificationFilter(j.LINEAR),e.colorTexture.setMagnificationFilter(j.LINEAR),e.colorTexture.create2DFromRaw(w,2*f,3,J.UNSIGNED_CHAR,E),T&&(e._openGLRenderWindow.setGraphicsResourceForObject(T,e.colorTexture,d),T!==e._colorTransferFunc&&(e._openGLRenderWindow.registerGraphicsResourceUser(T,t),e._openGLRenderWindow.unregisterGraphicsResourceUser(e._colorTransferFunc,t)),e._colorTransferFunc=T)}else e.colorTexture=v.oglObject;t.updateLabelOutlineThicknessTexture(i);const S=e._openGLRenderWindow.getGraphicsResourceForObject(o);if(d=is(s,o),!((O=S==null?void 0:S.oglObject)!=null&&O.getHandle())||(S==null?void 0:S.hash)!==d){e.scalarTexture=he.newInstance(),e.scalarTexture.setOpenGLRenderWindow(e._openGLRenderWindow);const w=s.getDimensions();e.scalarTexture.setOglNorm16Ext(e.context.getExtension("EXT_texture_norm16")),e.scalarTexture.resetFormatAndType(),e.scalarTexture.create3DFilterableFromDataArray(w[0],w[1],w[2],o,e.renderable.getPreferSizeOverAccuracy()),o&&(e._openGLRenderWindow.setGraphicsResourceForObject(o,e.scalarTexture,d),o!==e._scalars&&(e._openGLRenderWindow.registerGraphicsResourceUser(o,t),e._openGLRenderWindow.unregisterGraphicsResourceUser(e._scalars,t)),e._scalars=o)}else e.scalarTexture=S.oglObject;if(!e.tris.getCABO().getElementCount()){const w=new Float32Array(12);for(let D=0;D<4;D++)w[D*3]=D%2*2-1,w[D*3+1]=D>1?1:-1,w[D*3+2]=-1;const m=new Uint16Array(8);m[0]=3,m[1]=0,m[2]=1,m[3]=3,m[4]=3,m[5]=0,m[6]=3,m[7]=2;const E=A.newInstance({numberOfComponents:3,values:w});E.setName("points");const M=A.newInstance({numberOfComponents:1,values:m});e.tris.getCABO().createVBO(M,"polys",me.SURFACE,{points:E,cellOffset:0})}e.VBOBuildTime.modified()},t.updateLabelOutlineThicknessTexture=a=>{var u;const i=a.getProperty().getLabelOutlineThickness(),s=e._openGLRenderWindow.getGraphicsResourceForObject(i),o=`${i.join("-")}`;if(!((u=s==null?void 0:s.oglObject)!=null&&u.getHandle())||(s==null?void 0:s.hash)!==o){e.labelOutlineThicknessTexture=he.newInstance(),e.labelOutlineThicknessTexture.setOpenGLRenderWindow(e._openGLRenderWindow);const g=1024,f=1,l=g*f,p=new Uint8Array(l);for(let d=0;d<g;++d){const h=typeof i[d]<"u"?i[d]:i[0];p[d]=h}e.labelOutlineThicknessTexture.resetFormatAndType(),e.labelOutlineThicknessTexture.setMinificationFilter(j.NEAREST),e.labelOutlineThicknessTexture.setMagnificationFilter(j.NEAREST),e.labelOutlineThicknessTexture.create2DFromRaw(g,f,1,J.UNSIGNED_CHAR,p),i&&(e._openGLRenderWindow.setGraphicsResourceForObject(i,e.labelOutlineThicknessTexture,o),i!==e._labelOutlineThicknessArray&&(e._openGLRenderWindow.registerGraphicsResourceUser(i,t),e._openGLRenderWindow.unregisterGraphicsResourceUser(e._labelOutlineThicknessArray,t)),e._labelOutlineThicknessArray=i)}else e.labelOutlineThicknessTexture=s.oglObject},t.isLabelmapOutlineRequired=a=>{const i=a.getProperty(),s=e.renderable;return i.getUseLabelOutline()||s.getBlendMode()===Kr.LABELMAP_EDGE_PROJECTION_BLEND}}const Ty={context:null,VBOBuildTime:null,scalarTexture:null,opacityTexture:null,opacityTextureString:null,colorTexture:null,colorTextureString:null,jitterTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,lightComplexity:0,fullViewportTime:1,idxToView:null,idxNormalMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0};function vy(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Ty,r),De.extend(t,e,r),ut.implementBuildShadersWithReplacements(t,e,r),e.VBOBuildTime={},xe(e.VBOBuildTime,{mtime:0}),e.tris=ft.newInstance(),e.jitterTexture=he.newInstance(),e.jitterTexture.setWrapS(In.REPEAT),e.jitterTexture.setWrapT(In.REPEAT),e.framebuffer=Ma.newInstance(),e.idxToView=X(new Float64Array(16)),e.idxNormalMatrix=ct(new Float64Array(9)),e.modelToView=X(new Float64Array(16)),e.projectionToView=X(new Float64Array(16)),e.projectionToWorld=X(new Float64Array(16)),Me(t,e,["context"]),dy(t,e)}const yy=ye(vy,"vtkOpenGLVolumeMapper");Oe("vtkVolumeMapper",yy);const{FieldAssociations:Cy}=wn;function Sy(t,e){e.classHierarchy.push("vtkHardwareSelector"),t.getSourceDataAsync=async(r,n,a,i,s)=>{},t.selectAsync=async(r,n,a,i,s)=>{const o=await t.getSourceDataAsync(r,n,a,i,s);return o?o.generateSelection(n,a,i,s):[]}}const xy={fieldAssociation:Cy.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function Tf(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,xy,r),y.obj(t,e),y.setGet(t,e,["fieldAssociation","captureZValues"]),Sy(t,e)}const wy=y.newInstance(Tf,"vtkHardwareSelector");var Ry={newInstance:wy,extend:Tf};const My={GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},Oy={CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5};var my={SelectionContent:My,SelectionField:Oy};function Ey(t,e){e.classHierarchy.push("vtkSelectionNode"),t.getBounds=()=>e.points.getBounds()}const Dy={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function vf(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Dy,r),y.obj(t,e),e.properties={},y.setGet(t,e,["contentType","fieldType","properties","selectionList"]),Ey(t,e)}const Vy=y.newInstance(vf,"vtkSelectionNode");var yf={newInstance:Vy,extend:vf,...my};const{PassTypes:ve}=ku,{SelectionContent:Ly,SelectionField:ao}=yf,{FieldAssociations:qn}=wn,{vtkErrorMacro:Cf}=y,_t=1;function Sf(t){return`${t.propID} ${t.compositeID}`}function xf(t,e,r,n){if(!r)return 0;const a=(e*(n[2]-n[0]+1)+t)*4;return r[a+3]}function vt(t,e,r,n){if(!r)return 0;const a=(e*(n[2]-n[0]+1)+t)*4,i=r[a],s=r[a+1];return(r[a+2]*256+s)*256+i}function wf(t,e){let r=e;return r<<=24,r|=t,r}function fn(t,e,r,n){const a=r<0?0:r;if(a===0){if(n[0]=e[0],n[1]=e[1],e[0]<t.area[0]||e[0]>t.area[2]||e[1]<t.area[1]||e[1]>t.area[3])return null;const c=[e[0]-t.area[0],e[1]-t.area[1]],u=vt(c[0],c[1],t.pixBuffer[ve.ACTOR_PASS],t.area);if(u<=0||u-_t>=t.props.length)return null;const g={};g.valid=!0,g.propID=u-_t,g.prop=t.props[g.propID];let f=vt(c[0],c[1],t.pixBuffer[ve.COMPOSITE_INDEX_PASS],t.area);if((f<0||f>16777215)&&(f=0),g.compositeID=f-_t,t.captureZValues){const d=(c[1]*(t.area[2]-t.area[0]+1)+c[0])*4;g.zValue=(256*t.zBuffer[d]+t.zBuffer[d+1])/65535,g.displayPosition=e}if(t.pixBuffer[ve.ID_LOW24]&&xf(c[0],c[1],t.pixBuffer[ve.ID_LOW24],t.area)===0)return g;const l=vt(c[0],c[1],t.pixBuffer[ve.ID_LOW24],t.area),p=vt(c[0],c[1],t.pixBuffer[ve.ID_HIGH24],t.area);return g.attributeID=wf(l,p),g}const i=[e[0],e[1]],s=[0,0];let o=fn(t,e,0,n);if(o&&o.valid)return o;for(let c=1;c<a;++c){for(let u=i[1]>c?i[1]-c:0;u<=i[1]+c;++u)if(s[1]=u,i[0]>=c&&(s[0]=i[0]-c,o=fn(t,s,0,n),o&&o.valid)||(s[0]=i[0]+c,o=fn(t,s,0,n),o&&o.valid))return o;for(let u=i[0]>=c?i[0]-(c-1):0;u<=i[0]+(c-1);++u)if(s[0]=u,i[1]>=c&&(s[1]=i[1]-c,o=fn(t,s,0,n),o&&o.valid)||(s[1]=i[1]+c,o=fn(t,s,0,n),o&&o.valid))return o}return n[0]=e[0],n[1]=e[1],null}function Rf(t,e,r,n,a){const i=[];let s=0;return e.forEach((o,c)=>{const u=yf.newInstance();switch(u.setContentType(Ly.INDICES),t){case qn.FIELD_ASSOCIATION_CELLS:u.setFieldType(ao.CELL);break;case qn.FIELD_ASSOCIATION_POINTS:u.setFieldType(ao.POINT);break;default:Cf("Unknown field association")}u.getProperties().propID=o.info.propID,u.getProperties().prop=o.info.prop,u.getProperties().compositeID=o.info.compositeID,u.getProperties().attributeID=o.info.attributeID,u.getProperties().pixelCount=o.pixelCount,r&&(u.getProperties().displayPosition=[o.info.displayPosition[0],o.info.displayPosition[1],o.info.zValue],u.getProperties().worldPosition=a.displayToWorld(o.info.displayPosition[0],o.info.displayPosition[1],o.info.zValue,n)),u.setSelectionList(o.attributeIDs),i[s]=u,s++}),i}function Fy(t,e,r,n,a){const i=Math.floor(e),s=Math.floor(r),o=Math.floor(n),c=Math.floor(a),u=new Map,g=[0,0];for(let f=s;f<=c;f++)for(let l=i;l<=o;l++){const d=fn(t,[l,f],0,g);if(d&&d.valid){const h=Sf(d);if(!u.has(h))u.set(h,{info:d,pixelCount:1,attributeIDs:[d.attributeID]});else{const T=u.get(h);T.pixelCount++,t.captureZValues&&d.zValue<T.info.zValue&&(T.info=d),T.attributeIDs.indexOf(d.attributeID)===-1&&T.attributeIDs.push(d.attributeID)}}}return Rf(t.fieldAssociation,u,t.captureZValues,t.renderer,t.openGLRenderWindow)}function ky(t,e){e.classHierarchy.push("vtkOpenGLHardwareSelector"),t.releasePixBuffers=()=>{e.rawPixBuffer=[],e.pixBuffer=[],e.zBuffer=null},t.beginSelection=()=>{e._openGLRenderer=e._openGLRenderWindow.getViewNodeFor(e._renderer),e.maxAttributeId=0;const n=e._openGLRenderWindow.getSize();if(!e.framebuffer)e.framebuffer=Ma.newInstance(),e.framebuffer.setOpenGLRenderWindow(e._openGLRenderWindow),e.framebuffer.saveCurrentBindingsAndBuffers(),e.framebuffer.create(n[0],n[1]),e.framebuffer.populateFramebuffer();else{e.framebuffer.setOpenGLRenderWindow(e._openGLRenderWindow),e.framebuffer.saveCurrentBindingsAndBuffers();const a=e.framebuffer.getSize();!a||a[0]!==n[0]||a[1]!==n[1]?(e.framebuffer.create(n[0],n[1]),e.framebuffer.populateFramebuffer()):e.framebuffer.bind()}if(e._openGLRenderer.clear(),e._openGLRenderer.setSelector(t),e.hitProps={},e.propPixels={},e.props=[],t.releasePixBuffers(),e.fieldAssociation===qn.FIELD_ASSOCIATION_POINTS){const a=e._openGLRenderWindow.getContext(),i=a.isEnabled(a.BLEND);a.disable(a.BLEND),e._openGLRenderWindow.traverseAllPasses(),i&&a.enable(a.BLEND)}},t.endSelection=()=>{e.hitProps={},e._openGLRenderer.setSelector(null),e.framebuffer.restorePreviousBindingsAndBuffers()},t.preCapturePass=()=>{const n=e._openGLRenderWindow.getContext();e.originalBlending=n.isEnabled(n.BLEND),n.disable(n.BLEND)},t.postCapturePass=()=>{const n=e._openGLRenderWindow.getContext();e.originalBlending&&n.enable(n.BLEND)},t.select=()=>{let n=null;return t.captureBuffers()&&(n=t.generateSelection(e.area[0],e.area[1],e.area[2],e.area[3]),t.releasePixBuffers()),n},t.getSourceDataAsync=async(n,a,i,s,o)=>{if(e._renderer=n,a===void 0){const u=e._openGLRenderWindow.getSize();t.setArea(0,0,u[0]-1,u[1]-1)}else t.setArea(a,i,s,o);if(!t.captureBuffers())return!1;const c={area:[...e.area],pixBuffer:[...e.pixBuffer],captureZValues:e.captureZValues,zBuffer:e.zBuffer,props:[...e.props],fieldAssociation:e.fieldAssociation,renderer:n,openGLRenderWindow:e._openGLRenderWindow};return c.generateSelection=function(){for(var u=arguments.length,g=new Array(u),f=0;f<u;f++)g[f]=arguments[f];return Fy(c,...g)},c},t.captureBuffers=()=>{if(!e._renderer||!e._openGLRenderWindow)return Cf("Renderer and view must be set before calling Select."),!1;e._openGLRenderer=e._openGLRenderWindow.getViewNodeFor(e._renderer),e._openGLRenderWindow.getRenderable().preRender(),t.invokeEvent({type:"StartEvent"}),e.originalBackground=e._renderer.getBackgroundByReference(),e._renderer.setBackground(0,0,0,0);const n=e._openGLRenderWindow.getRenderPasses();t.beginSelection();const a=[];for(e.currentPass=ve.MIN_KNOWN_PASS;e.currentPass<=ve.MAX_KNOWN_PASS;e.currentPass++)t.passRequired(e.currentPass)&&(t.preCapturePass(e.currentPass),e.captureZValues&&e.currentPass===ve.ACTOR_PASS&&typeof n[0].requestDepth=="function"&&typeof n[0].getFramebuffer=="function"&&n[0].requestDepth(),e._openGLRenderWindow.traverseAllPasses(),t.postCapturePass(e.currentPass),t.savePixelBuffer(e.currentPass),a.push(e.currentPass));return a.forEach(i=>{e.currentPass=i,t.processPixelBuffers()}),e.currentPass=ve.MAX_KNOWN_PASS,t.endSelection(),e._renderer.setBackground(e.originalBackground),t.invokeEvent({type:"EndEvent"}),!0},t.processPixelBuffers=()=>{e.props.forEach((n,a)=>{t.isPropHit(a)&&n.processSelectorPixelBuffers(t,e.propPixels[a])})},t.passRequired=n=>{if(n===ve.ID_HIGH24){if(e.fieldAssociation===qn.FIELD_ASSOCIATION_POINTS)return e.maximumPointId>16777215;if(e.fieldAssociation===qn.FIELD_ASSOCIATION_CELLS)return e.maximumCellId>16777215}return!0},t.savePixelBuffer=n=>{if(e.pixBuffer[n]=e._openGLRenderWindow.getPixelData(e.area[0],e.area[1],e.area[2],e.area[3]),!e.rawPixBuffer[n]){const a=(e.area[2]-e.area[0]+1)*(e.area[3]-e.area[1]+1)*4;e.rawPixBuffer[n]=new Uint8Array(a),e.rawPixBuffer[n].set(e.pixBuffer[n])}if(n===ve.ACTOR_PASS){if(e.captureZValues){const a=e._openGLRenderWindow.getRenderPasses();if(typeof a[0].requestDepth=="function"&&typeof a[0].getFramebuffer=="function"){const i=a[0].getFramebuffer();i.saveCurrentBindingsAndBuffers(),i.bind(),e.zBuffer=e._openGLRenderWindow.getPixelData(e.area[0],e.area[1],e.area[2],e.area[3]),i.restorePreviousBindingsAndBuffers()}}t.buildPropHitList(e.rawPixBuffer[n])}},t.buildPropHitList=n=>{let a=0;for(let i=0;i<=e.area[3]-e.area[1];i++)for(let s=0;s<=e.area[2]-e.area[0];s++){let o=vt(s,i,n,e.area);o>0&&(o--,o in e.hitProps||(e.hitProps[o]=!0,e.propPixels[o]=[]),e.propPixels[o].push(a*4)),++a}},t.renderProp=n=>{e.currentPass===ve.ACTOR_PASS&&(t.setPropColorValueFromInt(e.props.length+_t),e.props.push(n))},t.renderCompositeIndex=n=>{e.currentPass===ve.COMPOSITE_INDEX_PASS&&t.setPropColorValueFromInt(n+_t)},t.renderAttributeId=n=>{n<0||(e.maxAttributeId=n>e.maxAttributeId?n:e.maxAttributeId)},t.passTypeToString=n=>y.enumToString(ve,n),t.isPropHit=n=>!!e.hitProps[n],t.setPropColorValueFromInt=n=>{e.propColorValue[0]=n%256/255,e.propColorValue[1]=Math.floor(n/256)%256/255,e.propColorValue[2]=Math.floor(n/65536)%256/255},t.getPixelInformation=(n,a,i)=>{const s=a<0?0:a;if(s===0){if(i[0]=n[0],i[1]=n[1],n[0]<e.area[0]||n[0]>e.area[2]||n[1]<e.area[1]||n[1]>e.area[3])return null;const g=[n[0]-e.area[0],n[1]-e.area[1]],f=vt(g[0],g[1],e.pixBuffer[ve.ACTOR_PASS],e.area);if(f<=0||f-_t>=e.props.length)return null;const l={};l.valid=!0,l.propID=f-_t,l.prop=e.props[l.propID];let p=vt(g[0],g[1],e.pixBuffer[ve.COMPOSITE_INDEX_PASS],e.area);if((p<0||p>16777215)&&(p=0),l.compositeID=p-_t,e.captureZValues){const T=(g[1]*(e.area[2]-e.area[0]+1)+g[0])*4;l.zValue=(256*e.zBuffer[T]+e.zBuffer[T+1])/65535,l.displayPosition=n}if(e.pixBuffer[ve.ID_LOW24]&&xf(g[0],g[1],e.pixBuffer[ve.ID_LOW24],e.area)===0)return l;const d=vt(g[0],g[1],e.pixBuffer[ve.ID_LOW24],e.area),h=vt(g[0],g[1],e.pixBuffer[ve.ID_HIGH24],e.area);return l.attributeID=wf(d,h),l}const o=[n[0],n[1]],c=[0,0];let u=t.getPixelInformation(n,0,i);if(u&&u.valid)return u;for(let g=1;g<s;++g){for(let f=o[1]>g?o[1]-g:0;f<=o[1]+g;++f)if(c[1]=f,o[0]>=g&&(c[0]=o[0]-g,u=t.getPixelInformation(c,0,i),u&&u.valid)||(c[0]=o[0]+g,u=t.getPixelInformation(c,0,i),u&&u.valid))return u;for(let f=o[0]>=g?o[0]-(g-1):0;f<=o[0]+(g-1);++f)if(c[0]=f,o[1]>=g&&(c[1]=o[1]-g,u=t.getPixelInformation(c,0,i),u&&u.valid)||(c[1]=o[1]+g,u=t.getPixelInformation(c,0,i),u&&u.valid))return u}return i[0]=n[0],i[1]=n[1],null},t.generateSelection=(n,a,i,s)=>{const o=Math.floor(n),c=Math.floor(a),u=Math.floor(i),g=Math.floor(s),f=new Map,l=[0,0];for(let p=c;p<=g;p++)for(let d=o;d<=u;d++){const h=[d,p],T=t.getPixelInformation(h,0,l);if(T&&T.valid){const v=Sf(T);if(!f.has(v))f.set(v,{info:T,pixelCount:1,attributeIDs:[T.attributeID]});else{const C=f.get(v);C.pixelCount++,e.captureZValues&&T.zValue<C.info.zValue&&(C.info=T),C.attributeIDs.indexOf(T.attributeID)===-1&&C.attributeIDs.push(T.attributeID)}}}return Rf(e.fieldAssociation,f,e.captureZValues,e._renderer,e._openGLRenderWindow)},t.getRawPixelBuffer=n=>e.rawPixBuffer[n],t.getPixelBuffer=n=>e.pixBuffer[n],t.attach=(n,a)=>{e._openGLRenderWindow=n,e._renderer=a};const r=t.setArea;t.setArea=function(){return r(...arguments)?(e.area[0]=Math.floor(e.area[0]),e.area[1]=Math.floor(e.area[1]),e.area[2]=Math.floor(e.area[2]),e.area[3]=Math.floor(e.area[3]),!0):!1}}const Ny={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function Mf(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Ny,r),Ry.extend(t,e,r),e.propColorValue=[0,0,0],e.props=[],e.area||(e.area=[0,0,0,0]),y.setGetArray(t,e,["area"],4),y.setGet(t,e,["_renderer","currentPass","_openGLRenderWindow","maximumPointId","maximumCellId"]),y.setGetArray(t,e,["propColorValue"],3),y.moveToProtected(t,e,["renderer","openGLRenderWindow"]),y.event(t,e,"event"),ky(t,e)}const _y=y.newInstance(Mf,"vtkOpenGLHardwareSelector");var os={newInstance:_y,extend:Mf,...ku};const{vtkErrorMacro:mn}=We,{Representation:Gy}=Ra,{ObjectType:Er}=Qt,{PassTypes:Uy}=os,By={type:"StartEvent"},Wy={type:"EndEvent"};function $y(t,e){e.classHierarchy.push("vtkOpenGLGlyph3DMapper");const r={...t};t.renderPiece=(n,a)=>{if(t.invokeEvent(By),e.renderable.getStatic()||e.renderable.update(),e.currentInput=e.renderable.getInputData(1),t.invokeEvent(Wy),!e.currentInput){mn("No input!");return}if(!e.currentInput.getPoints||!e.currentInput.getPoints().getNumberOfValues())return;const i=e.context;e._openGLRenderWindow.getWebgl2()?(e.hardwareSupport=!0,e.extension=null):e.extension||(e.extension=e.context.getExtension("ANGLE_instanced_arrays"),e.hardwareSupport=!!e.extension);const s=a.getProperty().getBackfaceCulling(),o=a.getProperty().getFrontfaceCulling();!s&&!o?e._openGLRenderWindow.disableCullFace():o?(e._openGLRenderWindow.enableCullFace(),i.cullFace(i.FRONT)):(e._openGLRenderWindow.enableCullFace(),i.cullFace(i.BACK)),t.renderPieceStart(n,a),t.renderPieceDraw(n,a),t.renderPieceFinish(n,a)},t.multiply4x4WithOffset=(n,a,i,s)=>{const o=a[0],c=a[1],u=a[2],g=a[3],f=a[4],l=a[5],p=a[6],d=a[7],h=a[8],T=a[9],v=a[10],C=a[11],S=a[12],x=a[13],R=a[14],O=a[15];let w=i[s],m=i[s+1],E=i[s+2],M=i[s+3];n[0]=w*o+m*f+E*h+M*S,n[1]=w*c+m*l+E*T+M*x,n[2]=w*u+m*p+E*v+M*R,n[3]=w*g+m*d+E*C+M*O,w=i[s+4],m=i[s+5],E=i[s+6],M=i[s+7],n[4]=w*o+m*f+E*h+M*S,n[5]=w*c+m*l+E*T+M*x,n[6]=w*u+m*p+E*v+M*R,n[7]=w*g+m*d+E*C+M*O,w=i[s+8],m=i[s+9],E=i[s+10],M=i[s+11],n[8]=w*o+m*f+E*h+M*S,n[9]=w*c+m*l+E*T+M*x,n[10]=w*u+m*p+E*v+M*R,n[11]=w*g+m*d+E*C+M*O,w=i[s+12],m=i[s+13],E=i[s+14],M=i[s+15],n[12]=w*o+m*f+E*h+M*S,n[13]=w*c+m*l+E*T+M*x,n[14]=w*u+m*p+E*v+M*R,n[15]=w*g+m*d+E*C+M*O},t.replaceShaderNormal=(n,a,i)=>{if(e.hardwareSupport&&e.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let o=n.Vertex;e.lastBoundBO.getCABO().getNormalOffset()&&(o=V.substitute(o,"//VTK::Normal::Dec",["attribute vec3 normalMC;","attribute mat3 gNormal;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,o=V.substitute(o,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * gNormal * normalMC;"]).result),n.Vertex=o}r.replaceShaderNormal(n,a,i)},t.replaceShaderColor=(n,a,i)=>{if(e.hardwareSupport&&e.renderable.getColorArray()){let s=n.Vertex,o=n.Geometry,c=n.Fragment;const u=e.lastBoundBO.getReferenceByName("lastLightComplexity");let g=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity"];u&&(g=g.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let f=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];u&&(f=f.concat(["  vec3 specularColor;","  float specularPower;"])),f=f.concat(["  opacity = opacityUniform;"]),u&&(f=f.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),e.drawingEdges||(g=g.concat(["varying vec4 vertexColorVSOutput;"]),s=V.substitute(s,"//VTK::Color::Dec",["attribute vec4 gColor;","varying vec4 vertexColorVSOutput;"]).result,s=V.substitute(s,"//VTK::Color::Impl",["vertexColorVSOutput = gColor;"]).result,o=V.substitute(o,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,o=V.substitute(o,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result,f=f.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])),c=V.substitute(c,"//VTK::Color::Impl",f).result,c=V.substitute(c,"//VTK::Color::Dec",g).result,n.Vertex=s,n.Geometry=o,n.Fragment=c}r.replaceShaderColor(n,a,i)},t.replaceShaderPositionVC=(n,a,i)=>{if(e.hardwareSupport){let s=n.Vertex;e.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(s=V.substitute(s,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","vertexVCVSOutput = MCVCMatrix * gVertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result,s=V.substitute(s,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result):(s=V.substitute(s,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;"]).result,s=V.substitute(s,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result),n.Vertex=s}r.replaceShaderPositionVC(n,a,i)},t.replaceShaderPicking=(n,a,i)=>{if(e.hardwareSupport){let s=n.Fragment,o=n.Vertex;o=V.substitute(o,"//VTK::Picking::Dec",["attribute vec3 mapperIndexVS;","varying vec3 mapperIndexVSOutput;"]).result,o=V.substitute(o,"//VTK::Picking::Impl","  mapperIndexVSOutput = mapperIndexVS;").result,n.Vertex=o,s=V.substitute(s,"//VTK::Picking::Dec",["varying vec3 mapperIndexVSOutput;","uniform vec3 mapperIndex;","uniform int picking;"]).result,s=V.substitute(s,"//VTK::Picking::Impl",["  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);","  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];"]).result,n.Fragment=s}else r.replaceShaderPicking(n,a,i)},t.updateGlyphShaderParameters=(n,a,i,s,o,c,u,g)=>{const f=i.getProgram();if(n){const l=e.normalMatrix,p=c,d=u*9,h=e.tmpMat3,T=l[0],v=l[1],C=l[2],S=l[3],x=l[4],R=l[5],O=l[6],w=l[7],m=l[8],E=p[d],M=p[d+1],D=p[d+2],N=p[d+3],G=p[d+4],_=p[d+5],B=p[d+6],F=p[d+7],z=p[d+8];h[0]=E*T+M*S+D*O,h[1]=E*v+M*x+D*w,h[2]=E*C+M*R+D*m,h[3]=N*T+G*S+_*O,h[4]=N*v+G*x+_*w,h[5]=N*C+G*R+_*m,h[6]=B*T+F*S+z*O,h[7]=B*v+F*x+z*w,h[8]=B*C+F*R+z*m,f.setUniformMatrix3x3("normalMatrix",e.tmpMat3)}if(t.multiply4x4WithOffset(e.tmpMat4,e.mcpcMatrix,o,u*16),f.setUniformMatrix("MCPCMatrix",e.tmpMat4),a&&(t.multiply4x4WithOffset(e.tmpMat4,e.mcvcMatrix,o,u*16),f.setUniformMatrix("MCVCMatrix",e.tmpMat4)),s){const l=s.getData();e.tmpColor[0]=l[u*4]/255,e.tmpColor[1]=l[u*4+1]/255,e.tmpColor[2]=l[u*4+2]/255,f.setUniform3fArray("ambientColorUniform",e.tmpColor),f.setUniform3fArray("diffuseColorUniform",e.tmpColor)}g&&f.setUniform3fArray("mapperIndex",g.getPropColorValue())},t.renderPieceDraw=(n,a)=>{const i=a.getProperty().getRepresentation(),s=e.context,o=a.getProperty().getEdgeVisibility()&&i===Gy.SURFACE,c=e.openGLCamera.getKeyMatrices(n),u=e.openGLActor.getKeyMatrices();Za(e.normalMatrix,c.normalMatrix,u.normalMatrix),ae(e.mcpcMatrix,c.wcpc,u.mcwc),ae(e.mcvcMatrix,c.wcvc,u.mcwc);const g=e.renderable.getMatrixArray(),f=e.renderable.getNormalArray(),l=e.renderable.getColorArray(),p=g.length/16;let d=!1;e._openGLRenderer.getSelector()&&e._openGLRenderer.getSelector().getCurrentPass()===Uy.COMPOSITE_INDEX_PASS&&(d=!0);for(let h=e.primTypes.Start;h<e.primTypes.End;h++){const T=e.primitives[h].getCABO();if(T.getElementCount()){e.drawingEdges=o&&(h===e.primTypes.TrisEdges||h===e.primTypes.TriStripsEdges),e.lastBoundBO=e.primitives[h],e.primitives[h].updateShaders(n,a,t);const v=e.primitives[h].getProgram(),C=e.primitives[h].getOpenGLMode(i),S=v.isUniformUsed("normalMatrix"),x=v.isUniformUsed("MCVCMatrix");if(e.hardwareSupport)e.extension?e.extension.drawArraysInstancedANGLE(C,0,T.getElementCount(),p):s.drawArraysInstanced(C,0,T.getElementCount(),p);else for(let R=0;R<p;++R)d&&e._openGLRenderer.getSelector().renderCompositeIndex(R),t.updateGlyphShaderParameters(S,x,e.primitives[h],l,g,f,R,d?e._openGLRenderer.getSelector():null),s.drawArrays(C,0,T.getElementCount())}}},t.setMapperShaderParameters=(n,a,i)=>{if(n.getCABO().getElementCount()&&(e.glyphBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){n.getProgram().isAttributeUsed("gMatrix")?n.getVAO().addAttributeMatrixWithDivisor(n.getProgram(),e.matrixBuffer,"gMatrix",0,64,e.context.FLOAT,4,!1,1)||mn("Error setting gMatrix in shader VAO."):n.getVAO().removeAttributeArray("gMatrix"),n.getProgram().isAttributeUsed("gNormal")?n.getVAO().addAttributeMatrixWithDivisor(n.getProgram(),e.normalBuffer,"gNormal",0,36,e.context.FLOAT,3,!1,1)||mn("Error setting gNormal in shader VAO."):n.getVAO().removeAttributeArray("gNormal"),n.getProgram().isAttributeUsed("gColor")?n.getVAO().addAttributeArrayWithDivisor(n.getProgram(),e.colorBuffer,"gColor",0,4,e.context.UNSIGNED_BYTE,4,!0,1,!1)||mn("Error setting gColor in shader VAO."):n.getVAO().removeAttributeArray("gColor"),n.getProgram().isAttributeUsed("mapperIndexVS")?n.getVAO().addAttributeArrayWithDivisor(n.getProgram(),e.pickBuffer,"mapperIndexVS",0,4,e.context.UNSIGNED_BYTE,4,!0,1,!1)||mn("Error setting mapperIndexVS in shader VAO."):n.getVAO().removeAttributeArray("mapperIndexVS"),r.setMapperShaderParameters(n,a,i),n.getAttributeUpdateTime().modified();return}r.setMapperShaderParameters(n,a,i)},t.getNeedToRebuildBufferObjects=(n,a)=>(e.renderable.buildArrays(),e.VBOBuildTime.getMTime()<e.renderable.getBuildTime().getMTime()?!0:r.getNeedToRebuildBufferObjects(n,a)),t.getNeedToRebuildShaders=(n,a,i)=>!!(r.getNeedToRebuildShaders(n,a,i)||n.getShaderSourceTime().getMTime()<e.renderable.getMTime()||n.getShaderSourceTime().getMTime()<e.currentInput.getMTime()),t.buildBufferObjects=(n,a)=>{if(e.hardwareSupport){const i=e.renderable.getMatrixArray(),s=e.renderable.getNormalArray(),o=e.renderable.getColorArray();if(e.matrixBuffer||(e.matrixBuffer=Qt.newInstance(),e.matrixBuffer.setOpenGLRenderWindow(e._openGLRenderWindow),e.normalBuffer=Qt.newInstance(),e.normalBuffer.setOpenGLRenderWindow(e._openGLRenderWindow),e.colorBuffer=Qt.newInstance(),e.colorBuffer.setOpenGLRenderWindow(e._openGLRenderWindow),e.pickBuffer=Qt.newInstance(),e.pickBuffer.setOpenGLRenderWindow(e._openGLRenderWindow)),e.renderable.getBuildTime().getMTime()>e.glyphBOBuildTime.getMTime()){e.matrixBuffer.upload(i,Er.ARRAY_BUFFER),e.normalBuffer.upload(s,Er.ARRAY_BUFFER),o?e.colorBuffer.upload(o.getData(),Er.ARRAY_BUFFER):e.colorBuffer.releaseGraphicsResources();const c=i.length/16,u=new Uint8Array(4*c);for(let g=0;g<c;++g){let f=g+1;const l=g*4;u[l]=f%256,f-=u[l],f/=256,u[l+1]=f%256,f-=u[l+1],f/=256,u[l+2]=f%256,u[l+3]=255}e.pickBuffer.upload(u,Er.ARRAY_BUFFER),e.glyphBOBuildTime.modified()}}return r.buildBufferObjects(n,a)}}const zy={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};function Hy(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,zy,r),Pd.extend(t,e,r),e.tmpMat3=ct(new Float64Array(9)),e.normalMatrix=ct(new Float64Array(9)),e.mcpcMatrix=X(new Float64Array(16)),e.mcvcMatrix=X(new Float64Array(16)),e.tmpColor=[],e.glyphBOBuildTime={},xe(e.glyphBOBuildTime,{mtime:0}),$y(t,e)}const jy=ye(Hy,"vtkOpenGLGlyph3DMapper");Oe("vtkGlyph3DMapper",jy);function by(t){return t}function cs(t){if(t===null||t==="null")return null;if(t==="true")return!0;if(t==="false")return!1;if(!(t===void 0||t==="undefined"))return t[0]==="["&&t[t.length-1]==="]"?t.substring(1,t.length-1).split(",").map(e=>cs(e.trim())):t===""||Number.isNaN(Number(t))?t:Number(t)}function Ky(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:!0,e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:window.location.search;const r={},n=t?cs:by;return new URLSearchParams(e).forEach((i,s)=>{s&&(r[s]=i?n(i):!0)}),r}var Xy={toNativeType:cs,extractURLParameters:Ky};const P={DEFAULT:0,GEOMETRY:1,SLICE:2,VOLUME:3,YZ_PLANE:4,XZ_PLANE:5,XY_PLANE:6},oa={PICKING_BUFFER:0,FRONT_BUFFER:1},Ay={MOUSE_MOVE:0,MOUSE_RELEASE:1};var Of={ViewTypes:P,RenderingTypes:oa,CaptureOn:Ay};const{vtkErrorMacro:Dr}=y;function Yy(t,e){e.classHierarchy.push("vtkPiecewiseFunction"),t.getSize=()=>e.nodes.length,t.getType=()=>{let r,n=0,a=0;e.nodes.length>0&&(n=e.nodes[0].y);for(let i=1;i<e.nodes.length;i++){if(r=e.nodes[i].y,r!==n)if(r>n)switch(a){case 0:case 1:a=1;break;case 2:default:a=3;break}else switch(a){case 0:case 2:a=2;break;case 1:default:a=3;break}if(n=r,a===3)break}switch(a){case 0:return"Constant";case 1:return"NonDecreasing";case 2:return"NonIncreasing";case 3:default:return"Varied"}},t.getDataPointer=()=>{const r=e.nodes.length;if(e.function=null,r>0){e.function=[];for(let n=0;n<r;n++)e.function[2*n]=e.nodes[n].x,e.function[2*n+1]=e.nodes[n].y}return e.function},t.getFirstNonZeroValue=()=>{if(e.nodes.length===0)return 0;let r=1,n=0,a=0;for(;a<e.nodes.length;a++)if(e.nodes[a].y!==0){r=0;break}return r?n=Number.MAX_VALUE:a>0?n=e.nodes[a-1].x:e.clamping?n=-Number.MAX_VALUE:n=e.nodes[0].x,n},t.getNodeValue=(r,n)=>{const a=e.nodes.length;return r<0||r>=a?(Dr("Index out of range!"),-1):(n[0]=e.nodes[r].x,n[1]=e.nodes[r].y,n[2]=e.nodes[r].midpoint,n[3]=e.nodes[r].sharpness,1)},t.setNodeValue=(r,n)=>{const a=e.nodes.length;if(r<0||r>=a)return Dr("Index out of range!"),-1;const i=e.nodes[r].x;return e.nodes[r].x=n[0],e.nodes[r].y=n[1],e.nodes[r].midpoint=n[2],e.nodes[r].sharpness=n[3],i!==n[0]?t.sortAndUpdateRange():t.modified(),1},t.addPoint=(r,n)=>t.addPointLong(r,n,.5,0),t.addPointLong=(r,n,a,i)=>{if(a<0||a>1)return Dr("Midpoint outside range [0.0, 1.0]"),-1;if(i<0||i>1)return Dr("Sharpness outside range [0.0, 1.0]"),-1;e.allowDuplicateScalars||t.removePoint(r);const s={x:r,y:n,midpoint:a,sharpness:i};e.nodes.push(s),t.sortAndUpdateRange();let o;for(o=0;o<e.nodes.length&&e.nodes[o].x!==r;o++);return o<e.nodes.length?o:-1},t.setNodes=r=>{e.nodes!==r&&(e.nodes=r,t.sortAndUpdateRange())},t.sortAndUpdateRange=()=>{e.nodes.sort((n,a)=>n.x-a.x),t.updateRange()||t.modified()},t.updateRange=()=>{const r=e.range.slice(),n=e.nodes.length;return n?(e.range[0]=e.nodes[0].x,e.range[1]=e.nodes[n-1].x):(e.range[0]=0,e.range[1]=0),r[0]===e.range[0]&&r[1]===e.range[1]?!1:(t.modified(),!0)},t.removePoint=r=>{let n;for(n=0;n<e.nodes.length&&e.nodes[n].x!==r;n++);if(n>=e.nodes.length)return-1;const a=n;let i=!1;return e.nodes.splice(n,1),(n===0||n===e.nodes.length)&&(i=t.updateRange()),i||t.modified(),a},t.removeAllPoints=()=>{e.nodes=[],t.sortAndUpdateRange()},t.addSegment=(r,n,a,i)=>{t.sortAndUpdateRange();for(let s=0;s<e.nodes.length;)e.nodes[s].x>=r&&e.nodes[s].x<=a?e.nodes.splice(s,1):s++;t.addPoint(r,n,.5,0),t.addPoint(a,i,.5,0)},t.getValue=r=>{const n=[];return t.getTable(r,r,1,n),n[0]},t.adjustRange=r=>{if(r.length<2)return 0;const n=t.getRange();n[0]<r[0]?t.addPoint(r[0],t.getValue(r[0])):t.addPoint(r[0],t.getValue(n[0])),n[1]>r[1]?t.addPoint(r[1],t.getValue(r[1])):t.addPoint(r[1],t.getValue(n[1])),t.sortAndUpdateRange();for(let a=0;a<e.nodes.length;)e.nodes[a].x>=r[0]&&e.nodes[a].x<=r[1]?e.nodes.splice(a,1):++a;return t.sortAndUpdateRange(),1},t.estimateMinNumberOfSamples=(r,n)=>{const a=t.findMinimumXDistance();return Math.ceil((n-r)/a)},t.findMinimumXDistance=()=>{const r=e.nodes.length;if(r<2)return-1;let n=e.nodes[1].x-e.nodes[0].x;for(let a=0;a<r-1;a++){const i=e.nodes[a+1].x-e.nodes[a].x;i<n&&(n=i)}return n},t.getTable=function(r,n,a,i){let s=arguments.length>4&&arguments[4]!==void 0?arguments[4]:1,o,c=0;const u=e.nodes.length;let g=0;u!==0&&(g=e.nodes[u-1].y);let f=0,l=0,p=0,d=0,h=0,T=0,v=0;for(o=0;o<a;o++){const C=s*o;for(a>1?f=r+o/(a-1)*(n-r):f=.5*(r+n);c<u&&f>e.nodes[c].x;)c++,c<u&&(l=e.nodes[c-1].x,p=e.nodes[c].x,d=e.nodes[c-1].y,h=e.nodes[c].y,T=e.nodes[c-1].midpoint,v=e.nodes[c-1].sharpness,T<1e-5&&(T=1e-5),T>.99999&&(T=.99999));if(c>=u)i[C]=e.clamping?g:0;else if(c===0)i[C]=e.clamping?e.nodes[0].y:0;else{let S=(f-l)/(p-l);if(S<T?S=.5*S/T:S=.5+.5*(S-T)/(1-T),v>.99)if(S<.5){i[C]=d;continue}else{i[C]=h;continue}if(v<.01){i[C]=(1-S)*d+S*h;continue}S<.5?S=.5*(S*2)**(1+10*v):S>.5&&(S=1-.5*((1-S)*2)**(1+10*v));const x=S*S,R=x*S,O=2*R-3*x+1,w=-2*R+3*x,m=R-2*x+S,E=R-x,M=h-d,D=(1-v)*M;i[C]=O*d+w*h+m*D+E*D;const N=d<h?d:h,G=d>h?d:h;i[C]=i[C]<N?N:i[C],i[C]=i[C]>G?G:i[C]}}}}const qy={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function mf(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,qy,r),y.obj(t,e),e.nodes=[],y.setGet(t,e,["allowDuplicateScalars","clamping"]),y.setArray(t,e,["range"],2),y.getArray(t,e,["range"]),Yy(t,e)}const Zy=y.newInstance(mf,"vtkPiecewiseFunction");var ca={newInstance:Zy,extend:mf};function Py(t,e){var r=e===void 0?null:e,n=/(['"])__worker_loader_strict__(['"])/g,a=[],i=t.toString();return i=i.replace(n,"$1use strict$2"),a.push("("+i+")()"),r&&a.push("//# sourceMappingURL="+r+`
`),a}function Jy(t,e){var r=Py(t,e),n=new Blob(r,{type:"application/javascript"});return URL.createObjectURL(n)}function Qy(t,e){var r;return function(a){return r=r||Jy(t,e),new Worker(r,a)}}var Iy=Qy(function(){(function(){"__worker_loader_strict__";var t={exports:{}},e=function(){function w(m,E){for(var M=0;M<E.length;M++){var D=E[M];D.enumerable=D.enumerable||!1,D.configurable=!0,"value"in D&&(D.writable=!0),Object.defineProperty(m,D.key,D)}}return function(m,E,M){return E&&w(m.prototype,E),M&&w(m,M),m}}();function r(w,m){if(!(w instanceof m))throw new TypeError("Cannot call a class as a function")}var n=function(){function w(){r(this,w),Object.defineProperty(this,"__listeners",{value:{},enumerable:!1,writable:!1})}return e(w,[{key:"emit",value:function(E){if(!this.__listeners[E])return this;for(var M=arguments.length,D=Array(M>1?M-1:0),N=1;N<M;N++)D[N-1]=arguments[N];var G=!0,_=!1,B=void 0;try{for(var F=this.__listeners[E][Symbol.iterator](),z;!(G=(z=F.next()).done);G=!0){var U=z.value;U.apply(void 0,D)}}catch(k){_=!0,B=k}finally{try{!G&&F.return&&F.return()}finally{if(_)throw B}}return this}},{key:"once",value:function(E,M){var D=this,N=function G(){D.off(E,G),M.apply(void 0,arguments)};return this.on(E,N)}},{key:"on",value:function(E,M){return this.__listeners[E]||(this.__listeners[E]=[]),this.__listeners[E].push(M),this}},{key:"off",value:function(E,M){return M?this.__listeners[E]=this.__listeners[E].filter(function(D){return D!==M}):this.__listeners[E]=[],this}}]),w}(),a=n,i=function(){function w(m,E){for(var M=0;M<E.length;M++){var D=E[M];D.enumerable=D.enumerable||!1,D.configurable=!0,"value"in D&&(D.writable=!0),Object.defineProperty(m,D.key,D)}}return function(m,E,M){return E&&w(m.prototype,E),M&&w(m,M),m}}(),s=function w(m,E,M){m===null&&(m=Function.prototype);var D=Object.getOwnPropertyDescriptor(m,E);if(D===void 0){var N=Object.getPrototypeOf(m);return N===null?void 0:w(N,E,M)}else{if("value"in D)return D.value;var G=D.get;return G===void 0?void 0:G.call(M)}},o=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(w){return typeof w}:function(w){return w&&typeof Symbol=="function"&&w.constructor===Symbol&&w!==Symbol.prototype?"symbol":typeof w};function c(w){if(Array.isArray(w)){for(var m=0,E=Array(w.length);m<w.length;m++)E[m]=w[m];return E}else return Array.from(w)}function u(w,m){if(!(w instanceof m))throw new TypeError("Cannot call a class as a function")}function g(w,m){if(!w)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return m&&(typeof m=="object"||typeof m=="function")?m:w}function f(w,m){if(typeof m!="function"&&m!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof m);w.prototype=Object.create(m&&m.prototype,{constructor:{value:w,enumerable:!1,writable:!0,configurable:!0}}),m&&(Object.setPrototypeOf?Object.setPrototypeOf(w,m):w.__proto__=m)}function l(w,m,E){return m in w?Object.defineProperty(w,m,{value:E,enumerable:!0,configurable:!0,writable:!0}):w[m]=E,w}var p=a,d=0,h=1,T=0,v=1,C="main",S=function(m){return(typeof m>"u"?"undefined":o(m))==="object"&&m!==null&&typeof m.then=="function"&&typeof m.catch=="function"};function x(w){var m=l({},C,w),E=self.postMessage.bind(self),M=new(function(B){f(F,B);function F(){return u(this,F),g(this,(F.__proto__||Object.getPrototypeOf(F)).apply(this,arguments))}return i(F,[{key:"emit",value:function(U){for(var k=arguments.length,L=Array(k>1?k-1:0),W=1;W<k;W++)L[W-1]=arguments[W];return L.length==1&&L[0]instanceof R?E({eventName:U,args:L},L[0].transferable):E({eventName:U,args:L}),this}},{key:"emitLocally",value:function(U){for(var k,L=arguments.length,W=Array(L>1?L-1:0),H=1;H<L;H++)W[H-1]=arguments[H];(k=s(F.prototype.__proto__||Object.getPrototypeOf(F.prototype),"emit",this)).call.apply(k,[this,U].concat(W))}},{key:"operation",value:function(U,k){return m[U]=k,this}}]),F}(p)),D=function(F,z,U){var k=function($){$&&$ instanceof R?G(F,v,$.payload,$.transferable):G(F,v,$)},L=function($){G(F,T,{message:$.message,stack:$.stack})};try{var W=N(F,z,U);S(W)?W.then(k).catch(L):k(W)}catch(H){L(H)}},N=function(F,z,U){var k=m[U||C];if(!k)throw new Error("Not found handler for this request");return k(z,_.bind(null,F))},G=function(F,z,U){var k=arguments.length>3&&arguments[3]!==void 0?arguments[3]:[];E([d,F,z,U],k)},_=function(F,z,U){if(!z)throw new Error("eventName is required");if(typeof z!="string")throw new Error("eventName should be string");E([h,F,z,U])};return self.addEventListener("message",function(B){var F=B.data;Array.isArray(F)?D.apply(void 0,c(F)):F&&F.eventName&&M.emitLocally.apply(M,[F.eventName].concat(c(F.args)))}),M}var R=function w(m,E){u(this,w),this.payload=m,this.transferable=E};t.exports=x,t.exports.TransferableResponse=R;var O=t.exports;O(function(w,m){var E=w.array,M=w.min,D=w.max,N=w.component||0,G=w.numberOfComponents||1,_=w.numberOfBins,B=D-M,F=new Float32Array(_);F.fill(0);for(var z=E.length,U=N;U<z;U+=G){var k=Math.floor((_-1)*(Number(E[U])-M)/B);F[k]+=1}return Promise.resolve(new O.TransferableResponse(F,[F.buffer]))})})()},null);const ua=.001,Wa={adjustPosition:"-webkit-grab",adjustHeight:"row-resize",adjustBias:"crosshair",adjustWidth:"col-resize",adjustZoom:"col-resize"},we=[],$a={adjustPosition(t,e,r){let{originalXY:n,gaussian:a,originalGaussian:i}=r;const s=i.position-n[0];return a.position=t+s,!0},adjustHeight(t,e,r){let{model:n,gaussian:a}=r;return a.height=1-e,a.height=Math.min(1,Math.max(n.gaussianMinimumHeight,a.height)),!0},adjustBias(t,e,r){let{originalXY:n,gaussian:a,originalGaussian:i}=r;return a.xBias=i.xBias-(n[0]-t)/a.height,a.yBias=i.yBias+4*(n[1]-e)/a.height,a.xBias=Math.max(-1,Math.min(1,a.xBias)),a.yBias=Math.max(0,Math.min(2,a.yBias)),!0},adjustWidth(t,e,r){let{originalXY:n,gaussian:a,originalGaussian:i,gaussianSide:s}=r;return a.width=s<0?i.width-(n[0]-t):i.width+(n[0]-t),a.width<ua&&(a.width=ua),!0},adjustZoom(t,e,r){let{rangeZoom:n,publicAPI:a}=r;const i=n[1]-n[0],s=(t-n[0])/i,o=Math.abs(s-n[0]),c=Math.abs(s-n[1]);if(Math.abs(s-.5*(n[0]+n[1]))<Math.min(o,c)){const g=i*.5;n[0]=Math.min(Math.max(s-g,0),n[1]-.1),n[1]=Math.max(Math.min(s+g,1),n[0]+.1)}else o<c?n[0]=Math.min(Math.max(s,0),n[1]-.1):n[1]=Math.max(Math.min(s,1),n[0]+.1);return a.invokeZoomChange(n),!1}};function Zt(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:256;const r=[];for(;r.length<e;)r.push(0);let n=t.length;for(;n--;){const{position:a,height:i,width:s,xBias:o,yBias:c}=t[n];for(let u=0;u<e;u++){const g=u/(e-1);if(g>a+s||g<a-s){r[u]<0&&(r[u]=0);continue}const f=s<ua?ua:s;let l=0;o===0||g===a+o?l=g:g>a+o?f===o?l=a:l=a+(g-a-o)*(f/(f-o)):-f===o?l=a:l=a-(g-a-o)*(f/(f+o));const p=(l-a)/f,d=Math.exp(-(4*p*p)),h=1-p*p,T=1;let v;c<1?v=c*h+(1-c)*d:v=(2-c)*h+(c-1)*T;const C=i*v;C>r[u]&&(r[u]=C)}}return r}function e1(t,e,r,n){const a=Zt(t,e),i=[],s=(r[1]-r[0])/(a.length-1),o=.5,c=0;for(let u=0;u<a.length;u++){const g=r[0]+s*u,f=a[u];i.push({x:g,y:f,midpoint:o,sharpness:c})}n.setNodes(i)}function gn(t,e,r){let n=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{lineWidth:1,strokeStyle:"#000"};const a=e[3],i=e[2]/(r.length-1),s=!!n.fillStyle,o=a+e[1];t.lineWidth=n.lineWidth,t.strokeStyle=n.strokeStyle,t.beginPath(),t.moveTo(e[0],e[1]+e[3]);for(let c=0;c<r.length;c++)t.lineTo(e[0]+c*i,Math.max(e[1],o-r[c]*a));if(s){if(t.fillStyle=n.fillStyle,t.lineTo(e[0]+e[2],e[1]+e[3]),n.clip){t.clip();return}t.fill()}t.stroke()}function t1(t,e,r,n){const a=n||document.createElement("canvas");a.setAttribute("width",e),a.setAttribute("height",256);const i=a.getContext("2d"),s=t.getUint8Table(r[0],r[1],e,4),o=i.getImageData(0,0,e,256);for(let g=0;g<256;g++)o.data.set(s,g*4*e);const c=256*e*4,u=e*4;for(let g=3;g<c;g+=4)o.data[g]=255-Math.floor(g/u);return i.putImageData(o,0,0),a}function n1(t,e,r){const n=r||document.createElement("canvas");return n.setAttribute("width",e),n.setAttribute("height",256),n.getContext("2d").drawImage(t,0,0,t.width,t.height,0,0,e,256),n}function Vt(t,e,r){let n=arguments.length>3&&arguments[3]!==void 0?arguments[3]:[0,1];return[n[0]+(t-r[0])/r[2]*(n[1]-n[0]),(e-r[1])/r[3]]}function Bn(t,e){const r=e.map(a=>Math.abs(a.position-t)),n=Math.min(...r);return r.indexOf(n)}function pt(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0;return r=>{const{offsetX:n,offsetY:a}=r;e&&r.preventDefault(),t(n,a)}}function r1(){const t=we.length;for(var e=arguments.length,r=new Array(e),n=0;n<e;n++)r[n]=arguments[n];return we.push({callbacks:r,timeout:0,deltaT:200,count:0,ready:!1}),t}function a1(){we.filter(t=>t.ready).forEach(t=>{t.callbacks.forEach(e=>{e.touches===t.touches&&e.clicks===t.count&&e.action(...t.singleTouche)}),t.ts=0,t.count=0,t.touches=0,t.ready=!1})}function Vr(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:1,n=arguments.length>3&&arguments[3]!==void 0?arguments[3]:!0;return a=>{const i=a.target.getBoundingClientRect(),o=Array.prototype.map.call(a.touches,c=>[c.pageX-i.left,c.pageY-i.top]).reduce((c,u)=>[c[0]+u[0],c[1]+u[1]],[0,0]).map(c=>c/a.touches.length);a.type==="touchstart"?(clearTimeout(we[t].timeout),we[t].ts=a.timeStamp,we[t].singleTouche=o,we[t].touches=a.touches.length):a.type==="touchmove"?(we[t].ts=0,we[t].count=0,we[t].ready=!1):a.type==="touchend"&&(a.timeStamp-we[t].ts<we[t].deltaT?(we[t].count+=1,we[t].ready=!0,n&&a.preventDefault(),we[t].timeout=setTimeout(a1,we[t].deltaT)):we[t].ready=!1),a.touches.length===r&&(e(...o),n&&a.preventDefault())}}function Ti(t,e,r){return n=>t()?e(n):r(n)}function En(t,e){if(!e)return t;const r=t.length-1,n=e.map(a=>Math.round(a*r));return t.slice(n[0],n[1]+1)}function i1(t,e){return e?(t-e[0])/(e[1]-e[0]):t}const s1={applyGaussianToPiecewiseFunction:e1,computeOpacities:Zt,createListener:pt,drawChart:gn,findGaussian:Bn,listenerSelector:Ti,normalizeCoordinates:Vt};function o1(t,e){e.classHierarchy.push("vtkPiecewiseGaussianWidget"),e.canvas||(e.canvas=document.createElement("canvas")),t.setContainer=a=>{e.container&&e.container!==a&&e.container.removeChild(e.canvas),e.container!==a&&(e.container=a,e.container&&e.container.appendChild(e.canvas),t.modified())},t.setGaussians=a=>{e.gaussians!==a&&(e.gaussians=a,e.opacities=Zt(e.gaussians,e.piecewiseSize),t.invokeOpacityChange(t),t.modified())},t.addGaussian=(a,i,s,o,c)=>{const u=e.gaussians.length;return e.gaussians.push({position:a,height:i,width:s,xBias:o,yBias:c}),e.opacities=Zt(e.gaussians,e.piecewiseSize),t.invokeOpacityChange(t),t.modified(),u},t.removeGaussian=a=>{e.gaussians.splice(a,1),e.opacities=Zt(e.gaussians,e.piecewiseSize),t.invokeOpacityChange(t),t.modified()},t.setSize=(a,i)=>{e.canvas.setAttribute("width",a),e.canvas.setAttribute("height",i),(e.size[0]!==a||e.size[1]!==i)&&(e.size=[a,i],e.colorCanvasMTime=0,t.modified())},t.updateStyle=a=>{e.style={...e.style,...a},t.modified()},t.setDataArray=function(a){let{numberOfBinToConsiders:i=1,numberOfBinsToSkip:s=1,numberOfComponents:o=1,component:c=0}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};e.histogram=null,e.histogramArray=a,e.dataRange=xc(a,c,o);const[u,g]=e.dataRange,f=4;let l=Math.floor(a.length/f)||1;l+=l%o;let p=0;const d=[],h=[];for(;p<a.length;){const T=new Iy;h.push(T);const v=new kl(T),C=p,S=Math.min(p+l,a.length-1),x=new a.constructor(a.slice(C,S+1));d.push(v.postMessage({array:x,component:c,numberOfComponents:o,min:u,max:g,numberOfBins:e.numberOfBins},[x.buffer])),p+=l}Promise.all(d).then(T=>{h.forEach(x=>x.terminate()),e.histogram=new Float32Array(e.numberOfBins),e.histogram.fill(0),T.forEach(x=>{for(let R=0,O=x.length;R<O;++R)e.histogram[R]+=x[R]});const v=Math.min(i,e.histogram.length-s),C=Array.from(e.histogram);C.sort((x,R)=>Number(x)-Number(R));for(let x=0;x<s;x++)C.pop();for(;C.length>v;)C.shift();const S=C.reduce((x,R)=>x+R,0)/v;for(let x=0,R=e.histogram.length;x<R;++x)e.histogram[x]/=S;t.modified(),setTimeout(t.render,0)}),t.modified()},t.onClick=(a,i)=>{const[s,o]=Vt(a,i,e.graphArea,e.enableRangeZoom?e.rangeZoom:null);if(s<0&&e.style.iconSize>1){const c=e.style.iconSize+e.style.padding;let u=c,g=0;for(;i>u;)g+=1,u+=c;switch(g){case 0:{const f=t.addGaussian(0,1,.1,0,0),l=e.gaussians[f],p={...l},d=$a.adjustPosition;e.activeGaussian=f,e.selectedGaussian=f,y.setImmediate(()=>{t.onDown(a,i),e.dragAction={originalXY:[0,0],action:d,gaussian:l,originalGaussian:p}});break}case 1:{e.selectedGaussian!==-1&&t.removeGaussian(e.selectedGaussian);break}default:e.selectedGaussian=-1,e.dragAction=null}}else if(s<0||s>1||o<0||o>1)e.selectedGaussian=-1,e.dragAction=null;else{const c=Bn(s,e.gaussians);c!==e.selectedGaussian&&(e.selectedGaussian=c,t.modified())}return!0},t.onHover=(a,i)=>{const s=20/e.canvas.height,[o,c]=Vt(a,i,e.graphArea,e.enableRangeZoom?e.rangeZoom:null),[u]=Vt(a,i,e.graphArea),g=o<0?e.selectedGaussian:Bn(o,e.gaussians);e.canvas.style.cursor="default";const f=e.gaussians[g];if(e.enableRangeZoom&&u>=0&&i<e.graphArea[1]-6){const l=(e.rangeZoom[1]-e.rangeZoom[0])/3;u<e.rangeZoom[0]+l||u>e.rangeZoom[1]-l?e.canvas.style.cursor=Wa.adjustZoom:e.canvas.style.cursor=Wa.adjustPosition,e.dragAction={rangeZoom:e.rangeZoom,action:$a.adjustZoom}}else if(f&&u>=0){const l=1-c;let p=null;l>f.height+s?p="adjustPosition":l>f.height-s?Math.abs(o-f.position)<s?p="adjustHeight":p="adjustPosition":l>f.height*.5+s?p="adjustPosition":l>f.height*.5-s?Math.abs(o-f.position)<s?p="adjustBias":p="adjustPosition":l>s?p="adjustPosition":p="adjustWidth",e.canvas.style.cursor=Wa[p];const d=$a[p],h={...f};e.dragAction={originalXY:[o,c],action:d,gaussian:f,originalGaussian:h}}return g!==e.activeGaussian&&(e.activeGaussian=g,t.modified()),!0},t.onDown=(a,i)=>{e.mouseIsDown||t.invokeAnimation(!0),e.mouseIsDown=!0;const s=Vt(a,i,e.graphArea,e.enableRangeZoom?e.rangeZoom:null)[0],o=Bn(s,e.gaussians);e.gaussianSide=0;const c=e.gaussians[o];return c&&(e.gaussianSide=c.position-s),o!==e.selectedGaussian&&s>0&&(e.selectedGaussian=o,t.modified()),!0},t.onDrag=(a,i)=>{if(e.dragAction){const[s,o]=Vt(a,i,e.graphArea,e.enableRangeZoom?e.rangeZoom:null),{action:c}=e.dragAction;c(s,o,{gaussianSide:e.gaussianSide,model:e,publicAPI:t,...e.dragAction})&&(e.opacities=Zt(e.gaussians,e.piecewiseSize),t.invokeOpacityChange(t,!0)),t.modified()}return!0},t.onUp=(a,i)=>(e.mouseIsDown&&t.invokeAnimation(!1),e.mouseIsDown=!1,!0),t.onLeave=(a,i)=>(t.onUp(a,i),e.canvas.style.cursor="default",e.activeGaussian=-1,t.modified(),!0),t.onAddGaussian=(a,i)=>{const[s,o]=Vt(a,i,e.graphArea,e.enableRangeZoom?e.rangeZoom:null);return s>=0&&t.addGaussian(s,1-o,.1,0,0),!0},t.onRemoveGaussian=(a,i)=>{const s=Vt(a,i,e.graphArea,e.enableRangeZoom?e.rangeZoom:null)[0],o=Bn(s,e.gaussians);return s>=0&&o!==-1&&t.removeGaussian(o),!0},t.bindMouseListeners=()=>{if(!e.listeners){const a=()=>!!e.mouseIsDown,i=r1({clicks:1,touches:1,action:t.onClick},{clicks:2,touches:1,action:t.onAddGaussian},{clicks:2,touches:2,action:t.onRemoveGaussian});e.listeners={mousemove:Ti(a,pt(t.onDrag),pt(t.onHover)),dblclick:pt(t.onAddGaussian),contextmenu:pt(t.onRemoveGaussian),click:pt(t.onClick),mouseup:pt(t.onUp),mousedown:pt(t.onDown),mouseout:pt(t.onLeave),touchstart:Vr(i,y.chain(t.onHover,t.onDown)),touchmove:Ti(a,Vr(i,t.onDrag),Vr(i,t.onHover)),touchend:Vr(i,t.onUp,0)},Object.keys(e.listeners).forEach(s=>{e.canvas.addEventListener(s,e.listeners[s],!1)})}},t.unbindMouseListeners=()=>{e.listeners&&(Object.keys(e.listeners).forEach(a=>{e.canvas.removeEventListener(a,e.listeners[a])}),delete e.listeners)},t.render=()=>{const a=e.canvas.getContext("2d");a.imageSmoothingEnabled=!0;const[i,s]=e.size,o=e.style.padding,c=[Math.floor(e.style.iconSize+o),Math.floor(o),Math.ceil(i-2*o-e.style.iconSize),Math.ceil(s-2*o)],u=e.style.zoomControlHeight;if(e.enableRangeZoom&&(c[1]+=Math.floor(u),c[3]-=Math.floor(u)),e.graphArea=c,a.clearRect(0,0,i,s),a.lineJoin="round",a.fillStyle=e.style.backgroundColor,a.fillRect(...c),e.style.iconSize>1){const f=Math.round(e.style.iconSize/2-e.style.strokeWidth),l=Math.round(f+o+e.style.strokeWidth);a.beginPath(),a.lineWidth=e.style.buttonStrokeWidth,a.strokeStyle=e.style.buttonStrokeColor,a.arc(l-o/2,l,f,0,2*Math.PI,!1),a.fillStyle=e.style.buttonFillColor,a.fill(),a.stroke(),a.moveTo(l-f+e.style.strokeWidth+2-o/2,l),a.lineTo(l+f-e.style.strokeWidth-2-o/2,l),a.stroke(),a.moveTo(l-o/2,l-f+e.style.strokeWidth+2),a.lineTo(l-o/2,l+f-e.style.strokeWidth-2),a.stroke(),e.selectedGaussian===-1?(a.fillStyle=e.style.buttonDisableFillColor,a.lineWidth=e.style.buttonDisableStrokeWidth,a.strokeStyle=e.style.buttonDisableStrokeColor):(a.fillStyle=e.style.buttonFillColor,a.lineWidth=e.style.buttonStrokeWidth,a.strokeStyle=e.style.buttonStrokeColor),a.beginPath(),a.arc(l-o/2,l+o/2+e.style.iconSize,f,0,2*Math.PI,!1),a.fill(),a.stroke(),a.moveTo(l-f+e.style.strokeWidth+2-o/2,l+o/2+e.style.iconSize),a.lineTo(l+f-e.style.strokeWidth-2-o/2,l+o/2+e.style.iconSize),a.stroke()}if(e.histogram&&gn(a,c,En(e.histogram,e.rangeZoom),{lineWidth:1,strokeStyle:e.style.histogramColor,fillStyle:e.style.histogramColor}),gn(a,c,En(e.opacities,e.enableRangeZoom&&e.rangeZoom),{lineWidth:e.style.strokeWidth,strokeStyle:e.style.strokeColor}),e.colorTransferFunction&&e.colorTransferFunction.getSize()){const f=e.dataRange||e.colorTransferFunction.getMappingRange();(!e.colorCanvas||e.colorCanvasMTime!==e.colorTransferFunction.getMTime())&&(e.colorCanvasMTime=e.colorTransferFunction.getMTime(),e.colorCanvas=t1(e.colorTransferFunction,c[2],f,e.colorCanvas)),a.save(),gn(a,c,En(e.opacities,e.enableRangeZoom&&e.rangeZoom),{lineWidth:1,strokeStyle:"rgba(0,0,0,0)",fillStyle:"rgba(0,0,0,1)",clip:!0}),e.enableRangeZoom?a.drawImage(e.colorCanvas,e.rangeZoom[0]*c[2],0,c[2],c[3],c[0],c[1],c[2]/(e.rangeZoom[1]-e.rangeZoom[0]),c[3]):a.drawImage(e.colorCanvas,c[0],c[1]),a.restore()}else e.backgroundImage&&(e.colorCanvas=n1(e.backgroundImage,c[2],e.colorCanvas),a.save(),gn(a,c,En(e.opacities,e.enableRangeZoom&&e.rangeZoom),{lineWidth:1,strokeStyle:"rgba(0,0,0,0)",fillStyle:"rgba(0,0,0,1)",clip:!0}),a.drawImage(e.colorCanvas,c[0],c[1]),a.restore());e.enableRangeZoom&&(a.fillStyle=e.style.zoomControlColor,a.beginPath(),a.rect(c[0]+e.rangeZoom[0]*c[2],0,(e.rangeZoom[1]-e.rangeZoom[0])*c[2],u),a.fill());const g=e.gaussians[e.activeGaussian]||e.gaussians[e.selectedGaussian];if(g){const f=Zt([g],c[2]);gn(a,c,En(f,e.enableRangeZoom&&e.rangeZoom),{lineWidth:e.style.activeStrokeWidth,strokeStyle:e.style.activeColor});const l=c[0]+i1(g.position,e.enableRangeZoom&&e.rangeZoom)*c[2],p=c[1]+(1-g.height)*c[3],d=c[1]+(1-.5*g.height)*c[3],h=c[1]+c[3];let T=g.width*c[2];e.enableRangeZoom&&(T/=e.rangeZoom[1]-e.rangeZoom[0]),a.lineWidth=e.style.handleWidth,a.strokeStyle=e.style.handleColor,a.fillStyle=e.style.backgroundColor,a.beginPath(),a.moveTo(l,c[1]+(1-g.height)*c[3]),a.lineTo(l,c[1]+c[3]),a.stroke(),a.beginPath(),a.arc(l,p,6,0,2*Math.PI),a.fill(),a.stroke();const v=Math.min(T*.1,g.height*c[3]*.2);a.beginPath(),a.rect(l-v,d-v,v*2,v*2),a.fill(),a.stroke(),a.beginPath();const C=T*.8;a.rect(l-C,h-5,2*C,10),a.fill(),a.stroke()}},t.getOpacityNodes=a=>{const i=a||e.dataRange,s=(i[1]-i[0])/(e.opacities.length-1),o=[],c=.5,u=0;for(let g=0;g<e.opacities.length;g++){const f=i[0]+s*g,l=e.opacities[g];o.push({x:f,y:l,midpoint:c,sharpness:u})}return o},t.applyOpacity=(a,i)=>{const s=t.getOpacityNodes(i);a.setNodes(s)},t.getOpacityRange=a=>{const i=a||e.dataRange,s=(i[1]-i[0])/(e.opacities.length-1);let o=e.opacities.length-1,c=0;for(let u=0;u<e.opacities.length;u++)e.opacities[u]>0&&(o=Math.min(o,u)),e.opacities[u]>0&&(c=Math.max(c,u));return[i[0]+o*s,i[0]+c*s]};const r=t.setEnableRangeZoom;t.setEnableRangeZoom=a=>{const i=r(a);return i&&(e.colorCanvasMTime=0,e.rangeZoom=[0,1]),i};const n=t.setRangeZoom;t.setRangeZoom=function(){const a=n(...arguments);return a&&(e.colorCanvasMTime=0),a},t.onModified(()=>t.render()),t.setSize(...e.size)}const c1={histogram:[],numberOfBins:256,histogramArray:null,dataRange:[0,1],gaussians:[],opacities:[],size:[600,300],piecewiseSize:256,colorCanvasMTime:0,gaussianMinimumHeight:.05,style:{backgroundColor:"rgba(255, 255, 255, 1)",histogramColor:"rgba(200, 200, 200, 0.5)",strokeColor:"rgb(0, 0, 0)",activeColor:"rgb(0, 0, 150)",buttonDisableFillColor:"rgba(255, 255, 255, 0.5)",buttonDisableStrokeColor:"rgba(0, 0, 0, 0.5)",buttonStrokeColor:"rgba(0, 0, 0, 1)",buttonFillColor:"rgba(255, 255, 255, 1)",handleColor:"rgb(0, 150, 0)",strokeWidth:2,activeStrokeWidth:3,buttonStrokeWidth:1.5,handleWidth:3,iconSize:20,padding:10,zoomControlHeight:10,zoomControlColor:"#999"},activeGaussian:-1,selectedGaussian:-1,enableRangeZoom:!0,rangeZoom:[0,1]};function Ef(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,c1,r),y.obj(t,e),y.setGet(t,e,["piecewiseSize","numberOfBins","colorTransferFunction","backgroundImage","enableRangeZoom","gaussianMinimumHeight"]),y.setGetArray(t,e,["rangeZoom"],2),y.get(t,e,["size","canvas","gaussians"]),y.event(t,e,"opacityChange"),y.event(t,e,"animation"),y.event(t,e,"zoomChange"),o1(t,e)}const u1=y.newInstance(Ef,"vtkPiecewiseGaussianWidget");var f1={newInstance:u1,extend:Ef,...s1};const g1={Gaussians:[{position:.5,height:1,width:.5,xBias:.5,yBias:.5}],Points:[[0,0],[1,1]],Nodes:[{x:0,y:0,midpoint:.5,sharpness:0},{x:1,y:1,midpoint:.5,sharpness:0}]},l1={Gaussians:0,Points:1,Nodes:2};var p1={Defaults:g1,Mode:l1};const{Mode:Zn,Defaults:en}=p1;function h1(t,e,r){const n=e[1]-e[0],a=t.map(i=>{let[s,o]=i;return[s*n+e[0],o]});r.removeAllPoints(),a.forEach(i=>{let[s,o]=i;return r.addPoint(s,o)})}function d1(t,e,r){const n=e[1]-e[0],a=t.map(i=>({...i,x:i.x*n+e[0]}));r.setNodes(a)}function io(t){return t.map(e=>({...e}))}function T1(t,e){e.classHierarchy.push("vtkPiecewiseFunctionProxy"),e.piecewiseFunction=e.piecewiseFunction||ca.newInstance(),t.setGaussians=r=>{e.gaussians=io(r||[]),e.gaussians.length===0&&(e.gaussians=io(en.Gaussians)),t.applyMode()},t.setPoints=r=>{e.points=(r||[]).slice(),e.points.length===0&&(e.points=en.Points.slice()),t.applyMode()},t.setNodes=r=>{e.nodes=(r||[]).slice(),e.nodes.length===0&&(e.nodes=en.Nodes.slice()),t.applyMode()},t.setMode=r=>{e.mode!==r&&(e.mode=r,t.applyMode())},t.applyMode=()=>{switch(e.mode){case Zn.Gaussians:f1.applyGaussianToPiecewiseFunction(e.gaussians,255,e.dataRange,e.piecewiseFunction),t.modified();break;case Zn.Points:h1(e.points,e.dataRange,e.piecewiseFunction),t.modified();break;case Zn.Nodes:d1(e.nodes,e.dataRange,e.piecewiseFunction),t.modified();break}},t.getLookupTableProxy=()=>e.proxyManager.getLookupTable(e.arrayName),t.setDataRange=(r,n)=>{(e.dataRange[0]!==r||e.dataRange[1]!==n)&&(e.dataRange[0]=r,e.dataRange[1]=n,t.applyMode())},t.applyMode()}const v1={mode:Zn.Gaussians,gaussians:en.Gaussians,points:en.Points,nodes:en.Nodes,arrayName:"No array associated",arrayLocation:"pointData",dataRange:[0,1]};function Df(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,v1,r),y.obj(t,e),y.setGet(t,e,["arrayName"]),y.get(t,e,["piecewiseFunction","gaussians","nodes","points","mode","dataRange"]),T1(t,e),y.proxy(t,e)}const y1=y.newInstance(Df,"vtkPiecewiseFunctionProxy");var xM={newInstance:y1,extend:Df,Mode:Zn,Defaults:en};const{vtkErrorMacro:vi}=y,C1={Unknown:0,Scalar:1,RGB:2,RGBA:3,Offset:4,Vector:5,Point:6,CovariantVector:7,SymmetricSecondRankTensor:8,DiffusionTensor3D:9,Complex:10,FixedArray:11,Array:12,Matrix:13,VariableLengthVector:14,VariableSizeMatrix:15},Y={Unknown:"Unknown",Scalar:"Scalar",RGB:"RGB",RGBA:"RGBA",Offset:"Offset",Vector:"Vector",Point:"Point",CovariantVector:"CovariantVector",SymmetricSecondRankTensor:"SymmetricSecondRankTensor",DiffusionTensor3D:"DiffusionTensor3D",Complex:"Complex",FixedArray:"FixedArray",Array:"Array",Matrix:"Matrix",VariableLengthVector:"VariableLengthVector",VariableSizeMatrix:"VariableSizeMatrix"},yi=new Map([["Uint8Array","uint8"],["Int8Array","int8"],["Uint16Array","uint16"],["Int16Array","int16"],["Uint32Array","uint32"],["Int32Array","int32"],["Float32Array","float32"],["Float64Array","float64"]]),so=new Map([["uint8","Uint8Array"],["int8","Int8Array"],["uint16","Uint16Array"],["int16","Int16Array"],["uint32","Uint32Array"],["int32","Int32Array"],["float32","Float32Array"],["float64","Float64Array"]]);function S1(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};const r={origin:[0,0,0],spacing:[1,1,1]},n=[1,1,1],a=[1,0,0,0,1,0,0,0,1],i=t.direction.data===void 0,s=i?Y:C1;for(let u=0;u<t.imageType.dimension;++u){r.origin[u]=t.origin[u],r.spacing[u]=t.spacing[u],n[u]=t.size[u];for(let g=0;g<t.imageType.dimension;++g)i?a[g+u*3]=t.direction[u+g*t.imageType.dimension]:a[g+u*3]=t.direction.data[u+g*t.imageType.dimension]}const o=Ji.newInstance(r),c=A.newInstance({name:e.scalarArrayName||"Scalars",values:t.data,numberOfComponents:t.imageType.components});switch(o.setDirection(a),o.setDimensions(...n),o.getPointData().setScalars(c),i?s[t.imageType.pixelType]:t.imageType.pixelType){case s.Scalar:break;case s.RGB:break;case s.RGBA:break;case s.Offset:break;case s.Vector:t.imageType.dimension===3&&t.imageType.components===3&&o.getPointData().setVectors(c);break;case s.Point:break;case s.CovariantVector:t.imageType.dimension===3&&t.imageType.components===3&&o.getPointData().setVectors(c);break;case s.SymmetricSecondRankTensor:t.imageType.dimension===3&&t.imageType.components===6&&o.getPointData().setTensors(c);break;case s.DiffusionTensor3D:t.imageType.dimension===3&&t.imageType.components===6&&o.getPointData().setTensors(c);break;case s.Complex:break;case s.FixedArray:break;case s.Array:break;case s.Matrix:break;case s.VariableLengthVector:break;case s.VariableSizeMatrix:break;default:return vi(`Cannot handle unexpected itk-wasm pixel type ${t.imageType.pixelType}`),null}return o}function x1(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;const r=3,n={imageType:{dimension:r,pixelType:Y.Scalar,componentType:"",components:1},name:"vtkImageData",origin:t.getOrigin(),spacing:t.getSpacing(),direction:new Float64Array(9),size:t.getDimensions()},a=t.getDirection();for(let o=0;o<r;++o)for(let c=0;c<r;++c)n.direction[o+c*r]=a[c+o*r];const i=t.getPointData();let s;return i.getTensors()!==null?(n.imageType.pixelType=Y.DiffusionTensor3D,s=i.getTensors()):i.getVectors()!=null?(n.imageType.pixelType=Y.Vector,s=i.getVectors()):s=i.getScalars(),n.imageType.componentType=yi.get(s.getDataType()),e?n.data=s.getData().slice(0):n.data=s.getData(),n}function w1(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};const r=[];t.pointData.length&&r.push({data:{vtkClass:"vtkDataArray",name:e.pointDataName||"PointData",numberOfComponents:t.polyDataType.pointPixelComponents,size:t.pointData.length,dataType:so.get(t.polyDataType.pointPixelComponentType),buffer:t.pointData.buffer,values:t.pointData}});const n=[];t.cellData.length&&n.push({data:{vtkClass:"vtkDataArray",name:e.cellDataName||"CellData",numberOfComponents:t.polyDataType.pointPixelComponents,size:t.cellData.length,dataType:so.get(t.polyDataType.pointPixelComponentType),buffer:t.cellData.buffer,values:t.cellData}});const a={points:{vtkClass:"vtkPoints",name:"_points",numberOfComponents:3,size:t.points.length,dataType:"Float32Array",buffer:t.points.buffer,values:t.points},verts:{vtkClass:"vtkCellArray",name:"_verts",numberOfComponents:1,size:t.verticesBufferSize,dataType:"Uint32Array",buffer:t.vertices.buffer,values:t.vertices},lines:{vtkClass:"vtkCellArray",name:"_lines",numberOfComponents:1,size:t.linesBufferSize,dataType:"Uint32Array",buffer:t.lines.buffer,values:t.lines},polys:{vtkClass:"vtkCellArray",name:"_polys",numberOfComponents:1,size:t.polygonsBufferSize,dataType:"Uint32Array",buffer:t.polygons.buffer,values:t.polygons},strips:{vtkClass:"vtkCellArray",name:"_strips",numberOfComponents:1,size:t.triangleStripsBufferSize,dataType:"Uint32Array",buffer:t.triangleStrips.buffer,values:t.triangleStrips},pointData:{vtkClass:"vtkDataSetAttributes",activeGlobalIds:-1,activeNormals:-1,activePedigreeIds:-1,activeScalars:-1,activeTCoords:-1,activeTensors:-1,activeVectors:-1,copyFieldFlags:[],doCopyAllOff:!1,doCopyAllOn:!0,arrays:r},cellData:{vtkClass:"vtkDataSetAttributes",activeGlobalIds:-1,activeNormals:-1,activePedigreeIds:-1,activeScalars:-1,activeTCoords:-1,activeTensors:-1,activeVectors:-1,copyFieldFlags:[],doCopyAllOff:!1,doCopyAllOn:!0,arrays:n}},i=Be.newInstance(a),s=i.getPointData(),o=i.getCellData();if(t.pointData.length)switch(Y[t.polyDataType.pointPixelType]){case Y.Scalar:s.setScalars(s.getArrayByIndex(0));break;case Y.RGB:break;case Y.RGBA:break;case Y.Offset:break;case Y.Vector:t.polyDataType.pointPixelComponents===3&&s.setVectors(s.getArrayByIndex(0));break;case Y.Point:break;case Y.CovariantVector:t.polyDataType.pointPixelComponents===3&&s.setVectors(s.getArrayByIndex(0));break;case Y.SymmetricSecondRankTensor:t.polyDataType.pointPixelComponents===6&&s.setTensors(s.getArrayByIndex(0));break;case Y.DiffusionTensor3D:t.polyDataType.pointPixelComponents===6&&s.setTensors(s.getArrayByIndex(0));break;case Y.Complex:break;case Y.FixedArray:break;case Y.Array:break;case Y.Matrix:break;case Y.VariableLengthVector:break;case Y.VariableSizeMatrix:break;default:return vi(`Cannot handle unexpected itk-wasm pixel type ${t.polyDataType.pointPixelType}`),null}if(t.cellData.length)switch(Y[t.polyDataType.cellPixelType]){case Y.Scalar:o.setScalars(o.getArrayByIndex(0));break;case Y.RGB:break;case Y.RGBA:break;case Y.Offset:break;case Y.Vector:t.polyDataType.pointPixelComponents===3&&o.setVectors(o.getArrayByIndex(0));break;case Y.Point:break;case Y.CovariantVector:t.polyDataType.pointPixelComponents===3&&o.setVectors(o.getArrayByIndex(0));break;case Y.SymmetricSecondRankTensor:t.polyDataType.pointPixelComponents===6&&o.setTensors(o.getArrayByIndex(0));break;case Y.DiffusionTensor3D:t.polyDataType.pointPixelComponents===6&&o.setTensors(o.getArrayByIndex(0));break;case Y.Complex:break;case Y.FixedArray:break;case Y.Array:break;case Y.Matrix:break;case Y.VariableLengthVector:break;case Y.VariableSizeMatrix:break;default:return vi(`Cannot handle unexpected itk-wasm pixel type ${t.polyDataType.pointPixelType}`),null}return i}function R1(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};const r={polyDataType:{pointPixelComponentType:"float32",pointPixelComponents:1,pointPixelType:"Scalar",cellPixelComponentType:"float32",cellPixelComponents:1,cellPixelType:"Scalar"},numberOfPoints:t.getNumberOfPoints(),points:t.getPoints().getData(),verticesBufferSize:t.getVerts().getNumberOfValues(),vertices:t.getVerts().getData(),linesBufferSize:t.getLines().getNumberOfValues(),lines:t.getLines().getData(),polygonsBufferSize:t.getPolys().getNumberOfValues(),polygons:t.getPolys().getData(),triangleStripsBufferSize:t.getStrips().getNumberOfValues(),triangleStrips:t.getStrips().getData(),numberOfPointPixels:0,pointData:new Float32Array,numberOfCellPixels:0,cellData:new Float32Array},n=t.getPointData();if(n.getNumberOfArrays()){const i=e.pointDataName?n.getArrayByName(e.pointDataName):n.getArrayByIndex(0);r.numberOfPointPixels=i.getNumberOfTuples(),r.pointData=i.getData(),r.polyDataType.pointPixelComponentType=yi.get(i.getDataType()),r.polyDataType.cellPixelComponentType=r.polyDataType.pointPixelComponentType,r.polyDataType.pointPixelComponents=i.getNumberOfComponents(),r.polyDataType.cellPixelComponents=r.polyDataType.pointPixelComponents,n.getTensors()===i?r.polyDataType.pointPixelType=Y.SymmetricSecondRankTensor:n.getVectors()===i&&(r.polyDataType.pointPixelType=Y.Vector),r.polyDataType.cellPixelType=r.polyDataType.pointPixelType}const a=t.getCellData();if(a.getNumberOfArrays()){const i=e.cellDataName?n.getArrayByName(e.cellDataName):n.getArrayByIndex(0);r.numberOfCellPixels=i.getNumberOfTuples(),r.cellData=i.getData(),r.polyDataType.cellPixelComponentType=yi.get(i.getDataType()),r.polyDataType.cellPixelComponents=i.getNumberOfComponents(),a.getTensors()===i?r.polyDataType.cellPixelType=Y.SymmetricSecondRankTensor:a.getVectors()===i?r.polyDataType.cellPixelType=Y.Vector:r.polyDataType.cellPixelType=Y.Scalar}return r}var wM={convertItkToVtkImage:S1,convertVtkToItkImage:x1,convertItkToVtkPolyData:w1,convertVtkToItkPolyData:R1};const M1=[],yn=Object.create(null);M1.filter(t=>t.RGBPoints).filter(t=>t.ColorSpace!=="CIELAB").forEach(t=>{yn[t.Name]=t});const Cn=Object.keys(yn);Cn.sort();function O1(t){return yn[t]}function m1(t){!t.RGBPoints||t.ColorSpace==="CIELAB"||(yn[t.Name]||(Cn.push(t.Name),Cn.sort()),yn[t.Name]=t)}function E1(t){const e=Cn.indexOf(t);e>-1&&Cn.splice(e,1),delete yn[t]}var D1={addPreset:m1,removePresetByName:E1,getPresetByName:O1,rgbPresetNames:Cn};function V1(t,e){e.classHierarchy.push("vtkAbstractManipulator"),e._prevWorldCoords=[],t.getOrigin=r=>e.userOrigin?e.userOrigin:e.useCameraFocalPoint?r.pokedRenderer.getActiveCamera().getFocalPoint():e.handleOrigin?e.handleOrigin:e.widgetOrigin?e.widgetOrigin:[0,0,0],t.getNormal=r=>e.userNormal?e.userNormal:e.useCameraNormal?r.pokedRenderer.getActiveCamera().getDirectionOfProjection():e.handleNormal?e.handleNormal:e.widgetNormal?e.widgetNormal:[0,0,1],e._computeDeltaFromPrevCoords=r=>{var n;return!((n=e._prevWorldCoords)!=null&&n.length)||!(r!=null&&r.length)?[0,0,0]:re(r,e._prevWorldCoords,[])},e._addWorldDeltas=r=>{const{worldCoords:n}=r,a=e._computeDeltaFromPrevCoords(n);return n&&(e._prevWorldCoords=n),{...r,...{worldDelta:a}}}}const L1={useCameraFocalPoint:!1,useCameraNormal:!1};function Vf(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,L1,r),y.obj(t,e),y.setGet(t,e,["useCameraFocalPoint","useCameraNormal"]),y.setGetArray(t,e,["userOrigin","handleOrigin","widgetOrigin","userNormal","handleNormal","widgetNormal"],3),V1(t,e)}const F1=y.newInstance(Vf,"vtkAbstractManipulator");var Lf={extend:Vf,newInstance:F1};function Ff(t,e,r,n,a,i){const s=i.displayToWorld(t,e,0,a),o=i.displayToWorld(t,e,1,a);return be.intersectWithLine(s,o,r,n).x}function k1(t,e){e.classHierarchy.push("vtkPlaneManipulator"),t.handleEvent=(r,n)=>e._addWorldDeltas({worldCoords:Ff(r.position.x,r.position.y,t.getOrigin(r),t.getNormal(r),r.pokedRenderer,n)})}function N1(t){return{...t}}function kf(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Lf.extend(t,e,N1(r)),k1(t,e)}const _1=y.newInstance(kf,"vtkPlaneManipulator");var Ci={intersectDisplayWithPlane:Ff,extend:kf,newInstance:_1};const Si={Unknown:0,LeftController:1,RightController:2},Wn={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7},G1={Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4};var Nf={Device:Si,Input:Wn,Axis:G1};const{Device:Lr,Input:Xt}=Nf,{vtkWarningMacro:Fr,vtkErrorMacro:kr,normalizeWheel:U1,vtkOnceErrorMacro:B1}=y,cn={ctrlKey:!1,altKey:!1,shiftKey:!1},za={"xr-standard":[Xt.Trigger,Xt.Grip,Xt.TrackPad,Xt.Thumbstick,Xt.A,Xt.B]},us=["StartAnimation","Animation","EndAnimation","PointerEnter","PointerLeave","MouseEnter","MouseLeave","StartMouseMove","MouseMove","EndMouseMove","LeftButtonPress","LeftButtonRelease","MiddleButtonPress","MiddleButtonRelease","RightButtonPress","RightButtonRelease","KeyPress","KeyDown","KeyUp","StartMouseWheel","MouseWheel","EndMouseWheel","StartPinch","Pinch","EndPinch","StartPan","Pan","EndPan","StartRotate","Rotate","EndRotate","Button3D","Move3D","StartPointerLock","EndPointerLock","StartInteraction","Interaction","EndInteraction","AnimationFrameRateUpdate"];function Dn(t){t.cancelable&&t.preventDefault()}function Nr(t){const e=Object.create(null);return t.forEach(r=>{let{pointerId:n,position:a}=r;e[n]=a}),e}function W1(t,e){e.classHierarchy.push("vtkRenderWindowInteractor");const r={...t},n=new Set,a=new Map;let i=1;t.start=()=>{!e.initialized&&(t.initialize(),!e.initialized)||t.startEventLoop()},t.setRenderWindow=h=>{kr("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor")},t.setInteractorStyle=h=>{e.interactorStyle!==h&&(e.interactorStyle!=null&&e.interactorStyle.setInteractor(null),e.interactorStyle=h,e.interactorStyle!=null&&e.interactorStyle.getInteractor()!==t&&e.interactorStyle.setInteractor(t))},t.initialize=()=>{e.initialized=!0,t.enable(),t.render()},t.enable=()=>t.setEnabled(!0),t.disable=()=>t.setEnabled(!1),t.startEventLoop=()=>Fr("empty event loop");function s(h,T){e._forcedRenderer||(e.currentRenderer=t.findPokedRenderer(h,T))}t.getCurrentRenderer=()=>(e.currentRenderer||s(0,0),e.currentRenderer);function o(h){const T=e._view.getCanvas(),v=T.getBoundingClientRect(),C=T.width/v.width,S=T.height/v.height,x={x:C*(h.clientX-v.left),y:S*(v.height-h.clientY+v.top),z:0};return(a.size<=1||!e.currentRenderer)&&s(x.x,x.y),x}const c=e._getScreenEventPositionFor||o;function u(h){return{controlKey:h.ctrlKey,altKey:h.altKey,shiftKey:h.shiftKey}}function g(h){const T=u(h);return{key:h.key,keyCode:h.charCode,...T}}function f(h){return h.pointerType||""}const l=()=>{if(e.container===null)return;const{container:h}=e;h.addEventListener("contextmenu",Dn),h.addEventListener("wheel",t.handleWheel),h.addEventListener("DOMMouseScroll",t.handleWheel),h.addEventListener("pointerenter",t.handlePointerEnter),h.addEventListener("pointerleave",t.handlePointerLeave),h.addEventListener("pointermove",t.handlePointerMove,{passive:!1}),h.addEventListener("pointerdown",t.handlePointerDown,{passive:!1}),h.addEventListener("pointerup",t.handlePointerUp),h.addEventListener("pointercancel",t.handlePointerCancel),document.addEventListener("keypress",t.handleKeyPress),document.addEventListener("keydown",t.handleKeyDown),document.addEventListener("keyup",t.handleKeyUp),document.addEventListener("pointerlockchange",t.handlePointerLockChange),h.style.touchAction="none",h.style.userSelect="none",h.style.webkitTapHighlightColor="rgba(0,0,0,0)"};t.bindEvents=h=>{if(h===null)return;r.setContainer(h)&&l()};const p=()=>{clearTimeout(e.moveTimeoutID),clearTimeout(e.wheelTimeoutID),e.moveTimeoutID=0,e.wheelTimeoutID=0,i=1;const{container:h}=e;h&&(h.removeEventListener("contextmenu",Dn),h.removeEventListener("wheel",t.handleWheel),h.removeEventListener("DOMMouseScroll",t.handleWheel),h.removeEventListener("pointerenter",t.handlePointerEnter),h.removeEventListener("pointerleave",t.handlePointerLeave),h.removeEventListener("pointermove",t.handlePointerMove,{passive:!1}),h.removeEventListener("pointerdown",t.handlePointerDown,{passive:!1}),h.removeEventListener("pointerup",t.handlePointerUp),h.removeEventListener("pointercancel",t.handlePointerCancel)),document.removeEventListener("keypress",t.handleKeyPress),document.removeEventListener("keydown",t.handleKeyDown),document.removeEventListener("keyup",t.handleKeyUp),document.removeEventListener("pointerlockchange",t.handlePointerLockChange),a.clear()};t.unbindEvents=()=>{p(),r.setContainer(null)},t.handleKeyPress=h=>{const T=g(h);t.keyPressEvent(T)},t.handleKeyDown=h=>{const T=g(h);t.keyDownEvent(T)},t.handleKeyUp=h=>{const T=g(h);t.keyUpEvent(T)},t.handlePointerEnter=h=>{const T={...u(h),position:c(h),deviceType:f(h)};t.pointerEnterEvent(T),T.deviceType==="mouse"&&t.mouseEnterEvent(T)},t.handlePointerLeave=h=>{const T={...u(h),position:c(h),deviceType:f(h)};t.pointerLeaveEvent(T),T.deviceType==="mouse"&&t.mouseLeaveEvent(T)},t.handlePointerDown=h=>{if(!(h.button>2||t.isPointerLocked()))switch(e.preventDefaultOnPointerDown&&Dn(h),h.target.hasPointerCapture(h.pointerId)&&h.target.releasePointerCapture(h.pointerId),e.container.setPointerCapture(h.pointerId),a.has(h.pointerId)&&Fr("[RenderWindowInteractor] duplicate pointerId detected"),a.set(h.pointerId,{pointerId:h.pointerId,position:c(h)}),h.pointerType){case"pen":case"touch":t.handleTouchStart(h);break;case"mouse":default:t.handleMouseDown(h);break}},t.handlePointerUp=h=>{if(a.has(h.pointerId))switch(e.preventDefaultOnPointerUp&&Dn(h),a.delete(h.pointerId),e.container.releasePointerCapture(h.pointerId),h.pointerType){case"pen":case"touch":t.handleTouchEnd(h);break;case"mouse":default:t.handleMouseUp(h);break}},t.handlePointerCancel=h=>{if(a.has(h.pointerId))switch(a.delete(h.pointerId),h.pointerType){case"pen":case"touch":t.handleTouchEnd(h);break;case"mouse":default:t.handleMouseUp(h);break}},t.handlePointerMove=h=>{if(a.has(h.pointerId)){const T=a.get(h.pointerId);T.position=c(h)}switch(h.pointerType){case"pen":case"touch":t.handleTouchMove(h);break;case"mouse":default:t.handleMouseMove(h);break}},t.handleMouseDown=h=>{const T={...u(h),position:c(h),deviceType:f(h)};switch(h.button){case 0:t.leftButtonPressEvent(T);break;case 1:t.middleButtonPressEvent(T);break;case 2:t.rightButtonPressEvent(T);break;default:kr(`Unknown mouse button pressed: ${h.button}`);break}},t.requestPointerLock=()=>{e.container&&e.container.requestPointerLock()},t.exitPointerLock=()=>{var h;return(h=document.exitPointerLock)==null?void 0:h.call(document)},t.isPointerLocked=()=>!!e.container&&document.pointerLockElement===e.container,t.handlePointerLockChange=()=>{t.isPointerLocked()?t.startPointerLockEvent():t.endPointerLockEvent()};function d(){e._view&&e.enabled&&e.enableRender&&(e.inRender=!0,e._view.traverseAllPasses(),e.inRender=!1),t.invokeRenderEvent()}t.requestAnimation=h=>{if(h===void 0){kr("undefined requester, can not start animating");return}if(n.has(h)){Fr("requester is already registered for animating");return}n.add(h),!e.animationRequest&&n.size===1&&!e.xrAnimation&&(e._animationStartTime=Date.now(),e._animationFrameCount=0,e.animationRequest=requestAnimationFrame(t.handleAnimation),t.startAnimationEvent())},t.extendAnimation=h=>{const T=Date.now()+h;e._animationExtendedEnd=Math.max(e._animationExtendedEnd,T),!e.animationRequest&&n.size===0&&!e.xrAnimation&&(e._animationStartTime=Date.now(),e._animationFrameCount=0,e.animationRequest=requestAnimationFrame(t.handleAnimation),t.startAnimationEvent())},t.isAnimating=()=>e.xrAnimation||e.animationRequest!==null,t.cancelAnimation=function(h){let T=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;if(!n.has(h)){if(!T){const v=h&&h.getClassName?h.getClassName():h;Fr(`${v} did not request an animation`)}return}n.delete(h),e.animationRequest&&n.size===0&&Date.now()>e._animationExtendedEnd&&(cancelAnimationFrame(e.animationRequest),e.animationRequest=null,t.endAnimationEvent(),t.render())},t.switchToXRAnimation=()=>{e.animationRequest&&(cancelAnimationFrame(e.animationRequest),e.animationRequest=null),e.xrAnimation=!0},t.returnFromXRAnimation=()=>{e.xrAnimation=!1,n.size!==0&&(e.recentAnimationFrameRate=10,e.animationRequest=requestAnimationFrame(t.handleAnimation))},t.updateXRGamepads=(h,T,v)=>{h.inputSources.forEach(C=>{const S=C.gripSpace==null?null:T.getPose(C.gripSpace,v),x=C.gripSpace==null?null:T.getPose(C.targetRaySpace,v),R=C.gamepad,O=C.handedness;if(R){R.index in e.lastGamepadValues||(e.lastGamepadValues[R.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let w=0;w<R.buttons.length;++w)w in e.lastGamepadValues[R.index][O].buttons||(e.lastGamepadValues[R.index][O].buttons[w]=!1),e.lastGamepadValues[R.index][O].buttons[w]!==R.buttons[w].pressed&&S!=null&&(t.button3DEvent({gamepad:R,position:S.transform.position,orientation:S.transform.orientation,targetPosition:x.transform.position,targetOrientation:x.transform.orientation,pressed:R.buttons[w].pressed,device:C.handedness==="left"?Lr.LeftController:Lr.RightController,input:za[R.mapping]&&za[R.mapping][w]?za[R.mapping][w]:Xt.Trigger}),e.lastGamepadValues[R.index][O].buttons[w]=R.buttons[w].pressed),e.lastGamepadValues[R.index][O].buttons[w]&&S!=null&&t.move3DEvent({gamepad:R,position:S.transform.position,orientation:S.transform.orientation,targetPosition:x.transform.position,targetOrientation:x.transform.orientation,device:C.handedness==="left"?Lr.LeftController:Lr.RightController})}})},t.handleMouseMove=h=>{const T={...u(h),position:c(h),deviceType:f(h)};e.moveTimeoutID===0?t.startMouseMoveEvent(T):(t.mouseMoveEvent(T),clearTimeout(e.moveTimeoutID)),e.moveTimeoutID=setTimeout(()=>{t.endMouseMoveEvent(),e.moveTimeoutID=0},200)},t.handleAnimation=()=>{const h=Date.now();e._animationFrameCount++,h-e._animationStartTime>1e3&&e._animationFrameCount>1&&(e.recentAnimationFrameRate=1e3*(e._animationFrameCount-1)/(h-e._animationStartTime),e.lastFrameTime=1/e.recentAnimationFrameRate,t.animationFrameRateUpdateEvent(),e._animationStartTime=h,e._animationFrameCount=1),t.animationEvent(),d(),n.size>0||Date.now()<e._animationExtendedEnd?e.animationRequest=requestAnimationFrame(t.handleAnimation):(cancelAnimationFrame(e.animationRequest),e.animationRequest=null,t.endAnimationEvent(),t.render())},t.handleWheel=h=>{Dn(h);const T={...U1(h),...u(h),position:c(h),deviceType:f(h)};e.wheelTimeoutID===0&&(Math.abs(T.spinY)>=.3?i=Math.abs(T.spinY):i=1),T.spinY/=i,e.wheelTimeoutID===0?(t.startMouseWheelEvent(T),t.mouseWheelEvent(T)):(t.mouseWheelEvent(T),clearTimeout(e.wheelTimeoutID)),e.mouseScrollDebounceByPass?(t.extendAnimation(600),t.endMouseWheelEvent(),e.wheelTimeoutID=0):e.wheelTimeoutID=setTimeout(()=>{t.extendAnimation(600),t.endMouseWheelEvent(),e.wheelTimeoutID=0},200)},t.handleMouseUp=h=>{const T={...u(h),position:c(h),deviceType:f(h)};switch(h.button){case 0:t.leftButtonReleaseEvent(T);break;case 1:t.middleButtonReleaseEvent(T);break;case 2:t.rightButtonReleaseEvent(T);break;default:kr(`Unknown mouse button released: ${h.button}`);break}},t.handleTouchStart=h=>{const T=[...a.values()];if(e.recognizeGestures&&T.length>1){const v=Nr(a);if(T.length===2){const C={...u(cn),position:T[0].position,deviceType:f(h)};t.leftButtonReleaseEvent(C)}t.recognizeGesture("TouchStart",v)}else if(T.length===1){const v={...u(cn),position:c(h),deviceType:f(h)};t.leftButtonPressEvent(v)}},t.handleTouchMove=h=>{const T=[...a.values()];if(e.recognizeGestures&&T.length>1){const v=Nr(a);t.recognizeGesture("TouchMove",v)}else if(T.length===1){const v={...u(cn),position:T[0].position,deviceType:f(h)};t.mouseMoveEvent(v)}},t.handleTouchEnd=h=>{const T=[...a.values()];if(e.recognizeGestures)if(T.length===0){const v={...u(cn),position:c(h),deviceType:f(h)};t.leftButtonReleaseEvent(v)}else if(T.length===1){const v=Nr(a);t.recognizeGesture("TouchEnd",v);const C={...u(cn),position:T[0].position,deviceType:f(h)};t.leftButtonPressEvent(C)}else{const v=Nr(a);t.recognizeGesture("TouchMove",v)}else if(T.length===1){const v={...u(cn),position:T[0].position,deviceType:f(h)};t.leftButtonReleaseEvent(v)}},t.setView=h=>{e._view!==h&&(e._view=h,e._view.getRenderable().setInteractor(t),t.modified())},t.getFirstRenderer=()=>{var h,T,v;return(v=(T=(h=e._view)==null?void 0:h.getRenderable())==null?void 0:T.getRenderersByReference())==null?void 0:v[0]},t.findPokedRenderer=function(){var O,w;let h=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0,T=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0;if(!e._view)return null;const v=(w=(O=e._view)==null?void 0:O.getRenderable())==null?void 0:w.getRenderers();if(!v||v.length===0)return null;v.sort((m,E)=>m.getLayer()-E.getLayer());let C=null,S=null,x=null,R=v.length;for(;R--;){const m=v[R];if(e._view.isInViewport(h,T,m)&&m.getInteractive()){x=m;break}C===null&&m.getInteractive()&&(C=m),S===null&&e._view.isInViewport(h,T,m)&&(S=m)}return x===null&&(x=C),x===null&&(x=S),x==null&&(x=v[0]),x},t.render=()=>{!t.isAnimating()&&!e.inRender&&d()},us.forEach(h=>{const T=h.charAt(0).toLowerCase()+h.slice(1);t[`${T}Event`]=v=>{if(!e.enabled)return;if(!t.getCurrentRenderer()){B1(`
          Can not forward events without a current renderer on the interactor.
        `);return}const S={type:h,pokedRenderer:e.currentRenderer,firstRenderer:t.getFirstRenderer(),...v};t[`invoke${h}`](S)}}),t.recognizeGesture=(h,T)=>{if(Object.keys(T).length>2)return;if(e.startingEventPositions||(e.startingEventPositions={}),h==="TouchStart"){Object.keys(T).forEach(M=>{e.startingEventPositions[M]=T[M]}),e.currentGesture="Start";return}if(h==="TouchEnd"){e.currentGesture==="Pinch"&&(t.render(),t.endPinchEvent()),e.currentGesture==="Rotate"&&(t.render(),t.endRotateEvent()),e.currentGesture==="Pan"&&(t.render(),t.endPanEvent()),e.currentGesture="Start",e.startingEventPositions={};return}let v=0;const C=[],S=[];Object.keys(T).forEach(M=>{C[v]=T[M],S[v]=e.startingEventPositions[M],v++});const x=Math.sqrt((S[0].x-S[1].x)*(S[0].x-S[1].x)+(S[0].y-S[1].y)*(S[0].y-S[1].y)),R=Math.sqrt((C[0].x-C[1].x)*(C[0].x-C[1].x)+(C[0].y-C[1].y)*(C[0].y-C[1].y));let O=Tn(Math.atan2(S[1].y-S[0].y,S[1].x-S[0].x)),w=Tn(Math.atan2(C[1].y-C[0].y,C[1].x-C[0].x)),m=w-O;w=w+180>=360?w-180:w+180,O=O+180>=360?O-180:O+180,Math.abs(w-O)<Math.abs(m)&&(m=w-O);const E=[];if(E[0]=(C[0].x-S[0].x+C[1].x-S[1].x)/2,E[1]=(C[0].y-S[0].y+C[1].y-S[1].y)/2,h==="TouchMove")if(e.currentGesture==="Start"){let M=.01*Math.sqrt(e.container.clientWidth*e.container.clientWidth+e.container.clientHeight*e.container.clientHeight);M<15&&(M=15);const D=Math.abs(R-x),N=R*3.1415926*Math.abs(m)/360,G=Math.sqrt(E[0]*E[0]+E[1]*E[1]);if(D>M&&D>N&&D>G){e.currentGesture="Pinch";const _={scale:1,touches:T};t.startPinchEvent(_)}else if(N>M&&N>G){e.currentGesture="Rotate";const _={rotation:0,touches:T};t.startRotateEvent(_)}else if(G>M){e.currentGesture="Pan";const _={translation:[0,0],touches:T};t.startPanEvent(_)}}else{if(e.currentGesture==="Rotate"){const M={rotation:m,touches:T};t.rotateEvent(M)}if(e.currentGesture==="Pinch"){const M={scale:R/x,touches:T};t.pinchEvent(M)}if(e.currentGesture==="Pan"){const M={translation:E,touches:T};t.panEvent(M)}}},t.handleVisibilityChange=()=>{e._animationStartTime=Date.now(),e._animationFrameCount=0},t.setCurrentRenderer=h=>{e._forcedRenderer=!!h,e.currentRenderer=h},t.setContainer=h=>{p();const T=r.setContainer(h??null);return T&&l(),T},t.delete=()=>{for(;n.size;)t.cancelAnimation(n.values().next().value);typeof document.hidden<"u"&&document.removeEventListener("visibilitychange",t.handleVisibilityChange),e.container&&t.setContainer(null),r.delete()},typeof document.hidden<"u"&&document.addEventListener("visibilitychange",t.handleVisibilityChange,!1)}const $1={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:"Start",animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function _f(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,$1,r),y.obj(t,e),e._animationExtendedEnd=0,y.event(t,e,"RenderEvent"),us.forEach(n=>y.event(t,e,n)),y.get(t,e,["initialized","interactorStyle","lastFrameTime","recentAnimationFrameRate","_view"]),y.setGet(t,e,["container","lightFollowCamera","enabled","enableRender","recognizeGestures","desiredUpdateRate","stillUpdateRate","picker","preventDefaultOnPointerDown","preventDefaultOnPointerUp","mouseScrollDebounceByPass"]),y.moveToProtected(t,e,["view"]),W1(t,e)}const z1=y.newInstance(_f,"vtkRenderWindowInteractor");var Gf={newInstance:z1,extend:_f,handledEvents:us,...Nf};const{vtkErrorMacro:H1,VOID:j1}=y;function b1(t,e,r,n){return t.getRenderWindow().getViews()[0].worldToDisplay(e,r,n,t)}function K1(t,e,r,n){return t.getRenderWindow().getViews()[0].displayToWorld(e,r,n,t)}const X1={computeWorldToDisplay:b1,computeDisplayToWorld:K1};function A1(t,e){e.classHierarchy.push("vtkInteractorObserver");const r={...t};function n(){for(;e.subscribedEvents.length;)e.subscribedEvents.pop().unsubscribe()}function a(){Gf.handledEvents.forEach(i=>{t[`handle${i}`]&&e.subscribedEvents.push(e._interactor[`on${i}`](s=>e.processEvents?t[`handle${i}`](s):j1,e.priority))})}t.setInteractor=i=>{i!==e._interactor&&(n(),e._interactor=i,i&&e.enabled&&a(),t.modified())},t.setEnabled=i=>{i!==e.enabled&&(n(),i&&(e._interactor?a():H1(`
          The interactor must be set before subscribing to events
        `)),e.enabled=i,t.modified())},t.computeDisplayToWorld=(i,s,o,c)=>i?e._interactor.getView().displayToWorld(s,o,c,i):null,t.computeWorldToDisplay=(i,s,o,c)=>i?e._interactor.getView().worldToDisplay(s,o,c,i):null,t.setPriority=i=>{r.setPriority(i)&&e._interactor&&(n(),a())}}const Y1={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function Uf(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Y1,r),y.obj(t,e),y.event(t,e,"InteractionEvent"),y.event(t,e,"StartInteractionEvent"),y.event(t,e,"EndInteractionEvent"),y.get(t,e,["_interactor","enabled"]),y.setGet(t,e,["priority","processEvents"]),y.moveToProtected(t,e,["interactor"]),A1(t,e)}const q1=y.newInstance(Uf,"vtkInteractorObserver");var Bf={newInstance:q1,extend:Uf,...X1};const Wf=.5;function Z1(t,e){e.classHierarchy.push("vtkAbstractWidget"),e.actorToRepresentationMap=new WeakMap,t.getBounds=e.widgetState.getBounds,t.getNestedProps=()=>e.representations,t.activateHandle=r=>{let{selectedState:n,representation:a}=r;e.widgetState.activateOnly(n),e.activeState=n,n&&n.updateManipulator&&n.updateManipulator(),t.invokeActivateHandle({selectedState:n,representation:a}),t.updateCursor&&t.updateCursor()},t.deactivateAllHandles=()=>{e.widgetState.deactivate()},t.hasActor=r=>e.actorToRepresentationMap.has(r),t.grabFocus=()=>{e.hasFocus=!0},t.loseFocus=()=>{e.hasFocus=!1},t.hasFocus=()=>e.hasFocus,t.placeWidget=r=>e.widgetState.placeWidget(r),t.getPlaceFactor=()=>e.widgetState.getPlaceFactor(),t.setPlaceFactor=r=>e.widgetState.setPlaceFactor(r),t.getRepresentationFromActor=r=>e.actorToRepresentationMap.get(r),t.updateRepresentationForRender=function(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:oa.FRONT_BUFFER;for(let n=0;n<e.representations.length;n++)e.representations[n].updateActorVisibility(r,e.contextVisibility,e.handleVisibility)},t.getViewWidgets=()=>e._factory.getViewWidgets(),t.setPriority(Wf)}const P1={contextVisibility:!0,handleVisibility:!0,hasFocus:!1};function $f(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,P1,r),pr.extend(t,e,r),Bf.extend(t,e,r),y.setGet(t,e,["contextVisibility","handleVisibility","_widgetManager"]),y.get(t,e,["representations","widgetState","activeState"]),y.moveToProtected(t,e,["widgetManager"]),y.event(t,e,"ActivateHandle"),Z1(t,e)}const J1=y.newInstance($f,"vtkAbstractWidget");var Q1={newInstance:J1,extend:$f};const{ViewTypes:fs,RenderingTypes:oo,CaptureOn:xi}=Of,{vtkErrorMacro:I1}=y;let eC=1;function zf(t){const e=t.getActiveCamera(),r=t.getRenderWindow(),n=r.getInteractor(),a=n.getView();return{renderer:t,renderWindow:r,interactor:n,apiSpecificRenderWindow:a,camera:e}}function hr(t,e){const{dispHeightFactor:r,cameraPosition:n,cameraDir:a,isParallel:i,rendererPixelDims:s}=e;let o=1;if(i)o=r;else{const u=[...t];st.subtract(u,n,u),o=st.dot(u,a)*r}const c=s[1];return o/c}function tC(t,e){e.viewId||(e.viewId=`view-${eC++}`),e.classHierarchy.push("vtkWidgetManager");const r=new WeakMap,n=[];function a(v){const C=v.getRepresentations();for(let S=0;S<C.length;S++){const x=C[S],R={widget:v,representation:x},O=x.getActors();for(let w=0;w<O.length;w++){const m=O[w];r.set(m,R)}}}function i(v){return v&&(v.isA("vtkAbstractWidget")?v:v.getWidgetForView({viewId:e.viewId}))}function s(){const{_apiSpecificRenderWindow:v,_camera:C,_renderer:S}=e;if(S&&v&&C){const[x,R]=v.getSize(),[O,w,m,E]=S.getViewport(),M=v.getComputedDevicePixelRatio(),D=[x*(m-O)/M,R*(E-w)/M],N=C.getPosition(),G=C.getDirectionOfProjection(),_=C.getParallelProjection(),B=_?2*C.getParallelScale():2*Math.tan(st.radiansFromDegrees(C.getViewAngle())/2);e.widgets.forEach(F=>{F.getNestedProps().forEach(z=>{z.getScaleInPixels()&&z.setDisplayScaleParams({dispHeightFactor:B,cameraPosition:N,cameraDir:G,isParallel:_,rendererPixelDims:D})})})}}async function o(v,C,S){const{position:x}=v,{requestCount:R,selectedState:O,representation:w,widget:m}=await t.getSelectedDataForXY(x.x,x.y);if(R||S!==e._currentUpdateSelectionCallID)return;function E(_){C&&e._interactor.invokeLeftButtonRelease(v),_.activateHandle({selectedState:O,representation:w}),C&&e._interactor.invokeLeftButtonPress(v)}const N=t.getCursorStyles()[m?"hover":"default"];N&&e._apiSpecificRenderWindow.setCursor(N),e.activeWidget=null;let G=!1;if(e.widgetInFocus===m&&m.hasFocus())E(m),e.activeWidget=m,G=!0;else for(let _=0;_<e.widgets.length;_++){const B=e.widgets[_];B===m&&B.getNestedPickable()?(E(B),e.activeWidget=B,G=!0):(G||(G=!!B.getActiveState()),B.deactivateAllHandles())}G&&e._interactor.render()}const c=async function(v){let C=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;if(!e.isAnimating&&e.pickingEnabled&&v.pokedRenderer===e._renderer){const S=Symbol("UpdateSelection");e._currentUpdateSelectionCallID=S,await o(v,C,S)}};function u(v){v.updateRepresentationForRender(e.renderingType)}function g(){e.renderingType=oo.PICKING_BUFFER,e.widgets.forEach(u)}function f(){e.renderingType=oo.FRONT_BUFFER,e.widgets.forEach(u)}async function l(v,C,S,x){if(e._captureInProgress){await e._captureInProgress;return}g(),e._capturedBuffers=null,e._captureInProgress=e._selector.getSourceDataAsync(e._renderer,v,C,S,x),e._capturedBuffers=await e._captureInProgress,e._captureInProgress=null,e.previousSelectedData=null,f()}t.enablePicking=()=>{e.pickingEnabled=!0,t.renderWidgets()},t.renderWidgets=()=>{if(e.pickingEnabled&&e.captureOn===xi.MOUSE_RELEASE){const[v,C]=e._apiSpecificRenderWindow.getSize();l(0,0,v,C)}f(),t.modified()},t.disablePicking=()=>{e.pickingEnabled=!1},t.setRenderer=v=>{const C=zf(v);for(Object.assign(e,C),y.moveToProtected({},e,Object.keys(C));n.length;)n.pop().unsubscribe();e._selector=e._apiSpecificRenderWindow.createSelector(),e._selector.setFieldAssociation(Mu.FIELD_ASSOCIATION_POINTS),n.push(e._apiSpecificRenderWindow.onWindowResizeEvent(s)),n.push(e._camera.onModified(s)),s(),n.push(e._interactor.onStartAnimation(()=>{e.isAnimating=!0})),n.push(e._interactor.onEndAnimation(()=>{e.isAnimating=!1,t.renderWidgets()})),n.push(e._interactor.onMouseMove(S=>(c(S),y.VOID))),n.push(e._interactor.onLeftButtonPress(S=>{const{deviceType:x}=S,R=x==="touch"||x==="pen";return R&&c(S,R),y.VOID},Wf/2)),t.modified(),e.pickingEnabled&&t.enablePicking()};function p(v){v.setWidgetManager(t),a(v),s(),e._renderer.addActor(v)}t.addWidget=(v,C,S)=>{if(!e._renderer)return I1("Widget manager MUST BE link to a view before registering widgets"),null;const{viewId:x,_renderer:R}=e,O=v.getWidgetForView({viewId:x,renderer:R,viewType:C||fs.DEFAULT,initialValues:S});return O!=null&&e.widgets.indexOf(O)===-1&&(e.widgets.push(O),p(O),t.modified()),O};function d(v){e._renderer.removeActor(v),v.delete()}function h(){e._renderer.getRenderWindow().getInteractor().render(),t.renderWidgets()}t.removeWidgets=()=>{e.widgets.forEach(d),e.widgets=[],e.widgetInFocus=null,h()},t.removeWidget=v=>{const C=i(v),S=e.widgets.indexOf(C);S!==-1&&(e.widgets.splice(S,1),e.widgetInFocus===C&&t.releaseFocus(),d(C),h())},t.getSelectedDataForXY=async(v,C)=>{if(e.selections=null,e.pickingEnabled){if(!e._capturedBuffers||e.captureOn===xi.MOUSE_MOVE)await l(v,C,v,C);else{const S=e._capturedBuffers.area;(v<S[0]||v>S[2]||C<S[1]||C>S[3])&&await l(v,C,v,C)}e.selections=e._capturedBuffers.generateSelection(v,C,v,C)}return t.getSelectedData()},t.getSelectedData=()=>{if(!e.selections||!e.selections.length)return e.previousSelectedData=null,{};const{propID:v,compositeID:C,prop:S}=e.selections[0].getProperties();let{widget:x,representation:R}=e.selections[0].getProperties();if(e.previousSelectedData&&e.previousSelectedData.prop===S&&e.previousSelectedData.widget===x&&e.previousSelectedData.compositeID===C)return e.previousSelectedData.requestCount++,e.previousSelectedData;if(r.has(S)){const O=r.get(S);x=O.widget,R=O.representation}if(x&&R){const O=R.getSelectedState(S,C);return e.previousSelectedData={requestCount:0,propID:v,compositeID:C,prop:S,widget:x,representation:R,selectedState:O},e.previousSelectedData}return e.previousSelectedData=null,{}},t.grabFocus=v=>{const C=i(v);e.widgetInFocus&&e.widgetInFocus!==C&&e.widgetInFocus.loseFocus(),e.widgetInFocus=C,e.widgetInFocus&&e.widgetInFocus.grabFocus()},t.releaseFocus=()=>t.grabFocus(null);const T=t.delete;t.delete=()=>{for(;n.length;)n.pop().unsubscribe();T()}}const nC=function(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};return{viewId:null,widgets:[],activeWidget:null,renderer:null,viewType:fs.DEFAULT,isAnimating:!1,pickingEnabled:!0,selections:null,previousSelectedData:null,widgetInFocus:null,captureOn:xi.MOUSE_MOVE,...t,cursorStyles:t.cursorStyles?{...t.cursorStyles}:{default:"default",hover:"pointer"}}};function Hf(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,nC(r)),y.obj(t,e),y.setGet(t,e,["captureOn","cursorStyles",{type:"enum",name:"viewType",enum:fs}]),y.get(t,e,["selections","widgets","viewId","pickingEnabled","activeWidget"]),tC(t,e)}const rC=y.newInstance(Hf,"vtkWidgetManager");var RM={newInstance:rC,extend:Hf,Constants:Of,getPixelWorldHeightAtCoord:hr};function aC(){}function iC(t,e){e.classHierarchy.push("vtkAbstractWidgetFactory");const r={};t.getWidgetForView=a=>{let{viewId:i,renderer:s,viewType:o,initialValues:c}=a;if(!r[i]){if(!s)return null;const{interactor:u,apiSpecificRenderWindow:g,camera:f}=zf(s),l={},p={};y.obj(p,l),Object.assign(p,{onWidgetChange:t.onWidgetChange}),Object.assign(l,{widgetState:e.widgetState,manipulator:e.manipulator,viewType:o,renderer:s,camera:f,apiSpecificRenderWindow:g,factory:t}),y.moveToProtected(p,l,["renderer","camera","apiSpecificRenderWindow","factory"]),y.get(p,l,["viewType"]),y.safeArrays(l),Q1.extend(p,l,c);const d=c;l.representations=t.getRepresentationsForViewType(o).map(T=>{let{builder:v,labels:C,initialValues:S}=T;return v.newInstance({_parentProp:p,labels:C,...S,...d})}),l.representations.forEach(T=>{T.setInputData(l.widgetState),T.getActors().forEach(v=>{l.actorToRepresentationMap.set(v,T)})}),e.behavior(p,l),["coincidentTopologyParameters",...e.methodsToLink||[]].forEach(T=>{const v=`set${y.capitalize(T)}`,C=`get${y.capitalize(T)}`,S={[T]:[],[v]:[],[C]:[]};l.representations.forEach(x=>{x[T]&&S[T].push(x[T]),x[v]&&S[v].push(x[v]),x[C]&&S[C].push(x[C])}),Object.keys(S).forEach(x=>{const R=S[x];R.length===1?p[x]=R[0]:R.length>1&&(p[x]=y.chain(...R))})}),p.delete=y.chain(()=>{delete r[i]},p.delete),p.setInteractor(u);const h=Object.freeze(p);return r[i]=h,h}return r[i]},t.getViewIds=()=>Object.keys(r),t.getViewWidgets=()=>Object.values(r),t.setVisibility=a=>{const i=Object.keys(r);for(let s=0;s<i.length;s++)r[i[s]].setVisibility(a)},t.setPickable=a=>{const i=Object.keys(r);for(let s=0;s<i.length;s++)r[i[s]].setPickable(a)},t.setDragable=a=>{const i=Object.keys(r);for(let s=0;s<i.length;s++)r[i[s]].setDragable(a)},t.setContextVisibility=a=>{const i=Object.keys(r);for(let s=0;s<i.length;s++)r[i[s]].setContextVisibility(a)},t.setHandleVisibility=a=>{const i=Object.keys(r);for(let s=0;s<i.length;s++)r[i[s]].setHandleVisibility(a)},t.placeWidget=a=>e.widgetState.placeWidget(a),t.getPlaceFactor=()=>e.widgetState.getPlaceFactor(),t.setPlaceFactor=a=>e.widgetState.setPlaceFactor(a);let n=aC;t.delete=y.chain(t.delete,()=>n()),e.widgetState&&(n=e.widgetState.onModified(()=>t.invokeWidgetChange(e.widgetState)).unsubscribe)}function jf(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,r),y.obj(t,e),y.get(t,e,["widgetState"]),y.event(t,e,"WidgetChange"),iC(t,e)}const sC=y.newInstance(jf,"vtkAbstractWidget");var bf={newInstance:sC,extend:jf};const Ha="default";function co(t,e){const r=t.indexOf(e);r!==-1&&t.splice(r,1)}function oC(t,e){e.classHierarchy.push("vtkWidgetState");const r=[];e.labels={},e.nestedStates=[],t.bindState=function(n){let a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[Ha];if(e.nestedStates.push(n),r.push(n.onModified(t.modified)),Array.isArray(a)&&a.length)for(let i=0;i<a.length;i++){const s=a[i];e.labels[s]||(e.labels[s]=[]),e.labels[s].push(n)}else{const i=Array.isArray(a)?Ha:a||Ha;e.labels[i]||(e.labels[i]=[]),e.labels[i].push(n)}},t.unbindState=n=>{for(;r.length;)r.pop().unsubscribe();co(e.nestedStates,n);for(let a=0;a<e.nestedStates.length;a++)r.push(e.nestedStates[a].onModified(t.modified));Object.keys(e.labels).forEach(a=>{const i=e.labels[a];co(i,n)})},t.unbindAll=()=>{for(;r.length;)r.pop().unsubscribe();e.nestedStates=[]},t.activate=()=>t.setActive(!0),t.deactivate=n=>{n!==t&&t.setActive(!1);for(let a=0;a<e.nestedStates.length;a++)e.nestedStates[a].deactivate(n)},t.activateOnly=n=>{n&&n.setActive(!0),t.deactivate(n)},t.getStatesWithLabel=n=>e.labels[n],t.getAllNestedStates=()=>e.nestedStates,t.delete=y.chain(t.unbindAll,t.delete)}const cC={active:!1};function uC(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,cC,r),y.obj(t,e),y.setGet(t,e,["active"]),oC(t,e)}var Kf={extend:uC};function fC(t,e){const r=[],n=[...K.INIT_BOUNDS];t.containsPoint=(a,i,s)=>Array.isArray(a)?K.containsPoint(n,a[0],a[1],a[2]):K.containsPoint(n,a,i,s),t.placeWidget=a=>{e.bounds=[];const i=[(a[0]+a[1])/2,(a[2]+a[3])/2,(a[4]+a[5])/2];for(let s=0;s<6;s++){const o=i[Math.floor(s/2)];r[s]=a[s],e.bounds[s]=(a[s]-o)*e.placeFactor+o}K.setBounds(n,e.bounds),t.invokeBoundsChange(e.bounds),t.modified()},t.setPlaceFactor=a=>{if(e.placeFactor!==a){e.placeFactor=a,e.bounds=[];const i=[(r[0]+r[1])/2,(r[2]+r[3])/2,(r[4]+r[5])/2];for(let s=0;s<6;s++){const o=i[Math.floor(s/2)];e.bounds[s]=(r[s]-o)*e.placeFactor+o}K.setBounds(n,e.bounds),t.invokeBoundsChange(e.bounds),t.modified()}}}const gC={bounds:[-1,1,-1,1,-1,1],placeFactor:1};function lC(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,gC,r),y.setGetArray(t,e,["bounds"],6),y.get(t,e,["placeFactor"]),y.event(t,e,"BoundsChange"),e.bounds=e.bounds.slice(),fC(t,e)}var Xf={extend:lC};const pC={color:.5};function hC(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,pC,r),y.setGet(t,e,["color"])}var dC={extend:hC};const TC={color3:[255,255,255],opacity:255};function vC(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,TC,r),y.setGetArray(t,e,["color3"],3,255),y.setGet(t,e,["opacity"])}var yC={extend:vC};function CC(t,e){t.translate=(r,n,a)=>{const[i,s,o]=t.getCornerByReference();t.setCorner(i+r,s+n,o+a)}}const SC={corner:[0,0,0]};function xC(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,SC,r),y.setGetArray(t,e,["corner"],3),CC(t)}var wC={extend:xC};function RC(t,e){const r=e.angleUnit==="degree"?ot.buildFromDegree():ot.buildFromRadian();t.rotateFromDirections=(n,a)=>{r.identity().rotateFromDirections(n,a).apply(e.direction),t.modified()},t.rotate=(n,a)=>{r.identity().rotate(n,a).apply(e.direction)},t.rotateX=n=>{r.identity().rotateX(n).apply(e.direction)},t.rotateY=n=>{r.identity().rotateY(n).apply(e.direction)},t.rotateZ=n=>{r.identity().rotateZ(n).apply(e.direction)}}const MC={direction:[1,0,0]};function OC(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,MC,r),y.setGetArray(t,e,["direction"],3),RC(t,e)}var mC={extend:OC};function EC(t,e){t.updateManipulator=()=>{if(e.manipulator){const{origin:r,normal:n,direction:a}=e,{setHandleOrigin:i,setHandleCenter:s,setHandleNormal:o,setHandleDirection:c}=e.manipulator;r&&i?i(r):r&&s&&s(r),a&&c?c(a):a&&!n&&o?o(a):n&&c&&c(n)}}}const DC={manipulator:null};function VC(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,DC,r),y.setGet(t,e,["manipulator"]),EC(t,e)}var LC={extend:VC};const FC={name:""};function kC(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,FC,r),y.setGet(t,e,["name"])}var NC={extend:kC};function ja(t,e){return t.length===3&&e.length===3&&t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]}function _C(t,e,r,n){return ja(t,n.o)&&ja(e,n.p1)&&ja(r,n.p2)}function GC(t,e){const r={o:[],p1:[],p2:[]};t.normalize=()=>{pe(e.up),pe(e.right),pe(e.direction),t.modified()},t.updateFromOriginRightUp=(n,a,i)=>{_C(n,a,i,r)||(r.o=n.slice(),r.p1=a.slice(),r.p2=i.slice(),e.up=[i[0]-n[0],i[1]-n[1],i[2]-n[2]],e.right=[a[0]-n[0],a[1]-n[1],a[2]-n[2]],Te(e.up,e.right,e.direction),Te(e.direction,e.up,e.right),t.normalize(),t.modified())}}const UC={up:[0,1,0],right:[1,0,0],direction:[0,0,1]};function BC(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,UC,r),y.setGetArray(t,e,["up","right","direction"],3),GC(t,e)}var WC={extend:BC};function $C(t,e){const r={...t};t.translate=(n,a,i)=>{const[s,o,c]=t.getOriginByReference();t.setOrigin(s+n,o+a,c+i)},t.getOrigin=n=>{const a=r.getOrigin();if(!e.offset)return a;if(!n)return st.add(a,e.offset,a);const i=hr(a,n),{rendererPixelDims:s}=n,o=Math.min(s[0],s[1]);return st.multiplyAccumulate(a,e.offset,o*i,a)}}const zC={origin:null,offset:null};function HC(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,zC,r),y.setGetArray(t,e,["origin","offset"],3),$C(t,e)}var jC={extend:HC};const bC={scale1:.5};function KC(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,bC,r),y.setGet(t,e,["scale1"])}var XC={extend:KC};const AC={scale3:[1,1,1]};function YC(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,AC,r),y.setGetArray(t,e,["scale3"],3)}var qC={extend:YC};const ZC={text:"DefaultText"};function PC(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,ZC,r),y.setGet(t,e,["text"])}var JC={extend:PC};const QC={visible:!0};function IC(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,QC,r),y.setGet(t,e,["visible"]),t.isVisible=t.getVisible}var eS={extend:IC};const tS={shape:""};function nS(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,tS,r),y.setGet(t,e,["shape"])}var rS={extend:nS};const{vtkErrorMacro:aS}=y,iS={bounds:Xf,color:dC,color3:yC,corner:wC,direction:mC,manipulator:LC,name:NC,orientation:WC,origin:jC,scale1:XC,scale3:qC,text:JC,visible:eS,shape:rS};function ba(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},n=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{};(arguments.length>4&&arguments[4]!==void 0?arguments[4]:!1)||Kf.extend(r,n,e);for(let i=0;i<t.length;i++){const s=iS[t[i]];s?s.extend(r,n,e):aS("Invalid mixin name:",t[i])}return y.safeArrays(n),Object.freeze(r)}class sS{constructor(){this.publicAPI={},this.model={},Kf.extend(this.publicAPI,this.model),Xf.extend(this.publicAPI,this.model)}addDynamicMixinState(e){let{labels:r,mixins:n,name:a,initialValues:i}=e;const s=`${a}List`;return this.model[s]=[],this.publicAPI[`add${y.capitalize(a)}`]=o=>{const c=ba(n,{...i,...o});return this.publicAPI.bindState(c,r),this.model[s].push(c),this.publicAPI.modified(),c},this.publicAPI[`remove${y.capitalize(a)}`]=o=>{let c=this.model[s].indexOf(o);c===-1&&o<this.model[s].length&&(c=o);const u=this.model[s][c];u&&this.publicAPI.unbindState(u),this.model[s].splice(c,1),this.publicAPI.modified()},this.publicAPI[`get${y.capitalize(a)}List`]=()=>this.model[s].slice(),this.publicAPI[`clear${y.capitalize(a)}List`]=()=>{for(;this.model[s].length;){const o=this.model[s].pop();o&&this.publicAPI.unbindState(o)}this.publicAPI.modified()},this}addStateFromMixin(e){let{labels:r,mixins:n,name:a,initialValues:i}=e;const s=ba(n,i);return this.model[a]=s,this.publicAPI.bindState(s,r),y.setGet(this.publicAPI,this.model,[a]),this}addStateFromInstance(e){let{labels:r,name:n,instance:a}=e;return this.model[n]=a,this.publicAPI.bindState(a,r),y.setGet(this.publicAPI,this.model,[n]),this}addField(e){let{name:r,initialValue:n}=e;return Array.isArray(n)?y.setGetArray(this.publicAPI,this.model,[r],n.length):y.setGet(this.publicAPI,this.model,[r]),this.model[r]=n,this}build(){for(var e=arguments.length,r=new Array(e),n=0;n<e;n++)r[n]=arguments[n];return ba(r,{},this.publicAPI,this.model,!0)}}function oS(){return new sS}var wi={createBuilder:oS};const Af={DISPLAY:0,NORMALIZED_DISPLAY:1,VIEWPORT:2,NORMALIZED_VIEWPORT:3,PROJECTION:4,VIEW:5,WORLD:6};var Yf={Coordinate:Af};const{Coordinate:Z}=Yf,{vtkErrorMacro:_r}=y;function cS(t,e){e.classHierarchy.push("vtkCoordinate"),t.setValue=function(){if(e.deleted)return _r("instance deleted - cannot call any method"),!1;for(var r=arguments.length,n=new Array(r),a=0;a<r;a++)n[a]=arguments[a];let i=n;if(i.length===1&&Array.isArray(i[0])&&(i=i[0]),i.length===2)return t.setValue(i[0],i[1],0),!0;if(i.length!==3)throw new RangeError("Invalid number of values for array setter");let s=!1;return e.value.forEach((o,c)=>{if(o!==i[c]){if(s)return;s=!0}}),s&&(e.value=[].concat(i),t.modified()),!0},t.setCoordinateSystemToDisplay=()=>{t.setCoordinateSystem(Z.DISPLAY)},t.setCoordinateSystemToNormalizedDisplay=()=>{t.setCoordinateSystem(Z.NORMALIZED_DISPLAY)},t.setCoordinateSystemToViewport=()=>{t.setCoordinateSystem(Z.VIEWPORT)},t.setCoordinateSystemToNormalizedViewport=()=>{t.setCoordinateSystem(Z.NORMALIZED_VIEWPORT)},t.setCoordinateSystemToProjection=()=>{t.setCoordinateSystem(Z.PROJECTION)},t.setCoordinateSystemToView=()=>{t.setCoordinateSystem(Z.VIEW)},t.setCoordinateSystemToWorld=()=>{t.setCoordinateSystem(Z.WORLD)},t.getCoordinateSystemAsString=()=>y.enumToString(Z,e.coordinateSystem),t.getComputedWorldValue=r=>{let n=e.computedWorldValue;if(e.computing)return n;e.computing=1,n[0]=e.value[0],n[1]=e.value[1],n[2]=e.value[2];let a=r;if(e.renderer&&(a=e.renderer),!a){if(e.coordinateSystem===Z.WORLD){if(e.referenceCoordinate){const c=e.referenceCoordinate.getComputedWorldValue(a);n[0]+=c[0],n[1]+=c[1],n[2]+=c[2]}e.computing=0}else _r("Attempt to compute world coordinates from another coordinate system without a renderer");return n}let i=null;if(a&&a.getRenderWindow().getViews())i=a.getRenderWindow().getViews()[0];else return e.computedWorldValue;const s=i.getViewportSize(a),o=s[0]/s[1];if(e.referenceCoordinate&&e.coordinateSystem!==Z.WORLD){const c=e.referenceCoordinate.getComputedDoubleDisplayValue(a);let u=[c[0],c[1],0];switch(e.coordinateSystem){case Z.NORMALIZED_DISPLAY:u=i.displayToNormalizedDisplay(u[0],u[1],u[2]);break;case Z.VIEWPORT:u=i.displayToNormalizedDisplay(u[0],u[1],u[2]),u=i.normalizedDisplayToViewport(u[0],u[1],u[2],a);break;case Z.NORMALIZED_VIEWPORT:u=i.displayToNormalizedDisplay(u[0],u[1],u[2]),u=i.normalizedDisplayToViewport(u[0],u[1],u[2],a),u=i.viewportToNormalizedViewport(u[0],u[1],u[2],a);break;case Z.PROJECTION:u=i.displayToNormalizedDisplay(u[0],u[1],u[2]),u=i.normalizedDisplayToViewport(u[0],u[1],u[2],a),u=i.viewportToNormalizedViewport(u[0],u[1],u[2],a),u=a.normalizedViewportToProjection(u[0],u[1],u[2]);break;case Z.VIEW:u=i.displayToNormalizedDisplay(u[0],u[1],u[2]),u=i.normalizedDisplayToViewport(u[0],u[1],u[2],a),u=i.viewportToNormalizedViewport(u[0],u[1],u[2],a),u=a.normalizedViewportToProjection(u[0],u[1],u[2]),u=a.projectionToView(u[0],u[1],u[2],o);break}n[0]+=u[0],n[1]+=u[1],n[2]+=u[2]}switch(e.coordinateSystem){case Z.DISPLAY:n=i.displayToNormalizedDisplay(n[0],n[1],n[2]),n=i.normalizedDisplayToViewport(n[0],n[1],n[2],a),n=i.viewportToNormalizedViewport(n[0],n[1],n[2],a),n=a.normalizedViewportToProjection(n[0],n[1],n[2]),n=a.projectionToView(n[0],n[1],n[2],o),n=a.viewToWorld(n[0],n[1],n[2]);break;case Z.NORMALIZED_DISPLAY:n=i.normalizedDisplayToViewport(n[0],n[1],n[2],a),n=i.viewportToNormalizedViewport(n[0],n[1],n[2],a),n=a.normalizedViewportToProjection(n[0],n[1],n[2]),n=a.projectionToView(n[0],n[1],n[2],o),n=a.viewToWorld(n[0],n[1],n[2]);break;case Z.VIEWPORT:n=i.viewportToNormalizedViewport(n[0],n[1],n[2],a),n=a.normalizedViewportToProjection(n[0],n[1],n[2]),n=a.projectionToView(n[0],n[1],n[2],o),n=a.viewToWorld(n[0],n[1],n[2]);break;case Z.NORMALIZED_VIEWPORT:n=a.normalizedViewportToProjection(n[0],n[1],n[2]),n=a.projectionToView(n[0],n[1],n[2],o),n=a.viewToWorld(n[0],n[1],n[2]);break;case Z.PROJECTION:n=a.projectionToView(n[0],n[1],n[2],o),n=a.viewToWorld(n[0],n[1],n[2]);break;case Z.VIEW:n=a.viewToWorld(n[0],n[1],n[2]);break}if(e.referenceCoordinate&&e.coordinateSystem===Z.WORLD){const c=t.getComputedWorldValue(a);n[0]+=c[0],n[1]+=c[1],n[2]+=c[2]}return e.computing=0,e.computedWorldValue=n.slice(0),n},t.getComputedViewportValue=r=>{const n=t.getComputedDoubleViewportValue(r);return[yt(n[0]),yt(n[1])]},t.getComputedDisplayValue=r=>{const n=t.getComputedDoubleDisplayValue(r);return[Qn(n[0]),Qn(n[1])]},t.getComputedLocalDisplayValue=r=>{let n=r;e.renderer&&(n=e.renderer);let a=t.getComputedDisplayValue(n);if(!n)return _r("Attempt to convert to local display coordinates without a renderer"),a;let i=null;if(n&&n.getRenderWindow().getViews())i=n.getRenderWindow().getViews()[0];else return a;return a=i.displayToLocalDisplay(a[0],a[1],a[2]),[yt(a[0]),yt(a[1])]},t.getComputedDoubleViewportValue=r=>{let n=r;e.renderer&&(n=e.renderer);let a=t.getComputedDoubleDisplayValue(n);if(!n)return a;let i=null;if(n&&n.getRenderWindow().getViews())i=n.getRenderWindow().getViews()[0];else return a;return a=i.displayToNormalizedDisplay(a[0],a[1],a[2]),a=i.normalizedDisplayToViewport(a[0],a[1],a[2],n),[a[0],a[1]]},t.getComputedDoubleDisplayValue=r=>{if(e.computing)return e.computedDoubleDisplayValue;e.computing=1;let n=e.value.slice(0),a=r;if(e.renderer&&(a=e.renderer),!a){if(e.coordinateSystem===Z.DISPLAY){if(e.computedDoubleDisplayValue[0]=n[0],e.computedDoubleDisplayValue[1]=n[1],e.referenceCoordinate){const c=e.referenceCoordinate.getComputedDoubleDisplayValue();e.computedDoubleDisplayValue[0]+=c[0],e.computedDoubleDisplayValue[1]+=c[1]}}else e.computedDoubleDisplayValue[0]=Number.MAX_VALUE,e.computedDoubleDisplayValue[1]=Number.MAX_VALUE,_r("Request for coordinate transformation without required viewport");return e.computedDoubleDisplayValue}let i=null;if(a&&a.getRenderWindow().getViews())i=a.getRenderWindow().getViews()[0];else return n;const s=i.getViewportSize(a),o=s[0]/s[1];switch(e.coordinateSystem){case Z.WORLD:{if(e.referenceCoordinate){const c=e.referenceCoordinate.getComputedWorldValue(a);n[0]+=c[0],n[1]+=c[1],n[2]+=c[2]}n=a.worldToView(n[0],n[1],n[2]),n=a.viewToProjection(n[0],n[1],n[2],o),n=a.projectionToNormalizedViewport(n[0],n[1],n[2]),n=i.normalizedViewportToViewport(n[0],n[1],n[2],a),n=i.viewportToNormalizedDisplay(n[0],n[1],n[2],a),n=i.normalizedDisplayToDisplay(n[0],n[1],n[2]);break}case Z.VIEW:{n=a.viewToProjection(n[0],n[1],n[2],o),n=a.projectionToNormalizedViewport(n[0],n[1],n[2]),n=i.normalizedViewportToViewport(n[0],n[1],n[2],a),n=i.viewportToNormalizedDisplay(n[0],n[1],n[2],a),n=i.normalizedDisplayToDisplay(n[0],n[1],n[2]);break}case Z.PROJECTION:{n=a.projectionToNormalizedViewport(n[0],n[1],n[2]),n=i.normalizedViewportToViewport(n[0],n[1],n[2],a),n=i.viewportToNormalizedDisplay(n[0],n[1],n[2],a),n=i.normalizedDisplayToDisplay(n[0],n[1],n[2]);break}case Z.NORMALIZED_VIEWPORT:{if(n=i.normalizedViewportToViewport(n[0],n[1],n[2],a),e.referenceCoordinate){const c=e.referenceCoordinate.getComputedDoubleViewportValue(a);n[0]+=c[0],n[1]+=c[1]}n=i.viewportToNormalizedDisplay(n[0],n[1],n[2],a),n=i.normalizedDisplayToDisplay(n[0],n[1],n[2]);break}case Z.VIEWPORT:{if(e.referenceCoordinate){const c=e.referenceCoordinate.getComputedDoubleViewportValue(a);n[0]+=c[0],n[1]+=c[1]}n=i.viewportToNormalizedDisplay(n[0],n[1],n[2],a),n=i.normalizedDisplayToDisplay(n[0],n[1],n[2]);break}case Z.NORMALIZED_DISPLAY:n=i.normalizedDisplayToDisplay(n[0],n[1],n[2]);break;case Z.USERDEFINED:n=e.value.slice(0);break}if(e.referenceCoordinate&&(e.coordinateSystem===Z.DISPLAY||e.coordinateSystem===Z.NORMALIZED_DISPLAY)){const c=e.referenceCoordinate.getComputedDoubleDisplayValue(a);n[0]+=c[0],n[1]+=c[1]}return e.computedDoubleDisplayValue[0]=n[0],e.computedDoubleDisplayValue[1]=n[1],e.computing=0,e.computedDoubleDisplayValue},t.getComputedValue=r=>{let n=r;switch(e.renderer&&(n=e.renderer),e.coordinateSystem){case Z.WORLD:return t.getComputedWorldValue(n);case Z.VIEW:case Z.NORMALIZED_VIEWPORT:case Z.VIEWPORT:{const a=t.getComputedViewportValue(n);e.computedWorldValue[0]=a[0],e.computedWorldValue[1]=a[1];break}case Z.NORMALIZED_DISPLAY:case Z.DISPLAY:{const a=e.getComputedDisplayValue(n);e.computedWorldValue[0]=a[0],e.computedWorldValue[1]=a[1];break}}return e.computedWorldValue}}const uS={coordinateSystem:Z.WORLD,value:[0,0,0],renderer:null,referenceCoordinate:null,computing:0,computedWorldValue:[0,0,0],computedDoubleDisplayValue:[0,0]};function qf(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,uS,r),y.obj(t,e),y.set(t,e,["property"]),y.get(t,e,["value"]),y.setGet(t,e,["coordinateSystem","referenceCoordinate","renderer"]),y.getArray(t,e,["value"],3),cS(t,e)}const fS=y.newInstance(qf,"vtkCoordinate");var uo={newInstance:fS,extend:qf,...Yf};const{DisplayLocation:Ri}=Au;function gS(t,e){e.classHierarchy.push("vtkProperty2D"),t.setDisplayLocationToBackground=()=>t.setDisplayLocation(Ri.BACKGROUND),t.setDisplayLocationToForeground=()=>t.setDisplayLocation(Ri.FOREGROUND),t.setRepresentationToWireframe=()=>t.setRepresentation(me.WIREFRAME),t.setRepresentationToSurface=()=>t.setRepresentation(me.SURFACE),t.setRepresentationToPoints=()=>t.setRepresentation(me.POINTS),t.getRepresentationAsString=()=>y.enumToString(me,e.representation)}const lS={color:[1,1,1],opacity:1,pointSize:1,lineWidth:1,representation:me.SURFACE,displayLocation:Ri.FOREGROUND};function Zf(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,lS,r),y.obj(t,e),y.setGet(t,e,["opacity","lineWidth","pointSize","displayLocation","representation"]),y.setGetArray(t,e,["color"],3),gS(t,e)}const pS=y.newInstance(Zf,"vtkProperty2D");var hS={newInstance:pS,extend:Zf,...Au};function dS(t,e){e.classHierarchy.push("vtkActor2D"),t.getActors2D=()=>t,t.getIsOpaque=()=>{e.property||t.getProperty();let r=e.property.getOpacity()>=1;return r=r&&(!e.texture||!e.texture.isTranslucent()),r},t.hasTranslucentPolygonalGeometry=()=>e.mapper===null?!1:(e.property===null&&t.setProperty(t.makeProperty()),!t.getIsOpaque()),t.makeProperty=hS.newInstance,t.getProperty=()=>(e.property===null&&(e.property=t.makeProperty()),e.property),t.setDisplayPosition=(r,n)=>{e.positionCoordinate.setCoordinateSystem(Af.DISPLAY),e.positionCoordinate.setValue(r,n,0)},t.setWidth=r=>{const n=e.position2Coordinate.getValue();e.position2Coordinate.setCoordinateSystemToNormalizedViewport(),e.position2Coordinate.setValue(r,n[1])},t.setHeight=r=>{const n=e.position2Coordinate.getValue();e.position2Coordinate.setCoordinateSystemToNormalizedViewport(),e.position2Coordinate.setValue(n[0],r)},t.getWidth=()=>e.position2Coordinate.getValue()[0],t.getHeight=()=>e.position2Coordinate.getValue()[1],t.getMTime=()=>{let r=e.mtime;if(e.property!==null){const n=e.property.getMTime();r=n>r?n:r}return r=e.positionCoordinate.getMTime()>r?e.positionCoordinate.getMTime():r,r=e.positionCoordinate2.getMTime()>r?e.positionCoordinate2.getMTime():r,r},t.getRedrawMTime=()=>{let r=e.mtime;if(e.mapper!==null){let n=e.mapper.getMTime();r=n>r?n:r,e.mapper.getInput()!==null&&(e.mapper.getInputAlgorithm().update(),n=e.mapper.getInput().getMTime(),r=n>r?n:r)}return r},t.getBounds=()=>typeof t.getMapper().getBounds=="function"?(e.useBounds=!0,t.getMapper().getBounds()):(e.useBounds=!1,[]),t.getActualPositionCoordinate=()=>e.positionCoordinate,t.getActualPositionCoordinate2=()=>e.positionCoordinate2}const TS={mapper:null,property:null,layerNumber:0,positionCoordinate:null,positionCoordinate2:null};function Pf(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,TS,r),pr.extend(t,e,r),e.positionCoordinate=uo.newInstance(),e.positionCoordinate.setCoordinateSystemToViewport(),e.positionCoordinate2=uo.newInstance(),e.positionCoordinate2.setCoordinateSystemToNormalizedViewport(),e.positionCoordinate2.setValue(.5,.5),e.positionCoordinate2.setReferenceCoordinate(e.positionCoordinate),y.set(t,e,["property"]),y.setGet(t,e,["mapper"]),dS(t,e)}const vS=y.newInstance(Pf,"vtkActor2D");var MM={newInstance:vS,extend:Pf};const Sn={HANDLE:0,CONTEXT:1},{vtkErrorMacro:yS,vtkWarningMacro:CS}=y,SS=["active","inactive","static"];function fo(t,e){t&&t.setResolveCoincidentTopologyToPolygonOffset&&(t.setResolveCoincidentTopologyToPolygonOffset(),wa.forEach(r=>{if(e[r]){const n=`setRelativeCoincidentTopology${r}OffsetParameters`;if(t[n]){const{factor:a,offset:i}=e[r];t[n](a,i)}}}))}function xS(t){for(var e=arguments.length,r=new Array(e>1?e-1:0),n=1;n<e;n++)r[n-1]=arguments[n];const a={active:{},inactive:{},static:{}};return SS.forEach(i=>{const s=a[i];t.forEach(o=>{s[o]||(s[o]={}),r.filter(c=>c&&c[i]&&c[i][o]).forEach(c=>Object.assign(s[o],c[i][o]))})}),a}function wS(t,e,r){r?Object.keys(t).forEach(n=>{const a=t[n].actor===r?e.active[n]:e.inactive[n];a&&t[n].actor.getProperty().set(a)}):(Object.keys(e.static).forEach(n=>{t[n]&&t[n].actor.getProperty().set(e.static[n])}),Object.keys(e.inactive).forEach(n=>{t[n]&&t[n].actor.getProperty().set(e.inactive[n])}))}function RS(t){let e=t.source;t.filter&&(e.isA("vtkDataSet")?t.filter.setInputData(e):t.filter.setInputConnection(e.getOutputPort()),e=t.filter),e&&(e.isA("vtkDataSet")?t.mapper.setInputData(e):t.mapper.setInputConnection(e.getOutputPort())),t.glyph&&t.mapper.setInputConnection(t.glyph.getOutputPort(),1),t.actor.setMapper(t.mapper)}function Rt(t,e,r,n,a){var s;let i=((s=t[`get${y.capitalize(e)}`])==null?void 0:s.call(t))||t.getPointData().getArrayByName(e);if(!i||n!==void 0&&i.getDataType()!==n||a!==void 0&&i.getNumberOfComponents()!==a){let o=A,c=n,u=a;e==="points"?(o=er,c=c??"Float32Array",u=a??3):Yn.includes(e)?(o=vn,c=c??"Uint16Array",u=a??1):(c=c??"Float32Array",u=a??1),i=o.newInstance({name:e,dataType:c,numberOfComponents:u,size:u*r,empty:r===0}),e==="points"||Yn.includes(e)?t[`set${y.capitalize(e)}`](i):t.getPointData().addArray(i)}else i.getNumberOfTuples()!==r&&i.resize(r);return i}function MS(t,e){e.classHierarchy.push("vtkWidgetRepresentation");const r={mtimes:{},states:[]};e._onCoincidentTopologyParametersChanged=()=>{t.getActors().forEach(n=>{fo(n.getMapper(),e.coincidentTopologyParameters)})},t.getActors=()=>e.actors,t.getNestedProps=t.getActors,t.setLabels=function(){for(var n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];a.length===1?e.labels=[].concat(a[0]):e.labels=a,t.modified()},t.getRepresentationStates=function(){let n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:e.inputData[0];return r.mtimes.representation===t.getMTime()&&r.mtimes.input===n.getMTime()||(r.mtimes.representation=t.getMTime(),r.mtimes.input=n.getMTime(),r.states=[],e.labels.forEach(a=>{r.states=r.states.concat(n.getStatesWithLabel(a)||[])})),r.states},t.getSelectedState=(n,a)=>{const i=t.getRepresentationStates();return a<i.length?i[a]:(yS(`Representation ${t.getClassName()} should implement getSelectedState(prop, compositeID) method.`),null)},t.updateActorVisibility=function(){let n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:oa.FRONT_BUFFER,a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0,i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!0,s=!0;switch(e.behavior){case Sn.HANDLE:s=n===oa.PICKING_BUFFER||i;break;case Sn.CONTEXT:s=a;break;default:s=!0;break}const o=s;for(let c=0;c<e.actors.length;c++)e.visibilityFlagArray?e.actors[c].setVisibility(o&&e.visibilityFlagArray[c]):e.actors[c].setVisibility(o);if(e.alwaysVisibleActors)for(let c=0;c<e.alwaysVisibleActors.length;c++)e.alwaysVisibleActors[c].setVisibility(!0)},e.actors.push=function(){CS("You should use publicAPI.addActor() to initialize the actor properly");for(var n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];a.forEach(s=>t.addActor(s))},t.addActor=n=>{fo(n.getMapper(),e.coincidentTopologyParameters),Array.prototype.push.apply(e.actors,[n])},t.setLabels(e.labels)}function OS(t){return{activeScaleFactor:1.2,activeColor:1,useActiveColor:!0,actors:[],labels:[],behavior:Sn.CONTEXT,coincidentTopologyParameters:{Point:{factor:-1,offset:-1},Line:{factor:-1,offset:-1},Polygon:{factor:-1,offset:-1}},scaleInPixels:!1,displayScaleParams:{dispHeightFactor:1,cameraPosition:[0,0,0],cameraDir:[1,0,0],isParallel:!1,rendererPixelDims:[1,1]},_internalArrays:{},...t}}function mS(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};pr.extend(t,e,OS(r)),y.algo(t,e,1,1),y.get(t,e,["labels","displayScaleParams","coincidentTopologyParameters"]),y.set(t,e,[{type:"object",name:"displayScaleParams"},{type:"object",name:"coincidentTopologyParameters"}]),y.setGet(t,e,["scaleInPixels","activeScaleFactor","activeColor","useActiveColor"]),MS(t,e)}var gs={extend:mS,mergeStyles:xS,applyStyles:wS,connectPipeline:RS};function ES(t,e){e.classHierarchy.push("vtkContextRepresentation")}const DS={behavior:Sn.CONTEXT,pickable:!1,dragable:!0};function VS(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};const n={...DS,...r};gs.extend(t,e,n),ES(t,e)}var Jf={extend:VS};const LS={IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025};var ls={States:LS};const{States:at}=ls,Ka={Rotate:at.IS_ROTATE,Pan:at.IS_PAN,Spin:at.IS_SPIN,Dolly:at.IS_DOLLY,CameraPose:at.IS_CAMERA_POSE,WindowLevel:at.IS_WINDOW_LEVEL,Slice:at.IS_SLICE};function FS(t,e){e.classHierarchy.push("vtkInteractorStyle"),Object.keys(Ka).forEach(r=>{y.event(t,e,`Start${r}Event`),t[`start${r}`]=()=>{e.state===at.IS_NONE&&(e.state=Ka[r],e._interactor.requestAnimation(t),t.invokeStartInteractionEvent({type:"StartInteractionEvent"}),t[`invokeStart${r}Event`]({type:`Start${r}Event`}))},y.event(t,e,`End${r}Event`),t[`end${r}`]=()=>{e.state===Ka[r]&&(e.state=at.IS_NONE,e._interactor.cancelAnimation(t),t.invokeEndInteractionEvent({type:"EndInteractionEvent"}),t[`invokeEnd${r}Event`]({type:`End${r}Event`}),e._interactor.render())}}),e.getRenderer=r=>e.focusedRenderer||r.pokedRenderer,t.handleKeyPress=r=>{const n=e._interactor;let a=null;switch(r.key){case"r":case"R":e.getRenderer(r).resetCamera(),n.render();break;case"w":case"W":a=e.getRenderer(r).getActors(),a.forEach(i=>{const s=i.getProperty();s.setRepresentationToWireframe&&s.setRepresentationToWireframe()}),n.render();break;case"s":case"S":a=e.getRenderer(r).getActors(),a.forEach(i=>{const s=i.getProperty();s.setRepresentationToSurface&&s.setRepresentationToSurface()}),n.render();break;case"v":case"V":a=e.getRenderer(r).getActors(),a.forEach(i=>{const s=i.getProperty();s.setRepresentationToPoints&&s.setRepresentationToPoints()}),n.render();break}}}const kS={state:at.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function Qf(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,kS,r),Bf.extend(t,e,r),y.setGet(t,e,["focusedRenderer"]),FS(t,e)}const NS=y.newInstance(Qf,"vtkInteractorStyle");var ps={newInstance:NS,extend:Qf,...ls};const{vtkDebugMacro:Xa}=y,{States:_S}=ps,Vn={type:"StartInteractionEvent"},Et={type:"InteractionEvent"},Ln={type:"EndInteractionEvent"};function Mi(t,e,r,n,a,i){const s=t.getActiveCamera();let o=s.getFocalPoint();o=e.getInteractorStyle().computeWorldToDisplay(t,o[0],o[1],o[2]);const c=o[2],u=e.getInteractorStyle().computeDisplayToWorld(t,r,n,c),g=e.getInteractorStyle().computeDisplayToWorld(t,a,i,c),f=[g[0]-u[0],g[1]-u[1],g[2]-u[2]];o=s.getFocalPoint();const l=s.getPosition();s.setFocalPoint(f[0]+o[0],f[1]+o[1],f[2]+o[2]),s.setPosition(f[0]+l[0],f[1]+l[1],f[2]+l[2])}function GS(t,e,r,n){const a=r.getActiveCamera();if(a.getParallelProjection()){const i=n.getView(),s=i.getViewportSize(r),o=r.getViewport(),c=i.getSize(),u=s[0],g=s[1],f=u/2,l=g/2,p=e.x-o[0]*c[0],d=e.y-o[1]*c[1];Mi(r,n,f,l,p,d),a.setParallelScale(a.getParallelScale()/t),Mi(r,n,p,d,f,l)}else{let i=a.getFocalPoint();const s=a.getViewPlaneNormal();i=n.getInteractorStyle().computeWorldToDisplay(r,i[0],i[1],i[2]);const o=n.getInteractorStyle().computeDisplayToWorld(r,e.x,e.y,i[2]);a.setFocalPoint(o[0],o[1],o[2]),a.dolly(t),r.resetCameraClippingRange();const c=a.getPosition();i=a.getFocalPoint();const u=[0,0,0];let g=s[0]*(i[0]-c[0])+s[1]*(i[1]-c[1])+s[2]*(i[2]-c[2]);g/=s[0]**2+s[1]**2+s[2]**2,u[0]=c[0]+s[0]*g,u[1]=c[1]+s[1]*g,u[2]=c[2]+s[2]*g,a.setFocalPoint(u[0],u[1],u[2]),r.resetCameraClippingRange()}}function US(t,e,r){if(Number.isNaN(r))return;const n=e.getActiveCamera();n.getParallelProjection()?n.setParallelScale(n.getParallelScale()/r):(n.dolly(r),e.resetCameraClippingRange()),t.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}const BS={dollyToPosition:GS,translateCamera:Mi,dollyByFactor:US};function WS(t,e){e.classHierarchy.push("vtkInteractorStyleManipulator"),e.currentVRManipulators=new Map,e.mouseManipulators=[],e.keyboardManipulators=[],e.vrManipulators=[],e.gestureManipulators=[],e.currentManipulator=null,e.currentWheelManipulator=null,e.centerOfRotation=[0,0,0],e.rotationFactor=1,t.removeAllManipulators=()=>{t.removeAllMouseManipulators(),t.removeAllKeyboardManipulators(),t.removeAllVRManipulators(),t.removeAllGestureManipulators()},t.removeAllMouseManipulators=()=>{e.mouseManipulators=[]},t.removeAllKeyboardManipulators=()=>{e.keyboardManipulators=[]},t.removeAllVRManipulators=()=>{e.vrManipulators=[]},t.removeAllGestureManipulators=()=>{e.gestureManipulators=[]};const r=(a,i)=>{const s=i.indexOf(a);return s===-1?!1:(i.splice(s,1),t.modified(),!0)};t.removeMouseManipulator=a=>r(a,e.mouseManipulators),t.removeKeyboardManipulator=a=>r(a,e.keyboardManipulators),t.removeVRManipulator=a=>r(a,e.vrManipulators),t.removeGestureManipulator=a=>r(a,e.gestureManipulators);const n=(a,i)=>i.indexOf(a)!==-1?!1:(i.push(a),t.modified(),!0);t.addMouseManipulator=a=>n(a,e.mouseManipulators),t.addKeyboardManipulator=a=>n(a,e.keyboardManipulators),t.addVRManipulator=a=>n(a,e.vrManipulators),t.addGestureManipulator=a=>n(a,e.gestureManipulators),t.getNumberOfMouseManipulators=()=>e.mouseManipulators.length,t.getNumberOfKeyboardManipulators=()=>e.keyboardManipulators.length,t.getNumberOfVRManipulators=()=>e.vrManipulators.length,t.getNumberOfGestureManipulators=()=>e.gestureManipulators.length,t.resetCurrentManipulator=()=>{e.currentManipulator=null,e.currentWheelManipulator=null},t.handleLeftButtonPress=a=>{e.previousPosition=a.position,t.onButtonDown(1,a)},t.handleMiddleButtonPress=a=>{e.previousPosition=a.position,t.onButtonDown(2,a)},t.handleRightButtonPress=a=>{e.previousPosition=a.position,t.onButtonDown(3,a)},t.handleButton3D=a=>{if(!a)return;const i=t.findVRManipulator(a.device,a.input,a.pressed);i?(e.currentVRManipulators.set(a.device,i),i.onButton3D(t,e.getRenderer(a),e.state,a),a.pressed?t.startCameraPose():(e.currentVRManipulators.delete(a.device),e.currentVRManipulators.size===0&&t.endCameraPose())):Xa("No manipulator found")},t.handleMove3D=a=>{const i=e.currentVRManipulators.get(a.device);i&&e.state===_S.IS_CAMERA_POSE&&i.onMove3D(t,e.getRenderer(a),e.state,a)},t.onButtonDown=(a,i)=>{e.currentManipulator||(e.currentManipulator=t.findMouseManipulator(a,i.shiftKey,i.controlKey,i.altKey),e.currentManipulator?(e.currentManipulator.setCenter&&e.currentManipulator.setCenter(e.centerOfRotation),e.currentManipulator.setRotationFactor&&e.currentManipulator.setRotationFactor(e.rotationFactor),e.currentManipulator.startInteraction(),e.currentManipulator.onButtonDown(e._interactor,e.getRenderer(i),i.position),e._interactor.requestAnimation(t.onButtonDown),t.invokeStartInteractionEvent(Vn)):Xa("No manipulator found"))},t.findMouseManipulator=(a,i,s,o)=>{let c=null,u=e.mouseManipulators.length;for(;u--;){const g=e.mouseManipulators[u];g&&g.getButton()===a&&g.getShift()===i&&g.getControl()===s&&g.getAlt()===o&&g.isDragEnabled()&&(c=g)}return c},t.findVRManipulator=(a,i)=>{let s=null,o=e.vrManipulators.length;for(;o--;){const c=e.vrManipulators[o];c&&c.getDevice()===a&&c.getInput()===i&&(s=c)}return s},t.handleLeftButtonRelease=()=>{t.onButtonUp(1)},t.handleMiddleButtonRelease=()=>{t.onButtonUp(2)},t.handleRightButtonRelease=()=>{t.onButtonUp(3)},t.onButtonUp=a=>{e.currentManipulator&&e.currentManipulator.getButton&&e.currentManipulator.getButton()===a&&(e.currentManipulator.onButtonUp(e._interactor),e.currentManipulator.endInteraction(),e.currentManipulator=null,e._interactor.cancelAnimation(t.onButtonDown),t.invokeEndInteractionEvent(Ln))},t.handleStartMouseWheel=a=>{if(e.currentWheelManipulator)return;let i=null,s=e.mouseManipulators.length;for(;s--;){const o=e.mouseManipulators[s];o&&o.isScrollEnabled()&&o.getShift()===a.shiftKey&&o.getControl()===a.controlKey&&o.getAlt()===a.altKey&&(i=o)}i?(e.currentWheelManipulator=i,e.currentWheelManipulator.onStartScroll(e._interactor,e.getRenderer(a),a.spinY),e.currentWheelManipulator.startInteraction(),e._interactor.requestAnimation(t.handleStartMouseWheel),t.invokeStartInteractionEvent(Vn)):Xa("No manipulator found")},t.handleEndMouseWheel=()=>{e.currentWheelManipulator&&e.currentWheelManipulator.onEndScroll&&(e.currentWheelManipulator.onEndScroll(e._interactor),e.currentWheelManipulator.endInteraction(),e.currentWheelManipulator=null,e._interactor.cancelAnimation(t.handleStartMouseWheel),t.invokeEndInteractionEvent(Ln))},t.handleMouseWheel=a=>{e.currentWheelManipulator&&e.currentWheelManipulator.onScroll&&(e.currentWheelManipulator.onScroll(e._interactor,e.getRenderer(a),a.spinY,e.cachedMousePosition),t.invokeInteractionEvent(Et))},t.handleMouseMove=a=>{e.cachedMousePosition=a.position,e.currentManipulator&&e.currentManipulator.onMouseMove&&(e.currentManipulator.onMouseMove(e._interactor,e.getRenderer(a),a.position),t.invokeInteractionEvent(Et))},t.handleKeyPress=a=>{e.keyboardManipulators.filter(i=>i.onKeyPress).forEach(i=>{i.onKeyPress(e._interactor,e.getRenderer(a),a.key),t.invokeInteractionEvent(Et)})},t.handleKeyDown=a=>{e.keyboardManipulators.filter(i=>i.onKeyDown).forEach(i=>{i.onKeyDown(e._interactor,e.getRenderer(a),a.key),t.invokeInteractionEvent(Et)})},t.handleKeyUp=a=>{e.keyboardManipulators.filter(i=>i.onKeyUp).forEach(i=>{i.onKeyUp(e._interactor,e.getRenderer(a),a.key),t.invokeInteractionEvent(Et)})},t.handleStartPinch=a=>{t.startDolly();let i=e.gestureManipulators.length;for(;i--;){const s=e.gestureManipulators[i];s&&s.isPinchEnabled()&&(s.onStartPinch(e._interactor,a.scale),s.startInteraction())}e._interactor.requestAnimation(t.handleStartPinch),t.invokeStartInteractionEvent(Vn)},t.handleEndPinch=()=>{t.endDolly();let a=e.gestureManipulators.length;for(;a--;){const i=e.gestureManipulators[a];i&&i.isPinchEnabled()&&(i.onEndPinch(e._interactor),i.endInteraction())}e._interactor.cancelAnimation(t.handleStartPinch),t.invokeEndInteractionEvent(Ln)},t.handleStartRotate=a=>{t.startRotate();let i=e.gestureManipulators.length;for(;i--;){const s=e.gestureManipulators[i];s&&s.isRotateEnabled()&&(s.onStartRotate(e._interactor,a.rotation),s.startInteraction())}e._interactor.requestAnimation(t.handleStartRotate),t.invokeStartInteractionEvent(Vn)},t.handleEndRotate=()=>{t.endRotate();let a=e.gestureManipulators.length;for(;a--;){const i=e.gestureManipulators[a];i&&i.isRotateEnabled()&&(i.onEndRotate(e._interactor),i.endInteraction())}e._interactor.cancelAnimation(t.handleStartRotate),t.invokeEndInteractionEvent(Ln)},t.handleStartPan=a=>{t.startPan();let i=e.gestureManipulators.length;for(;i--;){const s=e.gestureManipulators[i];s&&s.isPanEnabled()&&(s.onStartPan(e._interactor,a.translation),s.startInteraction())}e._interactor.requestAnimation(t.handleStartPan),t.invokeStartInteractionEvent(Vn)},t.handleEndPan=()=>{t.endPan();let a=e.gestureManipulators.length;for(;a--;){const i=e.gestureManipulators[a];i&&i.isPanEnabled()&&(i.onEndPan(e._interactor),i.endInteraction())}e._interactor.cancelAnimation(t.handleStartPan),t.invokeEndInteractionEvent(Ln)},t.handlePinch=a=>{let i=e.gestureManipulators.length,s=0;for(;i--;){const o=e.gestureManipulators[i];o&&o.isPinchEnabled()&&(o.onPinch(e._interactor,e.getRenderer(a),a.scale),s++)}s&&t.invokeInteractionEvent(Et)},t.handlePan=a=>{let i=e.gestureManipulators.length,s=0;for(;i--;){const o=e.gestureManipulators[i];o&&o.isPanEnabled()&&(o.onPan(e._interactor,e.getRenderer(a),a.translation),s++)}s&&t.invokeInteractionEvent(Et)},t.handleRotate=a=>{let i=e.gestureManipulators.length,s=0;for(;i--;){const o=e.gestureManipulators[i];o&&o.isRotateEnabled()&&(o.onRotate(e._interactor,e.getRenderer(a),a.rotation),s++)}s&&t.invokeInteractionEvent(Et)}}const $S=t=>({cachedMousePosition:null,currentManipulator:null,currentWheelManipulator:null,centerOfRotation:[0,0,0],rotationFactor:1,...t});function If(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,$S(r)),ps.extend(t,e,r),y.setGet(t,e,["rotationFactor"]),y.get(t,e,["mouseManipulators","keyboardManipulators","vrManipulators","gestureManipulators"]),y.setGetArray(t,e,["centerOfRotation"],3),WS(t,e)}const zS=y.newInstance(If,"vtkInteractorStyleManipulator");var go={newInstance:zS,extend:If,...BS};function HS(t,e){e.classHierarchy.push("vtkCompositeCameraManipulator"),t.computeDisplayCenter=(r,n)=>{const a=r.computeWorldToDisplay(n,e.center[0],e.center[1],e.center[2]);e.displayCenter[0]=a[0],e.displayCenter[1]=a[1]}}const jS={center:[0,0,0],rotationFactor:1,displayCenter:[0,0]};function bS(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,jS,r),y.setGet(t,e,["rotationFactor"]),y.setGetArray(t,e,["displayCenter"],2),y.setGetArray(t,e,["center"],3),HS(t,e)}var hs={extend:bS};function KS(t,e){e.classHierarchy.push("vtkCompositeMouseManipulator"),t.startInteraction=()=>{},t.endInteraction=()=>{},t.onButtonDown=(r,n,a)=>{},t.onButtonUp=r=>{},t.onMouseMove=(r,n,a)=>{},t.onStartScroll=(r,n,a)=>{},t.onScroll=(r,n,a)=>{},t.onEndScroll=r=>{},t.isDragEnabled=()=>e.dragEnabled,t.isScrollEnabled=()=>e.scrollEnabled}const XS={button:1,shift:!1,control:!1,alt:!1,dragEnabled:!0,scrollEnabled:!1};function AS(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,XS,r),y.setGet(t,e,["button","shift","control","alt"]),y.set(t,e,["dragEnabled","scrollEnabled"]),KS(t,e)}var Oa={extend:AS};function YS(t,e){e.classHierarchy.push("vtkMouseCameraTrackballPanManipulator"),t.onButtonDown=(r,n,a)=>{e.previousPosition=a},t.onMouseMove=(r,n,a)=>{if(!a)return;const i=a,s=e.previousPosition;e.previousPosition=a;const o=n.getActiveCamera(),c=o.getPosition(),u=o.getFocalPoint();if(o.getParallelProjection()){o.orthogonalizeViewUp();const g=o.getViewUp(),f=o.getViewPlaneNormal(),l=[0,0,0];Te(f,g,l);const p=r.getView().getViewportSize(n)[1];let d=(i.x-s.x)/p,h=(s.y-i.y)/p;const T=o.getParallelScale();d*=T*2,h*=T*2;let v=l[0]*d+g[0]*h;c[0]+=v,u[0]+=v,v=l[1]*d+g[1]*h,c[1]+=v,u[1]+=v,v=l[2]*d+g[2]*h,c[2]+=v,u[2]+=v,o.setPosition(c[0],c[1],c[2]),o.setFocalPoint(u[0],u[1],u[2])}else{const{center:g}=e,f=r.getInteractorStyle(),l=f.computeWorldToDisplay(n,g[0],g[1],g[2])[2],p=f.computeDisplayToWorld(n,i.x,i.y,l),d=f.computeDisplayToWorld(n,s.x,s.y,l),h=[c[0]+(d[0]-p[0]),c[1]+(d[1]-p[1]),c[2]+(d[2]-p[2])],T=[u[0]+(d[0]-p[0]),u[1]+(d[1]-p[1]),u[2]+(d[2]-p[2])];o.setPosition(h[0],h[1],h[2]),o.setFocalPoint(T[0],T[1],T[2])}n.resetCameraClippingRange(),r.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()}}const qS={};function eg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,qS,r),y.obj(t,e),hs.extend(t,e,r),Oa.extend(t,e,r),YS(t,e)}const ZS=y.newInstance(eg,"vtkMouseCameraTrackballPanManipulator");var OM={newInstance:ZS,extend:eg};function PS(t,e){e.classHierarchy.push("vtkMouseCameraTrackballZoomManipulator"),t.onButtonDown=(r,n,a)=>{e.previousPosition=a;const i=r.getView().getViewportSize(n),s=n.getActiveCamera(),o=e.flipDirection?-1:1;if(s.getParallelProjection())e.zoomScale=1.5/i[1]*o;else{const c=s.getClippingRange();e.zoomScale=1.5*(c[1]/i[1])*o}},t.onMouseMove=(r,n,a)=>{if(!a)return;const i=e.previousPosition.y-a.y,s=n.getActiveCamera();if(s.getParallelProjection()){const o=i*e.zoomScale;s.setParallelScale((1-o)*s.getParallelScale())}else{const o=s.getPosition(),c=s.getFocalPoint(),u=s.getDirectionOfProjection(),g=i*e.zoomScale;let f=g*u[0];o[0]+=f,c[0]+=f,f=g*u[1],o[1]+=f,c[1]+=f,f=g*u[2],o[2]+=f,c[2]+=f,s.getFreezeFocalPoint()||s.setFocalPoint(c[0],c[1],c[2]),s.setPosition(o[0],o[1],o[2]),n.resetCameraClippingRange()}r.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera(),e.previousPosition=a},t.onScroll=(r,n,a)=>{if(!a)return;const i=n.getActiveCamera(),s=1-a/10;i.getParallelProjection()?i.setParallelScale(i.getParallelScale()/s):(i.dolly(s),n.resetCameraClippingRange()),r.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()}}const JS={zoomScale:0,flipDirection:!1};function tg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,JS,r),y.obj(t,e),Oa.extend(t,e,r),hs.extend(t,e,r),y.setGet(t,e,["flipDirection"]),PS(t,e)}const QS=y.newInstance(tg,"vtkMouseCameraTrackballZoomManipulator");var IS={newInstance:QS,extend:tg};const ex="WebGL",fa=Object.create(null);function ng(t,e){fa[t]=e}function tx(){return Object.keys(fa)}function rg(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};return fa[t]&&fa[t](e)}function nx(t,e){e.classHierarchy.push("vtkRenderWindow"),t.addRenderer=r=>{t.hasRenderer(r)||(r.setRenderWindow(t),e.renderers.push(r),t.modified())},t.removeRenderer=r=>{e.renderers=e.renderers.filter(n=>n!==r),t.modified()},t.hasRenderer=r=>e.renderers.indexOf(r)!==-1,t.newAPISpecificView=function(r){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};return rg(r||e.defaultViewAPI,n)},t.addView=r=>{t.hasView(r)||(r.setRenderable(t),e._views.push(r),t.modified())},t.removeView=r=>{e._views=e._views.filter(n=>n!==r),t.modified()},t.hasView=r=>e._views.indexOf(r)!==-1,t.preRender=()=>{e.renderers.forEach(r=>{r.isActiveCameraCreated()||r.resetCamera()})},t.render=()=>{t.preRender(),e.interactor?e.interactor.render():e._views.forEach(r=>r.traverseAllPasses())},t.getStatistics=()=>{const r={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return e._views.forEach(n=>{n.getGraphicsMemoryInfo&&(r.gpuMemoryMB+=n.getGraphicsMemoryInfo()/1e6)}),e.renderers.forEach(n=>{const a=n.getViewProps(),i=e._views[0].getViewNodeFor(n);a.forEach(s=>{if(s.getVisibility()){r.propCount+=1;const o=s.getMapper&&s.getMapper();if(o&&o.getPrimitiveCount){const c=i.getViewNodeFor(o);if(c){c.getAllocatedGPUMemoryInBytes&&(r.gpuMemoryMB+=c.getAllocatedGPUMemoryInBytes()/1e6);const u=o.getPrimitiveCount();Object.keys(u).forEach(g=>{r[g]||(r[g]=0),r[g]+=u[g]})}}}else r.invisiblePropCount+=1})}),r.str=Object.keys(r).map(n=>`${n}: ${r[n]}`).join(`
`),r},t.captureImages=function(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"image/png",n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};return y.setImmediate(t.render),e._views.map(a=>a.captureNextImage?a.captureNextImage(r,n):void 0).filter(a=>!!a)},t.addRenderWindow=r=>e.childRenderWindows.includes(r)?!1:(e.childRenderWindows.push(r),t.modified(),!0),t.removeRenderWindow=r=>{const n=e.childRenderWindows.findIndex(a=>a===r);return n<0?!1:(e.childRenderWindows.splice(n,1),t.modified(),!0)}}const rx={defaultViewAPI:ex,renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1,childRenderWindows:[]};function ag(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,rx,r),y.obj(t,e),y.setGet(t,e,["interactor","numberOfLayers","_views","defaultViewAPI"]),y.get(t,e,["neverRendered"]),y.getArray(t,e,["renderers","childRenderWindows"]),y.moveToProtected(t,e,["views"]),y.event(t,e,"completion"),nx(t,e)}const ax=y.newInstance(ag,"vtkRenderWindow");var ix={newInstance:ax,extend:ag,registerViewConstructor:ng,listViewAPIs:tx,newAPISpecificView:rg};const{vtkDebugMacro:Gr}=y;function sx(t,e){e.classHierarchy.push("vtkCamera");const r=new Float64Array(3),n=new Float64Array([0,0,-1]),a=new Float64Array([0,1,0]),i=X(new Float64Array(16)),s=X(new Float64Array(16)),o=new Float64Array(3),c=new Float64Array(3),u=new Float64Array(3),g=X(new Float64Array(16)),f=X(new Float64Array(16)),l=new Float64Array(3),p=new Float64Array(3);function d(){e.viewPlaneNormal[0]=-e.directionOfProjection[0],e.viewPlaneNormal[1]=-e.directionOfProjection[1],e.viewPlaneNormal[2]=-e.directionOfProjection[2]}t.orthogonalizeViewUp=()=>{const h=t.getViewMatrix();e.viewUp[0]=h[4],e.viewUp[1]=h[5],e.viewUp[2]=h[6],t.modified()},t.setPosition=(h,T,v)=>{h===e.position[0]&&T===e.position[1]&&v===e.position[2]||(e.position[0]=h,e.position[1]=T,e.position[2]=v,t.computeDistance(),t.modified())},t.setFocalPoint=(h,T,v)=>{h===e.focalPoint[0]&&T===e.focalPoint[1]&&v===e.focalPoint[2]||(e.focalPoint[0]=h,e.focalPoint[1]=T,e.focalPoint[2]=v,t.computeDistance(),t.modified())},t.setDistance=h=>{if(e.distance===h)return;e.distance=h,e.distance<1e-20&&(e.distance=1e-20,Gr("Distance is set to minimum."));const T=e.directionOfProjection;e.focalPoint[0]=e.position[0]+T[0]*e.distance,e.focalPoint[1]=e.position[1]+T[1]*e.distance,e.focalPoint[2]=e.position[2]+T[2]*e.distance,t.modified()},t.computeDistance=()=>{const h=e.focalPoint[0]-e.position[0],T=e.focalPoint[1]-e.position[1],v=e.focalPoint[2]-e.position[2];if(e.distance=Math.sqrt(h*h+T*T+v*v),e.distance<1e-20){e.distance=1e-20,Gr("Distance is set to minimum.");const C=e.directionOfProjection;e.focalPoint[0]=e.position[0]+C[0]*e.distance,e.focalPoint[1]=e.position[1]+C[1]*e.distance,e.focalPoint[2]=e.position[2]+C[2]*e.distance}e.directionOfProjection[0]=h/e.distance,e.directionOfProjection[1]=T/e.distance,e.directionOfProjection[2]=v/e.distance,d()},t.dolly=h=>{if(h<=0)return;const T=e.distance/h;t.setPosition(e.focalPoint[0]-T*e.directionOfProjection[0],e.focalPoint[1]-T*e.directionOfProjection[1],e.focalPoint[2]-T*e.directionOfProjection[2])},t.roll=h=>{const T=e.position,v=e.focalPoint,C=e.viewUp,S=new Float64Array([C[0],C[1],C[2],0]);X(g);const x=new Float64Array([v[0]-T[0],v[1]-T[1],v[2]-T[2]]);Fe(g,g,fe(h),x),Tr(S,S,g),e.viewUp[0]=S[0],e.viewUp[1]=S[1],e.viewUp[2]=S[2],t.modified()},t.azimuth=h=>{const T=e.focalPoint;X(f),ge(f,f,T),Fe(f,f,fe(h),e.viewUp),ge(f,f,[-T[0],-T[1],-T[2]]),q(l,e.position,f),t.setPosition(l[0],l[1],l[2])},t.yaw=h=>{const T=e.position;X(f),ge(f,f,T),Fe(f,f,fe(h),e.viewUp),ge(f,f,[-T[0],-T[1],-T[2]]),q(p,e.focalPoint,f),t.setFocalPoint(p[0],p[1],p[2])},t.elevation=h=>{const T=e.focalPoint,v=t.getViewMatrix(),C=[-v[0],-v[1],-v[2]];X(f),ge(f,f,T),Fe(f,f,fe(h),C),ge(f,f,[-T[0],-T[1],-T[2]]),q(l,e.position,f),t.setPosition(l[0],l[1],l[2])},t.pitch=h=>{const T=e.position,v=t.getViewMatrix(),C=[v[0],v[1],v[2]];X(f),ge(f,f,T),Fe(f,f,fe(h),C),ge(f,f,[-T[0],-T[1],-T[2]]),q(p,e.focalPoint,f),t.setFocalPoint(...p)},t.zoom=h=>{h<=0||(e.parallelProjection?e.parallelScale/=h:e.viewAngle/=h,t.modified())},t.translate=(h,T,v)=>{const C=[h,T,v];Qe(e.position,C,e.position),Qe(e.focalPoint,C,e.focalPoint),t.computeDistance(),t.modified()},t.applyTransform=h=>{const T=[...e.viewUp,1],v=[],C=[],S=[];T[0]+=e.position[0],T[1]+=e.position[1],T[2]+=e.position[2],Tr(v,[...e.position,1],h),Tr(C,[...e.focalPoint,1],h),Tr(S,T,h),S[0]-=v[0],S[1]-=v[1],S[2]-=v[2],t.setPosition(...v.slice(0,3)),t.setFocalPoint(...C.slice(0,3)),t.setViewUp(...S.slice(0,3))},t.getThickness=()=>e.clippingRange[1]-e.clippingRange[0],t.setThickness=h=>{let T=h;T<1e-20&&(T=1e-20,Gr("Thickness is set to minimum.")),t.setClippingRange(e.clippingRange[0],e.clippingRange[0]+T)},t.setThicknessFromFocalPoint=h=>{let T=h;T<1e-20&&(T=1e-20,Gr("Thickness is set to minimum.")),t.setClippingRange(e.distance-T/2,e.distance+T/2)},t.setRoll=h=>{},t.getRoll=()=>{},t.setObliqueAngles=(h,T)=>{},t.getOrientation=()=>{},t.getOrientationWXYZ=()=>{},t.getFrustumPlanes=h=>{},t.getCameraLightTransformMatrix=h=>(Re(h,e.cameraLightTransform),h),t.computeCameraLightTransform=()=>{Re(i,t.getViewMatrix()),je(i,i),Go(s,[e.distance,e.distance,e.distance]),ae(i,i,s),X(e.cameraLightTransform),ge(e.cameraLightTransform,i,[0,0,-1])},t.deepCopy=h=>{},t.physicalOrientationToWorldDirection=h=>{const T=Ms(h[0],h[1],h[2],h[3]),v=Pn(),C=Ms(0,0,1,0);return Nl(v,T),Os(C,T,C),Os(C,C,v),[C[0],C[1],C[2]]},t.getPhysicalToWorldMatrix=h=>{t.getWorldToPhysicalMatrix(h),je(h,h)},t.getWorldToPhysicalMatrix=h=>{X(h);const T=[3];Te(e.physicalViewNorth,e.physicalViewUp,T),h[0]=T[0],h[1]=T[1],h[2]=T[2],h[4]=e.physicalViewUp[0],h[5]=e.physicalViewUp[1],h[6]=e.physicalViewUp[2],h[8]=-e.physicalViewNorth[0],h[9]=-e.physicalViewNorth[1],h[10]=-e.physicalViewNorth[2],se(h,h),oe(o,1/e.physicalScale,1/e.physicalScale,1/e.physicalScale),nn(h,h,o),ge(h,h,e.physicalTranslation)},t.computeViewParametersFromViewMatrix=h=>{je(i,h),q(o,r,i),t.computeDistance();const T=e.distance;t.setPosition(o[0],o[1],o[2]),q(c,n,i),Pa(c,c,o),Ct(c,c),t.setDirectionOfProjection(c[0],c[1],c[2]),q(u,a,i),Pa(u,u,o),Ct(u,u),t.setViewUp(u[0],u[1],u[2]),t.setDistance(T)},t.computeViewParametersFromPhysicalMatrix=h=>{t.getWorldToPhysicalMatrix(i),ae(i,h,i),t.computeViewParametersFromViewMatrix(i)},t.setViewMatrix=h=>{e.viewMatrix=h,e.viewMatrix&&(Re(i,e.viewMatrix),t.computeViewParametersFromViewMatrix(i),se(e.viewMatrix,e.viewMatrix))},t.getViewMatrix=()=>{if(e.viewMatrix)return e.viewMatrix;_l(i,e.position,e.focalPoint,e.viewUp),se(i,i);const h=new Float64Array(16);return Re(h,i),h},t.setProjectionMatrix=h=>{e.projectionMatrix=h},t.getProjectionMatrix=(h,T,v)=>{const C=new Float64Array(16);if(X(C),e.projectionMatrix){const R=1/e.physicalScale;return oe(o,R,R,R),Re(C,e.projectionMatrix),nn(C,C,o),se(C,C),C}X(i);const S=e.clippingRange[1]-e.clippingRange[0],x=[e.clippingRange[0]+(T+1)*S/2,e.clippingRange[0]+(v+1)*S/2];if(e.parallelProjection){const R=e.parallelScale*h,O=e.parallelScale,w=(e.windowCenter[0]-1)*R,m=(e.windowCenter[0]+1)*R,E=(e.windowCenter[1]-1)*O,M=(e.windowCenter[1]+1)*O;Gl(i,w,m,E,M,x[0],x[1]),se(i,i)}else{if(e.useOffAxisProjection)throw new Error("Off-Axis projection is not supported at this time");{const R=Math.tan(fe(e.viewAngle)/2);let O,w;e.useHorizontalViewAngle===!0?(O=e.clippingRange[0]*R,w=e.clippingRange[0]*R/h):(O=e.clippingRange[0]*R*h,w=e.clippingRange[0]*R);const m=(e.windowCenter[0]-1)*O,E=(e.windowCenter[0]+1)*O,M=(e.windowCenter[1]-1)*w,D=(e.windowCenter[1]+1)*w,N=x[0],G=x[1];i[0]=2*N/(E-m),i[5]=2*N/(D-M),i[2]=(m+E)/(E-m),i[6]=(M+D)/(D-M),i[10]=-(N+G)/(G-N),i[14]=-1,i[11]=-2*N*G/(G-N),i[15]=0}}return Re(C,i),C},t.getCompositeProjectionMatrix=(h,T,v)=>{const C=t.getViewMatrix(),S=t.getProjectionMatrix(h,T,v);return ae(S,C,S),S},t.setDirectionOfProjection=(h,T,v)=>{if(e.directionOfProjection[0]===h&&e.directionOfProjection[1]===T&&e.directionOfProjection[2]===v)return;e.directionOfProjection[0]=h,e.directionOfProjection[1]=T,e.directionOfProjection[2]=v;const C=e.directionOfProjection;e.focalPoint[0]=e.position[0]+C[0]*e.distance,e.focalPoint[1]=e.position[1]+C[1]*e.distance,e.focalPoint[2]=e.position[2]+C[2]*e.distance,d()},t.setDeviceAngles=(h,T,v,C)=>{const S=[3];Te(e.physicalViewNorth,e.physicalViewUp,S);const x=X(new Float64Array(16));Fe(x,x,fe(h),e.physicalViewUp),Fe(x,x,fe(T),S),Fe(x,x,fe(v),e.physicalViewNorth),Fe(x,x,fe(-C),e.physicalViewUp);const R=new Float64Array([-e.physicalViewUp[0],-e.physicalViewUp[1],-e.physicalViewUp[2]]),O=new Float64Array(e.physicalViewNorth);q(R,R,x),q(O,O,x),t.setDirectionOfProjection(R[0],R[1],R[2]),t.setViewUp(O[0],O[1],O[2]),t.modified()},t.setOrientationWXYZ=(h,T,v,C)=>{const S=X(new Float64Array(16));if(h!==0&&(T!==0||v!==0||C!==0)){const O=fe(h),w=Pn();Bo(w,[T,v,C],O),Ja(S,w)}const x=new Float64Array(3);q(x,[0,0,-1],S);const R=new Float64Array(3);q(R,[0,1,0],S),t.setDirectionOfProjection(...x),t.setViewUp(...R),t.modified()},t.computeClippingRange=h=>{let T=null,v=null;T=e.viewPlaneNormal,v=e.position;const C=-T[0],S=-T[1],x=-T[2],R=-(C*v[0]+S*v[1]+x*v[2]),O=[C*h[0]+S*h[2]+x*h[4]+R,1e-18];for(let w=0;w<2;w++)for(let m=0;m<2;m++)for(let E=0;E<2;E++){const M=C*h[E]+S*h[2+m]+x*h[4+w]+R;O[0]=M<O[0]?M:O[0],O[1]=M>O[1]?M:O[1]}return O}}const ox={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,cameraLightTransform:Uo(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function ig(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,ox,r),y.obj(t,e),y.get(t,e,["distance"]),y.setGet(t,e,["parallelProjection","useHorizontalViewAngle","viewAngle","parallelScale","useOffAxisProjection","freezeFocalPoint","physicalScale"]),y.getArray(t,e,["directionOfProjection","viewPlaneNormal","position","focalPoint"]),y.setGetArray(t,e,["clippingRange","windowCenter"],2),y.setGetArray(t,e,["viewUp","screenBottomLeft","screenBottomRight","screenTopRight","physicalTranslation","physicalViewUp","physicalViewNorth"],3),sx(t,e)}const cx=y.newInstance(ig,"vtkCamera");var ux={newInstance:cx,extend:ig};const fx=["HeadLight","CameraLight","SceneLight"];function gx(t,e){e.classHierarchy.push("vtkLight");const r=new Float64Array(3);t.getTransformedPosition=()=>(e.transformMatrix?q(r,e.position,e.transformMatrix):oe(r,e.position[0],e.position[1],e.position[2]),r),t.getTransformedFocalPoint=()=>(e.transformMatrix?q(r,e.focalPoint,e.transformMatrix):oe(r,e.focalPoint[0],e.focalPoint[1],e.focalPoint[2]),r),t.getDirection=()=>(e.directionMTime<e.mtime&&(Qa(e.direction,e.focalPoint,e.position),pe(e.direction),e.directionMTime=e.mtime),e.direction),t.setDirection=n=>{const a=new Float64Array(3);Qa(a,e.position,n),e.focalPoint=a},t.setDirectionAngle=(n,a)=>{const i=fe(n),s=fe(a);t.setPosition(Math.cos(i)*Math.sin(s),Math.sin(i),Math.cos(i)*Math.cos(s)),t.setFocalPoint(0,0,0),t.setPositional(0)},t.setLightTypeToHeadLight=()=>{t.setLightType("HeadLight")},t.setLightTypeToCameraLight=()=>{t.setLightType("CameraLight")},t.setLightTypeToSceneLight=()=>{t.setTransformMatrix(null),t.setLightType("SceneLight")},t.lightTypeIsHeadLight=()=>e.lightType==="HeadLight",t.lightTypeIsSceneLight=()=>e.lightType==="SceneLight",t.lightTypeIsCameraLight=()=>e.lightType==="CameraLight"}const lx={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:"SceneLight",shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function sg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,lx,r),y.obj(t,e),y.setGet(t,e,["intensity","switch","positional","exponent","coneAngle","coneFalloff","transformMatrix","lightType","shadowAttenuation","attenuationValues"]),y.setGetArray(t,e,["color","position","focalPoint","attenuationValues"],3),gx(t,e)}const px=y.newInstance(sg,"vtkLight");var hx={newInstance:px,extend:sg,LIGHT_TYPES:fx};const{vtkErrorMacro:Xr}=y;function dx(t){return()=>Xr(`vtkViewport::${t} - NOT IMPLEMENTED`)}function Tx(t,e){e.classHierarchy.push("vtkViewport"),t.getViewProps=()=>e.props,t.hasViewProp=n=>e.props.includes(n),t.addViewProp=n=>{n&&!t.hasViewProp(n)&&e.props.push(n)},t.removeViewProp=n=>{const a=e.props.filter(i=>i!==n);e.props.length!==a.length&&(e.props=a)},t.removeAllViewProps=()=>{e.props=[]};function r(n){let a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[];a.push(n);const i=n.getNestedProps();if(i&&i.length)for(let s=0;s<i.length;s++)r(i[s],a);return a}t.getViewPropsWithNestedProps=()=>{const n=[];for(let a=0;a<e.props.length;a++)r(e.props[a],n);return n},t.addActor2D=t.addViewProp,t.removeActor2D=n=>{t.removeViewProp(n)},t.getActors2D=()=>(e.actors2D=[],e.props.forEach(n=>{e.actors2D=e.actors2D.concat(n.getActors2D())}),e.actors2D),t.displayToView=()=>Xr("call displayToView on your view instead"),t.viewToDisplay=()=>Xr("callviewtodisplay on your view instead"),t.getSize=()=>Xr("call getSize on your View instead"),t.normalizedDisplayToProjection=(n,a,i)=>{const s=t.normalizedDisplayToNormalizedViewport(n,a,i);return t.normalizedViewportToProjection(s[0],s[1],s[2])},t.normalizedDisplayToNormalizedViewport=(n,a,i)=>{const s=[e.viewport[2]-e.viewport[0],e.viewport[3]-e.viewport[1]];return[(n-e.viewport[0])/s[0],(a-e.viewport[1])/s[1],i]},t.normalizedViewportToProjection=(n,a,i)=>[n*2-1,a*2-1,i*2-1],t.projectionToNormalizedDisplay=(n,a,i)=>{const s=t.projectionToNormalizedViewport(n,a,i);return t.normalizedViewportToNormalizedDisplay(s[0],s[1],s[2])},t.normalizedViewportToNormalizedDisplay=(n,a,i)=>{const s=[e.viewport[2]-e.viewport[0],e.viewport[3]-e.viewport[1]];return[n*s[0]+e.viewport[0],a*s[1]+e.viewport[1],i]},t.projectionToNormalizedViewport=(n,a,i)=>[(n+1)*.5,(a+1)*.5,(i+1)*.5],t.PickPropFrom=dx("PickPropFrom")}const vx={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function og(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,vx,r),y.obj(t,e),y.event(t,e,"event"),y.setGetArray(t,e,["viewport"],4),y.setGetArray(t,e,["background","background2"],3),Tx(t,e)}const yx=y.newInstance(og,"vtkViewport");var Cx={newInstance:yx,extend:og};const{vtkDebugMacro:Fn,vtkErrorMacro:Lt,vtkWarningMacro:Sx}=We;function lo(t){return()=>Lt(`vtkRenderer::${t} - NOT IMPLEMENTED`)}function xx(t,e){e.classHierarchy.push("vtkRenderer");const r={type:"ComputeVisiblePropBoundsEvent",renderer:t},n={type:"ResetCameraClippingRangeEvent",renderer:t},a={type:"ResetCameraEvent",renderer:t};t.updateCamera=()=>(e.activeCamera||(Fn("No cameras are on, creating one."),t.getActiveCameraAndResetIfCreated()),e.activeCamera.render(t),!0),t.updateLightsGeometryToFollowCamera=()=>{const i=t.getActiveCameraAndResetIfCreated();e.lights.forEach(s=>{s.lightTypeIsSceneLight()||(s.lightTypeIsHeadLight()?(s.setPositionFrom(i.getPositionByReference()),s.setFocalPointFrom(i.getFocalPointByReference()),s.modified(i.getMTime())):s.lightTypeIsCameraLight()?s.setTransformMatrix(i.getCameraLightTransformMatrix(Uo())):Lt("light has unknown light type",s.get()))})},t.updateLightGeometry=()=>e.lightFollowCamera?t.updateLightsGeometryToFollowCamera():!0,t.allocateTime=lo("allocateTime"),t.updateGeometry=lo("updateGeometry"),t.getVTKWindow=()=>e._renderWindow,t.setLayer=i=>{Fn(t.getClassName(),t,"setting Layer to ",i),e.layer!==i&&(e.layer=i,t.modified()),t.setPreserveColorBuffer(!!i)},t.setActiveCamera=i=>e.activeCamera===i?!1:(e.activeCamera=i,t.modified(),t.invokeEvent({type:"ActiveCameraEvent",camera:i}),!0),t.makeCamera=()=>{const i=ux.newInstance();return t.invokeEvent({type:"CreateCameraEvent",camera:i}),i},t.getActiveCamera=()=>(e.activeCamera||(e.activeCamera=t.makeCamera()),e.activeCamera),t.getActiveCameraAndResetIfCreated=()=>(e.activeCamera||(t.getActiveCamera(),t.resetCamera()),e.activeCamera),t.getActors=()=>(e.actors=[],e.props.forEach(i=>{e.actors=e.actors.concat(i.getActors())}),e.actors),t.addActor=t.addViewProp,t.removeActor=i=>{e.actors=e.actors.filter(s=>s!==i),t.removeViewProp(i),t.modified()},t.removeAllActors=()=>{t.getActors().forEach(s=>{t.removeViewProp(s)}),e.actors=[],t.modified()},t.getVolumes=()=>(e.volumes=[],e.props.forEach(i=>{e.volumes=e.volumes.concat(i.getVolumes())}),e.volumes),t.addVolume=t.addViewProp,t.removeVolume=i=>{e.volumes=e.volumes.filter(s=>s!==i),t.removeViewProp(i),t.modified()},t.removeAllVolumes=()=>{t.getVolumes().forEach(s=>{t.removeViewProp(s)}),e.volumes=[],t.modified()},t.hasLight=i=>e.lights.includes(i),t.addLight=i=>{i&&!t.hasLight(i)&&(e.lights.push(i),t.modified())},t.removeLight=i=>{e.lights=e.lights.filter(s=>s!==i),t.modified()},t.removeAllLights=()=>{e.lights=[],t.modified()},t.setLightCollection=i=>{e.lights=i,t.modified()},t.makeLight=hx.newInstance,t.createLight=()=>{e.automaticLightCreation&&(e._createdLight&&(t.removeLight(e._createdLight),e._createdLight.delete(),e._createdLight=null),e._createdLight=t.makeLight(),t.addLight(e._createdLight),e._createdLight.setLightTypeToHeadLight(),e._createdLight.setPosition(t.getActiveCamera().getPosition()),e._createdLight.setFocalPoint(t.getActiveCamera().getFocalPoint()))},t.normalizedDisplayToWorld=(i,s,o,c)=>{let u=t.normalizedDisplayToProjection(i,s,o);return u=t.projectionToView(u[0],u[1],u[2],c),t.viewToWorld(u[0],u[1],u[2])},t.worldToNormalizedDisplay=(i,s,o,c)=>{let u=t.worldToView(i,s,o);return u=t.viewToProjection(u[0],u[1],u[2],c),t.projectionToNormalizedDisplay(u[0],u[1],u[2])},t.viewToWorld=(i,s,o)=>{if(e.activeCamera===null)return Lt("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const c=e.activeCamera.getViewMatrix();je(c,c),se(c,c);const u=new Float64Array([i,s,o]);return q(u,u,c),u},t.projectionToView=(i,s,o,c)=>{if(e.activeCamera===null)return Lt("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0"),[0,0,0];const u=e.activeCamera.getProjectionMatrix(c,-1,1);je(u,u),se(u,u);const g=new Float64Array([i,s,o]);return q(g,g,u),g},t.worldToView=(i,s,o)=>{if(e.activeCamera===null)return Lt("WorldToView: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const c=e.activeCamera.getViewMatrix();se(c,c);const u=new Float64Array([i,s,o]);return q(u,u,c),u},t.viewToProjection=(i,s,o,c)=>{if(e.activeCamera===null)return Lt("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0"),[0,0,0];const u=e.activeCamera.getProjectionMatrix(c,-1,1);se(u,u);const g=new Float64Array([i,s,o]);return q(g,g,u),g},t.computeVisiblePropBounds=()=>{e.allBounds[0]=K.INIT_BOUNDS[0],e.allBounds[1]=K.INIT_BOUNDS[1],e.allBounds[2]=K.INIT_BOUNDS[2],e.allBounds[3]=K.INIT_BOUNDS[3],e.allBounds[4]=K.INIT_BOUNDS[4],e.allBounds[5]=K.INIT_BOUNDS[5];let i=!0;t.invokeEvent(r);for(let s=0;s<e.props.length;++s){const o=e.props[s];if(o.getVisibility()&&o.getUseBounds()){const c=o.getBounds();c&&Hr(c)&&(i=!1,c[0]<e.allBounds[0]&&(e.allBounds[0]=c[0]),c[1]>e.allBounds[1]&&(e.allBounds[1]=c[1]),c[2]<e.allBounds[2]&&(e.allBounds[2]=c[2]),c[3]>e.allBounds[3]&&(e.allBounds[3]=c[3]),c[4]<e.allBounds[4]&&(e.allBounds[4]=c[4]),c[5]>e.allBounds[5]&&(e.allBounds[5]=c[5]))}}return i&&(xn(e.allBounds),Fn("Can't compute bounds, no 3D props are visible")),e.allBounds},t.resetCamera=function(){const s=(arguments.length>0&&arguments[0]!==void 0?arguments[0]:null)||t.computeVisiblePropBounds(),o=[0,0,0];if(!Hr(s))return Fn("Cannot reset camera!"),!1;let c=null;if(t.getActiveCamera())c=e.activeCamera.getViewPlaneNormal();else return Lt("Trying to reset non-existent camera"),!1;e.activeCamera.setViewAngle(30),o[0]=(s[0]+s[1])/2,o[1]=(s[2]+s[3])/2,o[2]=(s[4]+s[5])/2;let u=s[1]-s[0],g=s[3]-s[2],f=s[5]-s[4];u*=u,g*=g,f*=f;let l=u+g+f;l=l===0?1:l,l=Math.sqrt(l)*.5;const p=fe(e.activeCamera.getViewAngle()),d=l,h=l/Math.sin(p*.5),T=e.activeCamera.getViewUp();return Math.abs(b(T,c))>.999&&(Sx("Resetting view-up since view plane normal is parallel"),e.activeCamera.setViewUp(-T[2],T[0],T[1])),e.activeCamera.setFocalPoint(o[0],o[1],o[2]),e.activeCamera.setPosition(o[0]+h*c[0],o[1]+h*c[1],o[2]+h*c[2]),t.resetCameraClippingRange(s),e.activeCamera.setParallelScale(d),e.activeCamera.setPhysicalScale(l),e.activeCamera.setPhysicalTranslation(-o[0],-o[1],-o[2]),t.invokeEvent(a),!0},t.resetCameraClippingRange=function(){const s=(arguments.length>0&&arguments[0]!==void 0?arguments[0]:null)||t.computeVisiblePropBounds();if(!Hr(s))return Fn("Cannot reset camera clipping range!"),!1;if(t.getActiveCameraAndResetIfCreated(),!e.activeCamera)return Lt("Trying to reset clipping range of non-existent camera"),!1;const o=e.activeCamera.computeClippingRange(s);let c=0;if(e.activeCamera.getParallelProjection())c=.2*e.activeCamera.getParallelScale();else{const u=fe(e.activeCamera.getViewAngle());c=.2*Math.tan(u/2)*o[1]}return o[1]-o[0]<c&&(c=c-o[1]+o[0],o[1]+=c/2,o[0]-=c/2),o[0]<0&&(o[0]=0),o[0]=.99*o[0]-(o[1]-o[0])*e.clippingRangeExpansion,o[1]=1.01*o[1]+(o[1]-o[0])*e.clippingRangeExpansion,o[0]=o[0]>=o[1]?.01*o[1]:o[0],e.nearClippingPlaneTolerance||(e.nearClippingPlaneTolerance=.01),o[0]<e.nearClippingPlaneTolerance*o[1]&&(o[0]=e.nearClippingPlaneTolerance*o[1]),e.activeCamera.setClippingRange(o[0],o[1]),t.invokeEvent(n),!1},t.setRenderWindow=i=>{i!==e._renderWindow&&(e._vtkWindow=i,e._renderWindow=i)},t.visibleActorCount=()=>e.props.filter(i=>i.getVisibility()).length,t.visibleVolumeCount=t.visibleActorCount,t.getMTime=()=>{let i=e.mtime;const s=e.activeCamera?e.activeCamera.getMTime():0;s>i&&(i=s);const o=e._createdLight?e._createdLight.getMTime():0;return o>i&&(i=o),i},t.getTransparent=()=>!!e.preserveColorBuffer,t.isActiveCameraCreated=()=>!!e.activeCamera}const wx={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:xt(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function cg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};for(Object.assign(e,wx,r),Cx.extend(t,e,r),e.background||(e.background=[0,0,0,1]);e.background.length<3;)e.background.push(0);e.background.length===3&&e.background.push(1),Ke(t,e,["_renderWindow","allocatedRenderTime","timeFactor","lastRenderTimeInSeconds","numberOfPropsRendered","lastRenderingUsedDepthPeeling","selector"]),Me(t,e,["twoSidedLighting","lightFollowCamera","automaticLightCreation","erase","draw","nearClippingPlaneTolerance","clippingRangeExpansion","backingStore","interactive","layer","preserveColorBuffer","preserveDepthBuffer","useDepthPeeling","occlusionRatio","maximumNumberOfPeels","delegate","backgroundTexture","texturedBackground","environmentTexture","environmentTextureDiffuseStrength","environmentTextureSpecularStrength","useEnvironmentTextureAsBackground","useShadows","pass"]),sr(t,e,["actors","volumes","lights"]),Fi(t,e,["background"],4,1),or(t,e,["renderWindow"]),xx(t,e)}const Rx=ye(cg,"vtkRenderer");var ug={newInstance:Rx,extend:cg};function Mx(t,e){e.classHierarchy.push("vtkRenderPass"),t.getOperation=()=>e.currentOperation,t.setCurrentOperation=r=>{e.currentOperation=r,e.currentTraverseOperation=`traverse${y.capitalize(e.currentOperation)}`},t.getTraverseOperation=()=>e.currentTraverseOperation,t.traverse=function(r){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:null;e.deleted||(e._currentParent=n,e.preDelegateOperations.forEach(a=>{t.setCurrentOperation(a),r.traverse(t)}),e.delegates.forEach(a=>{a.traverse(r,t)}),e.postDelegateOperations.forEach(a=>{t.setCurrentOperation(a),r.traverse(t)}))}}const Ox={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function fg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Ox,r),y.obj(t,e),y.get(t,e,["currentOperation"]),y.setGet(t,e,["delegates","_currentParent","preDelegateOperations","postDelegateOperations"]),y.moveToProtected(t,e,["currentParent"]),Mx(t,e)}const mx=y.newInstance(fg,"vtkRenderPass");var ds={newInstance:mx,extend:fg};const{Representation:Ex}=Ra,{vtkErrorMacro:po}=y;function Dx(t){const e=V.substitute(t.Fragment,"//VTK::RenderPassFragmentShader::Impl",`
      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);
      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);
      gl_FragData[1].r = weight;
    `,!1);t.Fragment=e.result}const Vx=`//VTK::System::Dec

in vec2 tcoord;

uniform sampler2D translucentRTexture;
uniform sampler2D translucentRGBATexture;

// the output of this shader
//VTK::Output::Dec

void main()
{
  vec4 t1Color = texture(translucentRGBATexture, tcoord);
  float t2Color = texture(translucentRTexture, tcoord).r;
  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);
}
`;function Lx(t,e){e.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass"),t.createVertexBuffer=()=>{const r=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),a=new Uint16Array([4,0,1,3,2]),i=A.newInstance({numberOfComponents:3,values:r});i.setName("points");const s=A.newInstance({numberOfComponents:2,values:n});s.setName("tcoords");const o=A.newInstance({numberOfComponents:1,values:a});e.tris.getCABO().createVBO(o,"polys",Ex.SURFACE,{points:i,tcoords:s,cellOffset:0}),e.VBOBuildTime.modified()},t.createFramebuffer=r=>{const n=r.getSize(),a=r.getContext();e.framebuffer=Ma.newInstance(),e.framebuffer.setOpenGLRenderWindow(r),e.framebuffer.create(...n),e.framebuffer.saveCurrentBindingsAndBuffers(),e.framebuffer.bind(),e.translucentRGBATexture=he.newInstance(),e.translucentRGBATexture.setInternalFormat(a.RGBA16F),e.translucentRGBATexture.setFormat(a.RGBA),e.translucentRGBATexture.setOpenGLDataType(a.HALF_FLOAT),e.translucentRGBATexture.setOpenGLRenderWindow(r),e.translucentRGBATexture.create2DFromRaw(n[0],n[1],4,"Float32Array",null),e.translucentRTexture=he.newInstance(),e.translucentRTexture.setInternalFormat(a.R16F),e.translucentRTexture.setFormat(a.RED),e.translucentRTexture.setOpenGLDataType(a.HALF_FLOAT),e.translucentRTexture.setOpenGLRenderWindow(r),e.translucentRTexture.create2DFromRaw(n[0],n[1],1,"Float32Array",null),e.translucentZTexture=he.newInstance(),e.translucentZTexture.setOpenGLRenderWindow(r),e.translucentZTexture.createDepthFromRaw(n[0],n[1],"Float32Array",null),e.framebuffer.setColorBuffer(e.translucentRGBATexture,0),e.framebuffer.setColorBuffer(e.translucentRTexture,1),e.framebuffer.setDepthBuffer(e.translucentZTexture)},t.createCopyShader=r=>{e.copyShader=r.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","attribute vec2 tcoordTC;","varying vec2 tcoord;","void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join(`
`),Vx,"")},t.createVBO=r=>{const n=r.getContext();e.tris.setOpenGLRenderWindow(r),t.createVertexBuffer();const a=e.copyShader;e.tris.getCABO().bind(),e.copyVAO.addAttributeArray(a,e.tris.getCABO(),"vertexDC",e.tris.getCABO().getVertexOffset(),e.tris.getCABO().getStride(),n.FLOAT,3,n.FALSE)||po("Error setting vertexDC in copy shader VAO."),e.copyVAO.addAttributeArray(a,e.tris.getCABO(),"tcoordTC",e.tris.getCABO().getTCoordOffset(),e.tris.getCABO().getStride(),n.FLOAT,2,n.FALSE)||po("Error setting vertexDC in copy shader VAO.")},t.traverse=(r,n,a)=>{if(e.deleted)return;const i=r.getSize(),s=r.getContext();if(e._supported=!1,n.getSelector()||!s||!r.getWebgl2()||!s.getExtension("EXT_color_buffer_half_float")&&!s.getExtension("EXT_color_buffer_float")){t.setCurrentOperation("translucentPass"),n.traverse(t);return}if(e._supported=!0,e.framebuffer===null)t.createFramebuffer(r);else{const c=e.framebuffer.getSize();c===null||c[0]!==i[0]||c[1]!==i[1]?(e.framebuffer.releaseGraphicsResources(),e.translucentRGBATexture.releaseGraphicsResources(r),e.translucentRTexture.releaseGraphicsResources(r),e.translucentZTexture.releaseGraphicsResources(r),t.createFramebuffer(r)):(e.framebuffer.saveCurrentBindingsAndBuffers(),e.framebuffer.bind())}s.drawBuffers([s.COLOR_ATTACHMENT0]),s.clearBufferfv(s.COLOR,0,[0,0,0,0]),s.clearBufferfv(s.DEPTH,0,[1]),s.colorMask(!1,!1,!1,!1),a.getOpaqueActorCount()>0&&(a.setCurrentOperation("opaqueZBufferPass"),n.traverse(a)),s.colorMask(!0,!0,!0,!0),s.drawBuffers([s.COLOR_ATTACHMENT0,s.COLOR_ATTACHMENT1]),s.viewport(0,0,i[0],i[1]),s.scissor(0,0,i[0],i[1]),s.clearBufferfv(s.COLOR,0,[0,0,0,1]),s.clearBufferfv(s.COLOR,1,[0,0,0,0]),s.enable(s.DEPTH_TEST),s.enable(s.BLEND),s.blendFuncSeparate(s.ONE,s.ONE,s.ZERO,s.ONE_MINUS_SRC_ALPHA),t.setCurrentOperation("translucentPass"),n.traverse(t),s.drawBuffers([s.NONE]),e.framebuffer.restorePreviousBindingsAndBuffers(),e.copyShader===null?t.createCopyShader(r):r.getShaderCache().readyShaderProgram(e.copyShader),e.copyVAO||(e.copyVAO=Ui.newInstance(),e.copyVAO.setOpenGLRenderWindow(r)),e.copyVAO.bind(),e.VBOBuildTime.getMTime()<t.getMTime()&&t.createVBO(r),s.blendFuncSeparate(s.SRC_ALPHA,s.ONE_MINUS_SRC_ALPHA,s.ONE,s.ONE_MINUS_SRC_ALPHA),s.depthMask(!1),s.depthFunc(s.ALWAYS),s.viewport(0,0,i[0],i[1]),s.scissor(0,0,i[0],i[1]),e.translucentRGBATexture.activate(),e.copyShader.setUniformi("translucentRGBATexture",e.translucentRGBATexture.getTextureUnit()),e.translucentRTexture.activate(),e.copyShader.setUniformi("translucentRTexture",e.translucentRTexture.getTextureUnit()),s.drawArrays(s.TRIANGLES,0,e.tris.getCABO().getElementCount()),s.depthMask(!0),s.depthFunc(s.LEQUAL),e.translucentRGBATexture.deactivate(),e.translucentRTexture.deactivate();const o=n.getTiledSizeAndOrigin();s.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),s.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize)},t.getShaderReplacement=()=>e._supported?Dx:null,t.releaseGraphicsResources=r=>{e.framebuffer&&(e.framebuffer.releaseGraphicsResources(r),e.framebuffer=null),e.translucentRGBATexture&&(e.translucentRGBATexture.releaseGraphicsResources(r),e.translucentRGBATexture=null),e.translucentRTexture&&(e.translucentRTexture.releaseGraphicsResources(r),e.translucentRTexture=null),e.translucentZTexture&&(e.translucentZTexture.releaseGraphicsResources(r),e.translucentZTexture=null),e.copyVAO&&(e.copyVAO.releaseGraphicsResources(r),e.copyVAO=null),e.copyShader&&(e.copyShader.releaseGraphicsResources(r),e.copyShader=null),e.tris&&(e.tris.releaseGraphicsResources(r),e.tris=null),t.modified()}}const Fx={framebuffer:null,copyShader:null,tris:null};function gg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Fx,r),ds.extend(t,e,r),e.VBOBuildTime={},y.obj(e.VBOBuildTime,{mtime:0}),e.tris=ft.newInstance(),y.get(t,e,["framebuffer"]),Lx(t,e)}const kx=y.newInstance(gg,"vtkOpenGLOrderIndependentTranslucentPass");var Nx={newInstance:kx,extend:gg};function _x(t,e){e.classHierarchy.push("vtkForwardPass"),t.traverse=function(r){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:null;if(e.deleted)return;e._currentParent=n,t.setCurrentOperation("buildPass"),r.traverse(t);const a=r.getRenderable().getNumberOfLayers(),i=r.getRenderable().getRenderersByReference();for(let s=0;s<a;s++)for(let o=0;o<i.length;o++){const c=i[o],u=r.getViewNodeFor(c);if(c.getDraw()&&c.getLayer()===s){if(e.opaqueActorCount=0,e.translucentActorCount=0,e.volumeCount=0,e.overlayActorCount=0,t.setCurrentOperation("queryPass"),u.traverse(t),(e.opaqueActorCount>0||e.translucentActorCount>0)&&e.volumeCount>0||e.depthRequested){const g=r.getFramebufferSize();e.framebuffer===null&&(e.framebuffer=Ma.newInstance()),e.framebuffer.setOpenGLRenderWindow(r),e.framebuffer.saveCurrentBindingsAndBuffers();const f=e.framebuffer.getSize();(f===null||f[0]!==g[0]||f[1]!==g[1])&&(e.framebuffer.create(g[0],g[1]),e.framebuffer.populateFramebuffer()),e.framebuffer.bind(),t.setCurrentOperation("zBufferPass"),u.traverse(t),e.framebuffer.restorePreviousBindingsAndBuffers(),e.depthRequested=!1}t.setCurrentOperation("cameraPass"),u.traverse(t),e.opaqueActorCount>0&&(t.setCurrentOperation("opaquePass"),u.traverse(t)),e.translucentActorCount>0&&(e.translucentPass||(e.translucentPass=Nx.newInstance()),e.translucentPass.traverse(r,u,t)),e.volumeCount>0&&(t.setCurrentOperation("volumePass"),u.traverse(t)),e.overlayActorCount>0&&(t.setCurrentOperation("overlayPass"),u.traverse(t))}}},t.getZBufferTexture=()=>e.framebuffer?e.framebuffer.getColorTexture():null,t.requestDepth=()=>{e.depthRequested=!0},t.incrementOpaqueActorCount=()=>e.opaqueActorCount++,t.incrementTranslucentActorCount=()=>e.translucentActorCount++,t.incrementVolumeCount=()=>e.volumeCount++,t.incrementOverlayActorCount=()=>e.overlayActorCount++}const Gx={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function lg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Gx,r),ds.extend(t,e,r),y.get(t,e,["framebuffer","opaqueActorCount","translucentActorCount","volumeCount"]),_x(t,e)}const Ux=y.newInstance(lg,"vtkForwardPass");var Bx={newInstance:Ux,extend:lg};const Wx=["lastShaderProgramBound","context","_openGLRenderWindow"];function $x(t,e){e.classHierarchy.push("vtkShaderCache"),t.replaceShaderValues=(r,n,a)=>{let i=n;a.length>0&&(i=V.substitute(i,"VSOut","GSOut").result);const s=e._openGLRenderWindow.getWebgl2();let o=`
`,c=`#version 100
`;s?c=`#version 300 es
#define attribute in
#define textureCube texture
#define texture2D texture
#define textureCubeLod textureLod
#define texture2DLod textureLod
`:(e.context.getExtension("OES_standard_derivatives"),e.context.getExtension("EXT_frag_depth")&&(o=`#extension GL_EXT_frag_depth : enable
`),e.context.getExtension("EXT_shader_texture_lod")&&(o+=`#extension GL_EXT_shader_texture_lod : enable
#define textureCubeLod textureCubeLodEXT
#define texture2DLod texture2DLodEXT`)),i=V.substitute(i,"//VTK::System::Dec",[`${c}
`,s?"":`#extension GL_OES_standard_derivatives : enable
`,o,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;let u=V.substitute(r,"//VTK::System::Dec",[`${c}
`,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;if(s){u=V.substitute(u,"varying","out").result,i=V.substitute(i,"varying","in").result;let f="",l=0;for(;i.includes(`gl_FragData[${l}]`);)i=V.substitute(i,`gl_FragData\\[${l}\\]`,`fragOutput${l}`).result,f+=`layout(location = ${l}) out vec4 fragOutput${l};
`,l++;i=V.substitute(i,"//VTK::Output::Dec",f).result}const g=V.substitute(a,"//VTK::System::Dec",c).result;return{VSSource:u,FSSource:i,GSSource:g}},t.readyShaderProgramArray=(r,n,a)=>{const i=t.replaceShaderValues(r,n,a),s=t.getShaderProgram(i.VSSource,i.FSSource,i.GSSource);return t.readyShaderProgram(s)},t.readyShaderProgram=r=>!r||!r.getCompiled()&&!r.compileShader()||!t.bindShaderProgram(r)?null:r,t.getShaderProgram=(r,n,a)=>{const i=`${r}${n}${a}`,s=Ul.hash(i);if(!(s in e.shaderPrograms)){const o=V.newInstance();return o.setContext(e.context),o.getVertexShader().setSource(r),o.getFragmentShader().setSource(n),a&&o.getGeometryShader().setSource(a),o.setMd5Hash(s),e.shaderPrograms[s]=o,o}return e.shaderPrograms[s]},t.releaseGraphicsResources=r=>{t.releaseCurrentShaderProgram(),Object.keys(e.shaderPrograms).map(n=>e.shaderPrograms[n]).forEach(n=>n.cleanup()),e.shaderPrograms={}},t.releaseCurrentShaderProgram=()=>{e.lastShaderProgramBound&&(e.lastShaderProgramBound.cleanup(),e.lastShaderProgramBound=null)},t.bindShaderProgram=r=>(e.lastShaderProgramBound===r||(e.lastShaderProgramBound&&e.lastShaderProgramBound.release(),r.bind(),e.lastShaderProgramBound=r),1)}const zx={lastShaderProgramBound:null,shaderPrograms:null,context:null};function pg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,zx,r),e.shaderPrograms={},y.obj(t,e),y.setGet(t,e,Wx),y.moveToProtected(t,e,["openGLRenderWindow"]),$x(t,e)}const Hx=y.newInstance(pg,"vtkShaderCache");var jx={newInstance:Hx,extend:pg};const{vtkErrorMacro:bx}=y;function Kx(t,e){e.classHierarchy.push("vtkOpenGLTextureUnitManager"),t.deleteTable=()=>{for(let r=0;r<e.numberOfTextureUnits;++r)e.textureUnits[r]===!0&&bx("some texture units  were not properly released");e.textureUnits=[],e.numberOfTextureUnits=0},t.setContext=r=>{if(e.context!==r){if(e.context!==0&&t.deleteTable(),e.context=r,e.context){e.numberOfTextureUnits=r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS);for(let n=0;n<e.numberOfTextureUnits;++n)e.textureUnits[n]=!1}t.modified()}},t.allocate=()=>{for(let r=0;r<e.numberOfTextureUnits;r++)if(!t.isAllocated(r))return e.textureUnits[r]=!0,r;return-1},t.allocateUnit=r=>t.isAllocated(r)?-1:(e.textureUnits[r]=!0,r),t.isAllocated=r=>e.textureUnits[r],t.free=r=>{e.textureUnits[r]=!1},t.freeAll=()=>{for(let r=0;r<e.numberOfTextureUnits;++r)e.textureUnits[r]=!1}}const Xx={context:null,numberOfTextureUnits:0,textureUnits:0};function hg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Xx,r),y.obj(t,e),e.textureUnits=[],y.get(t,e,["numberOfTextureUnits"]),y.setGet(t,e,["context"]),Kx(t,e)}const Ax=y.newInstance(hg,"vtkOpenGLTextureUnitManager");var Yx={newInstance:Ax,extend:hg};function qx(t,e){e.classHierarchy.push("vtkRenderWindowViewNode"),t.getViewNodeFactory=()=>null,t.getAspectRatio=()=>e.size[0]/e.size[1],t.getAspectRatioForRenderer=r=>{const n=r.getViewportByReference();return e.size[0]*(n[2]-n[0])/((n[3]-n[1])*e.size[1])},t.isInViewport=(r,n,a)=>{const i=a.getViewportByReference(),s=t.getFramebufferSize();return i[0]*s[0]<=r&&i[2]*s[0]>=r&&i[1]*s[1]<=n&&i[3]*s[1]>=n},t.getViewportSize=r=>{const n=r.getViewportByReference(),a=t.getFramebufferSize();return[(n[2]-n[0])*a[0],(n[3]-n[1])*a[1]]},t.getViewportCenter=r=>{const n=t.getViewportSize(r);return[n[0]*.5,n[1]*.5]},t.displayToNormalizedDisplay=(r,n,a)=>{const i=t.getFramebufferSize();return[r/i[0],n/i[1],a]},t.normalizedDisplayToDisplay=(r,n,a)=>{const i=t.getFramebufferSize();return[r*i[0],n*i[1],a]},t.worldToView=(r,n,a,i)=>i.worldToView(r,n,a),t.viewToWorld=(r,n,a,i)=>i.viewToWorld(r,n,a),t.worldToDisplay=(r,n,a,i)=>{const s=i.worldToView(r,n,a),o=t.getViewportSize(i),c=i.viewToProjection(s[0],s[1],s[2],o[0]/o[1]),u=i.projectionToNormalizedDisplay(c[0],c[1],c[2]);return t.normalizedDisplayToDisplay(u[0],u[1],u[2])},t.displayToWorld=(r,n,a,i)=>{const s=t.displayToNormalizedDisplay(r,n,a),o=i.normalizedDisplayToProjection(s[0],s[1],s[2]),c=t.getViewportSize(i),u=i.projectionToView(o[0],o[1],o[2],c[0]/c[1]);return i.viewToWorld(u[0],u[1],u[2])},t.normalizedDisplayToViewport=(r,n,a,i)=>{let s=i.getViewportByReference();s=t.normalizedDisplayToDisplay(s[0],s[1],0);const o=t.normalizedDisplayToDisplay(r,n,a);return[o[0]-s[0]-.5,o[1]-s[1]-.5,a]},t.viewportToNormalizedViewport=(r,n,a,i)=>{const s=t.getViewportSize(i);return s&&s[0]!==0&&s[1]!==0?[r/(s[0]-1),n/(s[1]-1),a]:[r,n,a]},t.normalizedViewportToViewport=(r,n,a,i)=>{const s=t.getViewportSize(i);return[r*(s[0]-1),n*(s[1]-1),a]},t.displayToLocalDisplay=(r,n,a)=>{const i=t.getFramebufferSize();return[r,i[1]-n-1,a]},t.viewportToNormalizedDisplay=(r,n,a,i)=>{let s=i.getViewportByReference();s=t.normalizedDisplayToDisplay(s[0],s[1],0);const o=r+s[0]+.5,c=n+s[1]+.5;return t.displayToNormalizedDisplay(o,c,a)},t.getComputedDevicePixelRatio=()=>e.size[0]/t.getContainerSize()[0],t.getContainerSize=()=>{y.vtkErrorMacro("not implemented")},t.getPixelData=(r,n,a,i)=>{y.vtkErrorMacro("not implemented")},t.createSelector=()=>{y.vtkErrorMacro("not implemented")}}const Zx={size:void 0,selector:void 0};function dg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Zx,r),e.size||(e.size=[300,300]),y.getArray(t,e,["size"],2),y.get(t,e,["selector"]),De.extend(t,e,r),qx(t,e)}const Px=y.newInstance(dg,"vtkRenderWindowViewNode");var Jx={newInstance:Px,extend:dg};const Qx="__getUnderlyingContext";function Ix(){const t=new Map,e={apply(a,i,s){return t.has(s[0])?t.get(s[0]):a.apply(i,s)}};function r(a){return{apply(i,s,o){return t.set(a,o[0]),i.apply(s,o)}}}const n=Object.create(null);return n.getParameter=(a,i,s,o)=>new Proxy(o.bind(a),e),n.depthMask=(a,i,s,o)=>new Proxy(o.bind(a),r(a.DEPTH_WRITEMASK)),{get(a,i,s){if(i===Qx)return()=>a;let o=Reflect.get(a,i,a);o instanceof Function&&(o=o.bind(a));const c=n[i];return c?c(a,i,s,o):o}}}const{vtkDebugMacro:ho,vtkErrorMacro:To}=y,ew={position:"absolute",top:0,left:0,width:"100%",height:"100%"},tw=["activateTexture","deactivateTexture","disableCullFace","enableCullFace","get3DContext","getActiveFramebuffer","getContext","getDefaultTextureByteSize","getDefaultTextureInternalFormat","getDefaultToWebgl2","getGLInformations","getGraphicsMemoryInfo","getGraphicsResourceForObject","getHardwareMaximumLineWidth","getPixelData","getShaderCache","getTextureUnitForTexture","getTextureUnitManager","getWebgl2","makeCurrent","releaseGraphicsResources","registerGraphicsResourceUser","unregisterGraphicsResourceUser","restoreContext","setActiveFramebuffer","setContext","setDefaultToWebgl2","setGraphicsResourceForObject"];function Le(t,e,r){const n=t.createFramebuffer(),a=t.createTexture();t.bindTexture(t.TEXTURE_2D,a),t.texImage2D(t.TEXTURE_2D,0,e,2,2,0,e,r,null),t.bindFramebuffer(t.FRAMEBUFFER,n),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,a,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER);return t.bindFramebuffer(t.FRAMEBUFFER,null),t.bindTexture(t.TEXTURE_2D,null),i===t.FRAMEBUFFER_COMPLETE}let ga=0;const ma=[];function nw(){ga++,ma.forEach(t=>t(ga))}function rw(){ga--,ma.forEach(t=>t(ga))}function aw(t){ma.push(t)}function iw(t){return ma.pop()}function vo(t){t.preventDefault()}function sw(t,e){e.classHierarchy.push("vtkOpenGLRenderWindow");let r;function n(){return r||(r=Ix()),r}t.getViewNodeFactory=()=>e.myFactory,e.canvas.addEventListener("webglcontextlost",vo,!1),e.canvas.addEventListener("webglcontextrestored",t.restoreContext,!1);const a=[0,0];function i(){e.renderable&&(e.size[0]!==a[0]||e.size[1]!==a[1])&&(a[0]=e.size[0],a[1]=e.size[1],e.canvas.setAttribute("width",e.size[0]),e.canvas.setAttribute("height",e.size[1])),e.viewStream&&e.viewStream.setSize(e.size[0],e.size[1]),e.canvas.style.display=e.useOffScreen?"none":"block",e.el&&(e.el.style.cursor=e.cursorVisibility?e.cursor:"none"),e.containerSize=null}t.onModified(i),t.buildPass=f=>{if(f){if(!e.renderable)return;t.prepareNodes(),t.addMissingNodes(e.renderable.getRenderersByReference()),t.addMissingNodes(e.renderable.getChildRenderWindowsByReference()),t.removeUnusedNodes(),t.initialize(),e.children.forEach(l=>{var p;(p=l.setOpenGLRenderWindow)==null||p.call(l,t)})}},t.initialize=()=>{if(!e.initialized){if(e.rootOpenGLRenderWindow=t.getLastAncestorOfType("vtkOpenGLRenderWindow"),e.rootOpenGLRenderWindow)e.context2D=t.get2DContext();else{e.context=t.get3DContext(),t.resizeFromChildRenderWindows(),e.context&&nw(),e.textureUnitManager=Yx.newInstance(),e.textureUnitManager.setContext(e.context),e.shaderCache.setContext(e.context);const f=e.context;f.blendFuncSeparate(f.SRC_ALPHA,f.ONE_MINUS_SRC_ALPHA,f.ONE,f.ONE_MINUS_SRC_ALPHA),f.depthFunc(f.LEQUAL),f.enable(f.BLEND)}e.initialized=!0}},t.makeCurrent=()=>{e.context.makeCurrent()},t.setContainer=f=>{e.el&&e.el!==f&&(e.canvas.parentNode!==e.el&&To("Error: canvas parent node does not match container"),e.el.removeChild(e.canvas),e.el.contains(e.bgImage)&&e.el.removeChild(e.bgImage)),e.el!==f&&(e.el=f,e.el&&(e.el.appendChild(e.canvas),e.useBackgroundImage&&e.el.appendChild(e.bgImage)),t.modified())},t.getContainer=()=>e.el,t.getContainerSize=()=>{if(!e.containerSize&&e.el){const{width:f,height:l}=e.el.getBoundingClientRect();e.containerSize=[f,l]}return e.containerSize||e.size},t.getFramebufferSize=()=>{var l;return((l=e.activeFramebuffer)==null?void 0:l.getSize())||e.size},t.getPixelData=(f,l,p,d)=>{const h=new Uint8Array((p-f+1)*(d-l+1)*4);return e.context.readPixels(f,l,p-f+1,d-l+1,e.context.RGBA,e.context.UNSIGNED_BYTE,h),h},t.get3DContext=function(){let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:"high-performance"},l=null;const p=typeof WebGL2RenderingContext<"u";return e.webgl2=!1,e.defaultToWebgl2&&p&&(l=e.canvas.getContext("webgl2",f),l&&(e.webgl2=!0,ho("using webgl2"))),l||(ho("using webgl1"),l=e.canvas.getContext("webgl",f)||e.canvas.getContext("experimental-webgl",f)),new Proxy(l,n())},t.get2DContext=function(){let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};return e.canvas.getContext("2d",f)},t.restoreContext=()=>{const f=ds.newInstance();f.setCurrentOperation("Release"),f.traverse(t,null)},t.activateTexture=f=>{const l=e._textureResourceIds.get(f);if(l!==void 0){e.context.activeTexture(e.context.TEXTURE0+l);return}const p=t.getTextureUnitManager().allocate();if(p<0){To("Hardware does not support the number of textures defined.");return}e._textureResourceIds.set(f,p),e.context.activeTexture(e.context.TEXTURE0+p)},t.deactivateTexture=f=>{const l=e._textureResourceIds.get(f);l!==void 0&&(t.getTextureUnitManager().free(l),e._textureResourceIds.delete(f))},t.getTextureUnitForTexture=f=>{const l=e._textureResourceIds.get(f);return l!==void 0?l:-1},t.getDefaultTextureByteSize=function(f){let l=arguments.length>1&&arguments[1]!==void 0?arguments[1]:null,p=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1;if(e.webgl2)switch(f){case J.CHAR:case J.SIGNED_CHAR:case J.UNSIGNED_CHAR:return 1;case l:case p:case J.UNSIGNED_SHORT:case J.SHORT:case J.VOID:return 2;default:return 4}return 1},t.getDefaultTextureInternalFormat=function(f,l){let p=arguments.length>2&&arguments[2]!==void 0?arguments[2]:null,d=arguments.length>3&&arguments[3]!==void 0?arguments[3]:!1;if(e.webgl2)switch(f){case J.UNSIGNED_CHAR:switch(l){case 1:return e.context.R8;case 2:return e.context.RG8;case 3:return e.context.RGB8;case 4:default:return e.context.RGBA8}case(p&&!d&&J.UNSIGNED_SHORT):switch(l){case 1:return p.R16_EXT;case 2:return p.RG16_EXT;case 3:return p.RGB16_EXT;case 4:default:return p.RGBA16_EXT}case(p&&!d&&J.SHORT):switch(l){case 1:return p.R16_SNORM_EXT;case 2:return p.RG16_SNORM_EXT;case 3:return p.RGB16_SNORM_EXT;case 4:default:return p.RGBA16_SNORM_EXT}case J.UNSIGNED_SHORT:case J.SHORT:case J.FLOAT:default:switch(l){case 1:return d?e.context.R16F:e.context.R32F;case 2:return d?e.context.RG16F:e.context.RG32F;case 3:return d?e.context.RGB16F:e.context.RGB32F;case 4:default:return d?e.context.RGBA16F:e.context.RGBA32F}}switch(l){case 1:return e.context.LUMINANCE;case 2:return e.context.LUMINANCE_ALPHA;case 3:return e.context.RGB;case 4:default:return e.context.RGBA}},t.setBackgroundImage=f=>{e.bgImage.src=f.src},t.setUseBackgroundImage=f=>{e.useBackgroundImage=f,e.useBackgroundImage&&!e.el.contains(e.bgImage)?e.el.appendChild(e.bgImage):!e.useBackgroundImage&&e.el.contains(e.bgImage)&&e.el.removeChild(e.bgImage)};function s(){let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:e.imageFormat;const l=document.createElement("canvas"),p=l.getContext("2d");l.width=e.canvas.width,l.height=e.canvas.height,p.drawImage(e.canvas,0,0);const d=e.canvas.getBoundingClientRect();e.renderable.getRenderers().forEach(C=>{C.getViewProps().forEach(x=>{if(x.getContainer){const O=x.getContainer().getElementsByTagName("canvas");for(let w=0;w<O.length;w++){const m=O[w],E=m.getBoundingClientRect(),M=E.x-d.x,D=E.y-d.y;p.drawImage(m,M,D)}}})});const v=l.toDataURL(f);l.remove(),t.invokeImageReady(v)}t.captureNextImage=function(){let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"image/png",{resetCamera:l=!1,size:p=null,scale:d=1}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(e.deleted)return null;e.imageFormat=f;const h=e.notifyStartCaptureImage;return e.notifyStartCaptureImage=!0,e._screenshot={size:p||d!==1?p||e.size.map(T=>T*d):null},new Promise((T,v)=>{const C=t.onImageReady(S=>{var x;if(e._screenshot.size===null)e.notifyStartCaptureImage=h,C.unsubscribe(),e._screenshot.placeHolder&&(e.size=e._screenshot.originalSize,t.modified(),e._screenshot.cameras&&e._screenshot.cameras.forEach(R=>{let{restoreParamsFn:O,arg:w}=R;return O(w)}),t.traverseAllPasses(),e.el.removeChild(e._screenshot.placeHolder),e._screenshot.placeHolder.remove(),e._screenshot=null),T(S);else{const R=document.createElement("img");if(R.style=ew,R.src=S,e._screenshot.placeHolder=e.el.appendChild(R),e.canvas.style.display="none",e._screenshot.originalSize=e.size,e.size=e._screenshot.size,(x=e.rootOpenGLRenderWindow)==null||x.resizeFromChildRenderWindows(),e._screenshot.size=null,t.modified(),l){const O=l!==!0;e._screenshot.cameras=e.renderable.getRenderers().map(w=>{const m=w.getActiveCamera(),E=m.get("focalPoint","position","parallelScale");return{resetCameraArgs:O?{renderer:w}:void 0,resetCameraFn:O?l:w.resetCamera,restoreParamsFn:m.set,arg:JSON.parse(JSON.stringify(E))}}),e._screenshot.cameras.forEach(w=>{let{resetCameraFn:m,resetCameraArgs:E}=w;return m(E)})}t.traverseAllPasses()}})})};let o;t.getHardwareMaximumLineWidth=()=>{if(o!=null)return o;const f=t.get3DContext(),l=f.getParameter(f.ALIASED_LINE_WIDTH_RANGE);return o=l[1],l[1]},t.getGLInformations=()=>{if(e._glInformation)return e._glInformation;const f=t.get3DContext(),l=f.getExtension("OES_texture_float"),p=f.getExtension("OES_texture_half_float"),d=f.getExtension("WEBGL_debug_renderer_info"),h=f.getExtension("WEBGL_draw_buffers"),T=f.getExtension("EXT_texture_filter_anisotropic")||f.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),v=[["Max Vertex Attributes","MAX_VERTEX_ATTRIBS",f.getParameter(f.MAX_VERTEX_ATTRIBS)],["Max Varying Vectors","MAX_VARYING_VECTORS",f.getParameter(f.MAX_VARYING_VECTORS)],["Max Vertex Uniform Vectors","MAX_VERTEX_UNIFORM_VECTORS",f.getParameter(f.MAX_VERTEX_UNIFORM_VECTORS)],["Max Fragment Uniform Vectors","MAX_FRAGMENT_UNIFORM_VECTORS",f.getParameter(f.MAX_FRAGMENT_UNIFORM_VECTORS)],["Max Fragment Texture Image Units","MAX_TEXTURE_IMAGE_UNITS",f.getParameter(f.MAX_TEXTURE_IMAGE_UNITS)],["Max Vertex Texture Image Units","MAX_VERTEX_TEXTURE_IMAGE_UNITS",f.getParameter(f.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],["Max Combined Texture Image Units","MAX_COMBINED_TEXTURE_IMAGE_UNITS",f.getParameter(f.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],["Max 2D Texture Size","MAX_TEXTURE_SIZE",f.getParameter(f.MAX_TEXTURE_SIZE)],["Max Cube Texture Size","MAX_CUBE_MAP_TEXTURE_SIZE",f.getParameter(f.MAX_CUBE_MAP_TEXTURE_SIZE)],["Max Texture Anisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT",T&&f.getParameter(T.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],["Point Size Range","ALIASED_POINT_SIZE_RANGE",f.getParameter(f.ALIASED_POINT_SIZE_RANGE).join(" - ")],["Line Width Range","ALIASED_LINE_WIDTH_RANGE",f.getParameter(f.ALIASED_LINE_WIDTH_RANGE).join(" - ")],["Max Viewport Dimensions","MAX_VIEWPORT_DIMS",f.getParameter(f.MAX_VIEWPORT_DIMS).join(" - ")],["Max Renderbuffer Size","MAX_RENDERBUFFER_SIZE",f.getParameter(f.MAX_RENDERBUFFER_SIZE)],["Framebuffer Red Bits","RED_BITS",f.getParameter(f.RED_BITS)],["Framebuffer Green Bits","GREEN_BITS",f.getParameter(f.GREEN_BITS)],["Framebuffer Blue Bits","BLUE_BITS",f.getParameter(f.BLUE_BITS)],["Framebuffer Alpha Bits","ALPHA_BITS",f.getParameter(f.ALPHA_BITS)],["Framebuffer Depth Bits","DEPTH_BITS",f.getParameter(f.DEPTH_BITS)],["Framebuffer Stencil Bits","STENCIL_BITS",f.getParameter(f.STENCIL_BITS)],["Framebuffer Subpixel Bits","SUBPIXEL_BITS",f.getParameter(f.SUBPIXEL_BITS)],["MSAA Samples","SAMPLES",f.getParameter(f.SAMPLES)],["MSAA Sample Buffers","SAMPLE_BUFFERS",f.getParameter(f.SAMPLE_BUFFERS)],["Supported Formats for UByte Render Targets     ","UNSIGNED_BYTE RENDER TARGET FORMATS",[l&&Le(f,f.RGBA,f.UNSIGNED_BYTE)?"RGBA":"",l&&Le(f,f.RGB,f.UNSIGNED_BYTE)?"RGB":"",l&&Le(f,f.LUMINANCE,f.UNSIGNED_BYTE)?"LUMINANCE":"",l&&Le(f,f.ALPHA,f.UNSIGNED_BYTE)?"ALPHA":"",l&&Le(f,f.LUMINANCE_ALPHA,f.UNSIGNED_BYTE)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Half Float Render Targets","HALF FLOAT RENDER TARGET FORMATS",[p&&Le(f,f.RGBA,p.HALF_FLOAT_OES)?"RGBA":"",p&&Le(f,f.RGB,p.HALF_FLOAT_OES)?"RGB":"",p&&Le(f,f.LUMINANCE,p.HALF_FLOAT_OES)?"LUMINANCE":"",p&&Le(f,f.ALPHA,p.HALF_FLOAT_OES)?"ALPHA":"",p&&Le(f,f.LUMINANCE_ALPHA,p.HALF_FLOAT_OES)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Full Float Render Targets","FLOAT RENDER TARGET FORMATS",[l&&Le(f,f.RGBA,f.FLOAT)?"RGBA":"",l&&Le(f,f.RGB,f.FLOAT)?"RGB":"",l&&Le(f,f.LUMINANCE,f.FLOAT)?"LUMINANCE":"",l&&Le(f,f.ALPHA,f.FLOAT)?"ALPHA":"",l&&Le(f,f.LUMINANCE_ALPHA,f.FLOAT)?"LUMINANCE_ALPHA":""].join(" ")],["Max Multiple Render Targets Buffers","MAX_DRAW_BUFFERS_WEBGL",h?f.getParameter(h.MAX_DRAW_BUFFERS_WEBGL):0],["High Float Precision in Vertex Shader","HIGH_FLOAT VERTEX_SHADER",[f.getShaderPrecisionFormat(f.VERTEX_SHADER,f.HIGH_FLOAT).precision," (-2<sup>",f.getShaderPrecisionFormat(f.VERTEX_SHADER,f.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",f.getShaderPrecisionFormat(f.VERTEX_SHADER,f.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Vertex Shader","MEDIUM_FLOAT VERTEX_SHADER",[f.getShaderPrecisionFormat(f.VERTEX_SHADER,f.MEDIUM_FLOAT).precision," (-2<sup>",f.getShaderPrecisionFormat(f.VERTEX_SHADER,f.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",f.getShaderPrecisionFormat(f.VERTEX_SHADER,f.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Vertex Shader","LOW_FLOAT VERTEX_SHADER",[f.getShaderPrecisionFormat(f.VERTEX_SHADER,f.LOW_FLOAT).precision," (-2<sup>",f.getShaderPrecisionFormat(f.VERTEX_SHADER,f.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",f.getShaderPrecisionFormat(f.VERTEX_SHADER,f.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Float Precision in Fragment Shader","HIGH_FLOAT FRAGMENT_SHADER",[f.getShaderPrecisionFormat(f.FRAGMENT_SHADER,f.HIGH_FLOAT).precision," (-2<sup>",f.getShaderPrecisionFormat(f.FRAGMENT_SHADER,f.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",f.getShaderPrecisionFormat(f.FRAGMENT_SHADER,f.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Fragment Shader","MEDIUM_FLOAT FRAGMENT_SHADER",[f.getShaderPrecisionFormat(f.FRAGMENT_SHADER,f.MEDIUM_FLOAT).precision," (-2<sup>",f.getShaderPrecisionFormat(f.FRAGMENT_SHADER,f.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",f.getShaderPrecisionFormat(f.FRAGMENT_SHADER,f.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Fragment Shader","LOW_FLOAT FRAGMENT_SHADER",[f.getShaderPrecisionFormat(f.FRAGMENT_SHADER,f.LOW_FLOAT).precision," (-2<sup>",f.getShaderPrecisionFormat(f.FRAGMENT_SHADER,f.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",f.getShaderPrecisionFormat(f.FRAGMENT_SHADER,f.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Int Precision in Vertex Shader","HIGH_INT VERTEX_SHADER",[f.getShaderPrecisionFormat(f.VERTEX_SHADER,f.HIGH_INT).precision," (-2<sup>",f.getShaderPrecisionFormat(f.VERTEX_SHADER,f.HIGH_INT).rangeMin,"</sup> - 2<sup>",f.getShaderPrecisionFormat(f.VERTEX_SHADER,f.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Vertex Shader","MEDIUM_INT VERTEX_SHADER",[f.getShaderPrecisionFormat(f.VERTEX_SHADER,f.MEDIUM_INT).precision," (-2<sup>",f.getShaderPrecisionFormat(f.VERTEX_SHADER,f.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",f.getShaderPrecisionFormat(f.VERTEX_SHADER,f.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Vertex Shader","LOW_INT VERTEX_SHADER",[f.getShaderPrecisionFormat(f.VERTEX_SHADER,f.LOW_INT).precision," (-2<sup>",f.getShaderPrecisionFormat(f.VERTEX_SHADER,f.LOW_INT).rangeMin,"</sup> - 2<sup>",f.getShaderPrecisionFormat(f.VERTEX_SHADER,f.LOW_INT).rangeMax,"</sup>)"].join("")],["High Int Precision in Fragment Shader","HIGH_INT FRAGMENT_SHADER",[f.getShaderPrecisionFormat(f.FRAGMENT_SHADER,f.HIGH_INT).precision," (-2<sup>",f.getShaderPrecisionFormat(f.FRAGMENT_SHADER,f.HIGH_INT).rangeMin,"</sup> - 2<sup>",f.getShaderPrecisionFormat(f.FRAGMENT_SHADER,f.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Fragment Shader","MEDIUM_INT FRAGMENT_SHADER",[f.getShaderPrecisionFormat(f.FRAGMENT_SHADER,f.MEDIUM_INT).precision," (-2<sup>",f.getShaderPrecisionFormat(f.FRAGMENT_SHADER,f.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",f.getShaderPrecisionFormat(f.FRAGMENT_SHADER,f.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Fragment Shader","LOW_INT FRAGMENT_SHADER",[f.getShaderPrecisionFormat(f.FRAGMENT_SHADER,f.LOW_INT).precision," (-2<sup>",f.getShaderPrecisionFormat(f.FRAGMENT_SHADER,f.LOW_INT).rangeMin,"</sup> - 2<sup>",f.getShaderPrecisionFormat(f.FRAGMENT_SHADER,f.LOW_INT).rangeMax,"</sup>)"].join("")],["Supported Extensions","EXTENSIONS",f.getSupportedExtensions().join("<br/>					    ")],["WebGL Renderer","RENDERER",f.getParameter(f.RENDERER)],["WebGL Vendor","VENDOR",f.getParameter(f.VENDOR)],["WebGL Version","VERSION",f.getParameter(f.VERSION)],["Shading Language Version","SHADING_LANGUAGE_VERSION",f.getParameter(f.SHADING_LANGUAGE_VERSION)],["Unmasked Renderer","UNMASKED_RENDERER",d&&f.getParameter(d.UNMASKED_RENDERER_WEBGL)],["Unmasked Vendor","UNMASKED_VENDOR",d&&f.getParameter(d.UNMASKED_VENDOR_WEBGL)],["WebGL Version","WEBGL_VERSION",e.webgl2?2:1]],C={};for(;v.length;){const[S,x,R]=v.pop();x&&(C[x]={label:S,value:R})}return e._glInformation=C,C},t.traverseAllPasses=()=>{var l;if(e.renderPasses)for(let p=0;p<e.renderPasses.length;++p)e.renderPasses[p].traverse(t,null);t.copyParentContent(),e.notifyStartCaptureImage&&s();const f=e.renderable.getChildRenderWindowsByReference();for(let p=0;p<f.length;++p)(l=t.getViewNodeFor(f[p]))==null||l.traverseAllPasses()},t.copyParentContent=()=>{const f=e.rootOpenGLRenderWindow;if(!f||!e.context2D||e.children.some(d=>{var h;return!!((h=d.getSelector)!=null&&h.call(d))}))return;const l=f.getCanvas(),p=e.canvas;e.context2D.drawImage(l,0,l.height-p.height,p.width,p.height,0,0,p.width,p.height)},t.resizeFromChildRenderWindows=()=>{var l;const f=e.renderable.getChildRenderWindowsByReference();if(f.length>0){const p=[0,0];for(let d=0;d<f.length;++d){const h=(l=t.getViewNodeFor(f[d]))==null?void 0:l.getSize();h&&(p[0]=h[0]>p[0]?h[0]:p[0],p[1]=h[1]>p[1]?h[1]:p[1])}t.setSize(...p)}},t.disableCullFace=()=>{e.cullFaceEnabled&&(e.context.disable(e.context.CULL_FACE),e.cullFaceEnabled=!1)},t.enableCullFace=()=>{e.cullFaceEnabled||(e.context.enable(e.context.CULL_FACE),e.cullFaceEnabled=!0)},t.setViewStream=f=>{if(e.viewStream===f)return!1;if(e.subscription&&(e.subscription.unsubscribe(),e.subscription=null),e.viewStream=f,e.viewStream){const l=e.renderable.getRenderers()[0];l.getBackgroundByReference()[3]=0,t.setUseBackgroundImage(!0),e.subscription=e.viewStream.onImageReady(p=>t.setBackgroundImage(p.image)),e.viewStream.setSize(e.size[0],e.size[1]),e.viewStream.invalidateCache(),e.viewStream.render(),t.modified()}return!0},t.createSelector=()=>{const f=os.newInstance();return f.setOpenGLRenderWindow(t),f};function c(){e.canvas.removeEventListener("webglcontextlost",vo),e.canvas.removeEventListener("webglcontextrestored",t.restoreContext)}t.delete=y.chain(()=>{e.context&&rw(),t.setContainer(),t.setViewStream()},c,t.delete),t.setActiveFramebuffer=f=>{e.activeFramebuffer=f};const u=t.setSize;t.setSize=(f,l)=>{const p=u(f,l);return p&&t.invokeWindowResizeEvent({width:f,height:l}),p},t.registerGraphicsResourceUser=(f,l)=>{e._graphicsResources.has(f)||t.setGraphicsResourceForObject(f,null,null);const p=e._graphicsResources.get(f);p==null||p.users.add(l)},t.unregisterGraphicsResourceUser=(f,l)=>{var d;const p=e._graphicsResources.get(f);p&&(p.users.delete(l),p.users.size||((d=p.oglObject)==null||d.releaseGraphicsResources(t),e._graphicsResources.delete(f)))},t.getGraphicsResourceForObject=f=>e._graphicsResources.get(f),t.setGraphicsResourceForObject=(f,l,p)=>{var h;if(!f)return;const d=e._graphicsResources.get(f);(h=d==null?void 0:d.oglObject)==null||h.releaseGraphicsResources(t),e._graphicsResources.set(f,{coreObject:f,oglObject:l,hash:p,users:(d==null?void 0:d.users)??new Set})},t.getGraphicsMemoryInfo=()=>{let f=0;return e._graphicsResources.forEach(l=>{let{oglObject:p}=l;f+=p.getAllocatedGPUMemoryInBytes()}),f},t.releaseGraphicsResources=()=>{e.shaderCache!==null&&e.shaderCache.releaseGraphicsResources(t),e._graphicsResources.forEach(f=>{let{oglObject:l}=f;l.releaseGraphicsResources(t)}),e._graphicsResources.clear(),e.textureUnitManager!==null&&e.textureUnitManager.freeAll(),e.renderable.getRenderersByReference().forEach(f=>{const l=t.getViewNodeFor(f);l==null||l.releaseGraphicsResources()})};const g={...t};tw.forEach(f=>{t[f]=function(){return e.rootOpenGLRenderWindow?e.rootOpenGLRenderWindow[f](...arguments):g[f](...arguments)}})}const ow={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,context2D:null,canvas:null,cursorVisibility:!0,cursor:"pointer",textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1};function Tg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,ow,r),Jx.extend(t,e,r),e.canvas||(e.canvas=document.createElement("canvas"),e.canvas.style.width="100%"),e.selector||(e.selector=os.newInstance(),e.selector.setOpenGLRenderWindow(t)),e.bgImage=new Image,e.bgImage.style.position="absolute",e.bgImage.style.left="0",e.bgImage.style.top="0",e.bgImage.style.width="100%",e.bgImage.style.height="100%",e.bgImage.style.zIndex="-1",e._textureResourceIds=new Map,e._graphicsResources=new Map,e._glInformation=null,e.myFactory=cp.newInstance(),e.shaderCache=jx.newInstance(),e.shaderCache.setOpenGLRenderWindow(t),e.renderPasses[0]=Bx.newInstance(),y.get(t,e,["shaderCache","textureUnitManager","webgl2","useBackgroundImage","activeFramebuffer","rootOpenGLRenderWindow"]),y.setGet(t,e,["initialized","context","context2D","canvas","renderPasses","notifyStartCaptureImage","defaultToWebgl2","cursor","useOffScreen"]),y.setGetArray(t,e,["size"],2),y.event(t,e,"imageReady"),y.event(t,e,"windowResizeEvent"),sw(t,e)}const Ts=y.newInstance(Tg,"vtkOpenGLRenderWindow");ng("WebGL",Ts);var mM={newInstance:Ts,extend:Tg,pushMonitorGLContextCount:aw,popMonitorGLContextCount:iw};Oe("vtkRenderWindow",Ts);function cw(t,e){e.classHierarchy.push("vtkMouseCameraTrackballRotateManipulator");const r=new Float64Array(3),n=new Float64Array(3),a=new Float64Array(3),i=new Float64Array(16),s=new Float64Array(3),o=new Float64Array(3),c=new Float64Array(3);t.onButtonDown=(u,g,f)=>{e.previousPosition=f},t.onMouseMove=(u,g,f)=>{if(!f)return;const l=g.getActiveCamera(),p=l.getPosition(),d=l.getFocalPoint();X(i);const{center:h,rotationFactor:T}=e;e.useFocalPointAsCenterOfRotation&&(h[0]=d[0],h[1]=d[1],h[2]=d[2]);const v=e.previousPosition.x-f.x,C=e.previousPosition.y-f.y,S=u.getView().getViewportSize(g),x=l.getViewUp();if(e.useWorldUpVec){const R=new Float64Array(3);Bl(R,e.worldUpVec),St(R,b(p,e.worldUpVec)/b(e.worldUpVec,e.worldUpVec)),Qe(h,R,R),ge(i,i,R),Fe(i,i,fe(360*v/S[0]*T),e.worldUpVec),R[0]=-R[0],R[1]=-R[1],R[2]=-R[2],ge(i,i,R),ge(i,i,h)}else ge(i,i,h),Fe(i,i,fe(360*v/S[0]*T),x);Te(l.getDirectionOfProjection(),x,s),Fe(i,i,fe(-360*C/S[1]*T),s),o[0]=-h[0],o[1]=-h[1],o[2]=-h[2],ge(i,i,o),q(r,p,i),q(n,d,i),c[0]=x[0]+p[0],c[1]=x[1]+p[1],c[2]=x[2]+p[2],q(a,c,i),l.setPosition(r[0],r[1],r[2]),l.setFocalPoint(n[0],n[1],n[2]),l.setViewUp(a[0]-r[0],a[1]-r[1],a[2]-r[2]),l.orthogonalizeViewUp(),g.resetCameraClippingRange(),u.getLightFollowCamera()&&g.updateLightsGeometryToFollowCamera(),e.previousPosition=f}}const uw={useWorldUpVec:!1,worldUpVec:[0,1,0],useFocalPointAsCenterOfRotation:!1};function vg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,uw,r),y.obj(t,e),Oa.extend(t,e,r),hs.extend(t,e,r),y.setGet(t,e,["useWorldUpVec"]),y.setGetArray(t,e,["worldUpVec"],3),y.setGet(t,e,["useFocalPointAsCenterOfRotation"]),cw(t,e)}const fw=y.newInstance(vg,"vtkMouseCameraTrackballRotateManipulator");var EM={newInstance:fw,extend:vg};const gw=1e-6;function lw(t,e){e.classHierarchy.push("vtkProp3D"),t.addPosition=n=>{e.position=e.position.map((a,i)=>a+n[i]),t.modified()},t.getOrientationWXYZ=()=>{const n=Pn();ms(n,e.rotation);const a=new Float64Array(3),i=Wl(a,n);return[Tn(i),a[0],a[1],a[2]]},t.getOrientationQuaternion=function(){let n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[];return ms(n,e.rotation)},t.rotateX=n=>{n!==0&&(Ei(e.rotation,e.rotation,fe(n)),t.modified())},t.rotateY=n=>{n!==0&&(Zr(e.rotation,e.rotation,fe(n)),t.modified())},t.rotateZ=n=>{n!==0&&(Di(e.rotation,e.rotation,fe(n)),t.modified())},t.rotateWXYZ=(n,a,i,s)=>{if(n===0||a===0&&i===0&&s===0)return;const o=fe(n),c=Pn();Bo(c,[a,i,s],o);const u=new Float64Array(16);Ja(u,c),ae(e.rotation,e.rotation,u),t.modified()},t.rotateQuaternion=n=>{if(Math.abs(n[3])>=1-gw)return;const a=Ja(new Float64Array(16),n);ae(e.rotation,e.rotation,a),t.modified()},t.setOrientation=(n,a,i)=>n===e.orientation[0]&&a===e.orientation[1]&&i===e.orientation[2]?!1:(e.orientation=[n,a,i],X(e.rotation),t.rotateZ(i),t.rotateX(n),t.rotateY(a),t.modified(),!0),t.setUserMatrix=n=>fr(e.userMatrix,n)?!1:(Re(e.userMatrix,n),t.modified(),!0),t.getMatrix=()=>(t.computeMatrix(),e.matrix),t.computeMatrix=()=>{if(t.getMTime()>e.matrixMTime.getMTime()){X(e.matrix),e.userMatrix&&ae(e.matrix,e.matrix,e.userMatrix),ge(e.matrix,e.matrix,e.origin),ge(e.matrix,e.matrix,e.position),ae(e.matrix,e.matrix,e.rotation),nn(e.matrix,e.matrix,e.scale),ge(e.matrix,e.matrix,[-e.origin[0],-e.origin[1],-e.origin[2]]),se(e.matrix,e.matrix),e.isIdentity=!0;for(let n=0;n<4;++n)for(let a=0;a<4;++a)(n===a?1:0)!==e.matrix[n+a*4]&&(e.isIdentity=!1);e.matrixMTime.modified()}},t.getCenter=()=>K.getCenter(e.bounds),t.getLength=()=>K.getLength(e.bounds),t.getXRange=()=>K.getXRange(e.bounds),t.getYRange=()=>K.getYRange(e.bounds),t.getZRange=()=>K.getZRange(e.bounds),t.getUserMatrix=()=>e.userMatrix;function r(){t.computeMatrix()}t.onModified(r)}const pw={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[1,-1,1,-1,1,-1],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function yg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,pw,r),pr.extend(t,e,r),e.matrixMTime={},y.obj(e.matrixMTime),y.get(t,e,["bounds","isIdentity"]),y.getArray(t,e,["orientation"]),y.setGetArray(t,e,["origin","position","scale"],3),e.matrix=X(new Float64Array(16)),e.rotation=X(new Float64Array(16)),e.userMatrix=X(new Float64Array(16)),e.transform=null,lw(t,e)}const hw=y.newInstance(yg,"vtkProp3D");var vs={newInstance:hw,extend:yg};const{InterpolationType:Ar}=Bv,{vtkErrorMacro:yo}=y,Yr=4;function dw(t,e){e.classHierarchy.push("vtkImageProperty"),t.getMTime=()=>{let r=e.mtime,n;for(let a=0;a<Yr;a++)e.componentData[a].rGBTransferFunction&&(n=e.componentData[a].rGBTransferFunction.getMTime(),r=r>n?r:n),e.componentData[a].piecewiseFunction&&(n=e.componentData[a].piecewiseFunction.getMTime(),r=r>n?r:n);return r},t.setRGBTransferFunction=function(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0,n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:null,a=r,i=n;return Number.isInteger(r)||(i=r,a=0),e.componentData[a].rGBTransferFunction!==i?(e.componentData[a].rGBTransferFunction=i,t.modified(),!0):!1},t.getRGBTransferFunction=function(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;return e.componentData[r].rGBTransferFunction},t.setPiecewiseFunction=function(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0,n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:null,a=r,i=n;return Number.isInteger(r)||(i=r,a=0),e.componentData[a].piecewiseFunction!==i?(e.componentData[a].piecewiseFunction=i,t.modified(),!0):!1},t.getPiecewiseFunction=function(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;return e.componentData[r].piecewiseFunction},t.setScalarOpacity=function(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0,n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:null,a=r,i=n;return Number.isInteger(r)||(i=r,a=0),t.setPiecewiseFunction(a,i)},t.getScalarOpacity=function(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;return t.getPiecewiseFunction(r)},t.setComponentWeight=function(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0,n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:1;if(r<0||r>=Yr)return yo("Invalid index"),!1;const a=Math.min(1,Math.max(0,n));return e.componentData[r].componentWeight!==a?(e.componentData[r].componentWeight=a,t.modified(),!0):!1},t.getComponentWeight=function(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;return r<0||r>=Yr?(yo("Invalid index"),0):e.componentData[r].componentWeight},t.setInterpolationTypeToNearest=()=>t.setInterpolationType(Ar.NEAREST),t.setInterpolationTypeToLinear=()=>t.setInterpolationType(Ar.LINEAR),t.getInterpolationTypeAsString=()=>y.enumToString(Ar,e.interpolationType)}const Tw={independentComponents:!1,interpolationType:Ar.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function Cg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};if(Object.assign(e,Tw,r),y.obj(t,e),!e.componentData){e.componentData=[];for(let n=0;n<Yr;n++)e.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}y.setGet(t,e,["independentComponents","interpolationType","colorWindow","colorLevel","ambient","diffuse","opacity","useLookupTableScalarRange","useLabelOutline","labelOutlineOpacity"]),y.setGetArray(t,e,["labelOutlineThickness"]),dw(t,e)}const vw=y.newInstance(Cg,"vtkImageProperty");var yw={newInstance:vw,extend:Cg};const{vtkDebugMacro:Cw}=y;function Sw(t,e){e.classHierarchy.push("vtkImageSlice"),t.getActors=()=>t,t.getImages=()=>t,t.getIsOpaque=()=>{if(e.forceOpaque)return!0;if(e.forceTranslucent)return!1;e.property||t.getProperty();let r=e.property.getOpacity()>=1;return r=r&&(!e.mapper||e.mapper.getIsOpaque()),r},t.hasTranslucentPolygonalGeometry=()=>!1,t.makeProperty=yw.newInstance,t.getProperty=()=>(e.property===null&&(e.property=t.makeProperty()),e.property),t.getBounds=()=>{if(e.mapper===null)return e.bounds;const r=e.mapper.getBounds();if(!r||r.length!==6)return r;if(r[0]>r[1])return e.mapperBounds=r.concat(),e.bounds=[1,-1,1,-1,1,-1],e.boundsMTime.modified(),r;const n=a=>a[0].map((i,s)=>a.map(o=>o[s]));if(!e.mapperBounds||!n([r,e.mapperBounds]).reduce((a,i)=>a&&i[0]===i[1],!0)||t.getMTime()>e.boundsMTime.getMTime()){Cw("Recomputing bounds..."),e.mapperBounds=r.map(i=>i),t.computeMatrix();const a=new Float64Array(16);se(a,e.matrix),K.transformBounds(r,a,e.bounds),e.boundsMTime.modified()}return e.bounds},t.getBoundsForSlice=(r,n)=>{const a=e.mapper.getBoundsForSlice(r,n);if(!K.isValid(a))return a;t.computeMatrix();const i=new Float64Array(16);return se(i,e.matrix),K.transformBounds(a,i)},t.getMinXBound=()=>t.getBounds()[0],t.getMaxXBound=()=>t.getBounds()[1],t.getMinYBound=()=>t.getBounds()[2],t.getMaxYBound=()=>t.getBounds()[3],t.getMinZBound=()=>t.getBounds()[4],t.getMaxZBound=()=>t.getBounds()[5],t.getMTime=()=>{let r=e.mtime;if(e.property!==null){const n=e.property.getMTime();r=n>r?n:r}return r},t.getRedrawMTime=()=>{let r=e.mtime;if(e.mapper!==null){let n=e.mapper.getMTime();r=n>r?n:r,e.mapper.getInput()!==null&&(e.mapper.getInputAlgorithm().update(),n=e.mapper.getInput().getMTime(),r=n>r?n:r)}if(e.property!==null){let n=e.property.getMTime();r=n>r?n:r,e.property.getRGBTransferFunction()!==null&&(n=e.property.getRGBTransferFunction().getMTime(),r=n>r?n:r)}return r},t.getSupportsSelection=()=>e.mapper?e.mapper.getSupportsSelection():!1}const xw={mapper:null,property:null,forceOpaque:!1,forceTranslucent:!1,bounds:[...K.INIT_BOUNDS]};function Sg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,xw,r),vs.extend(t,e,r),e.boundsMTime={},y.obj(e.boundsMTime),y.set(t,e,["property"]),y.setGet(t,e,["mapper","forceOpaque","forceTranslucent"]),y.getArray(t,e,["bounds"],6),Sw(t,e)}const ww=y.newInstance(Sg,"vtkImageSlice");var DM={newInstance:ww,extend:Sg};const Rw={MIN:0,MAX:1,MEAN:2,SUM:3};var Mw={SlabTypes:Rw};function Ow(t,e){e.classHierarchy.push("vtkAbstractImageMapper"),t.getIsOpaque=()=>!0,t.getCurrentImage=()=>null,t.getBoundsForSlice=()=>(y.vtkErrorMacro("vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED"),xt())}const mw={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1]};function Ew(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,mw,r),Zi.extend(t,e,r),y.setGet(t,e,["slice","useCustomExtents"]),y.setGetArray(t,e,["customDisplayExtent"],6),y.setGetArray(t,e,["backgroundColor"],4),Ow(t,e)}var xg={extend:Ew};const{SlabTypes:Dw}=Mw,{staticOffsetAPI:Vw,otherStaticMethods:Lw}=Rn;function Fw(t,e){e.classHierarchy.push("vtkImageResliceMapper"),t.getBounds=()=>{let r=[...K.INIT_BOUNDS];const n=t.getInputData();return t.getSlicePolyData()?r=t.getSlicePolyData().getBounds():n&&(r=n.getBounds(),t.getSlicePlane()&&K.cutWithPlane(r,t.getSlicePlane().getOrigin(),t.getSlicePlane().getNormal())),r}}const kw={slabThickness:0,slabTrapezoidIntegration:0,slabType:Dw.MEAN,slicePlane:null,slicePolyData:null};function wg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,kw,r),xg.extend(t,e,r),y.setGet(t,e,["slabThickness","slabTrapezoidIntegration","slabType","slicePlane","slicePolyData"]),Rn.implementCoincidentTopologyMethods(t,e),Fw(t,e)}const Nw=y.newInstance(wg,"vtkImageResliceMapper");var VM={newInstance:Nw,extend:wg,...Vw,...Lw};const{vtkDebugMacro:_w}=y;function Gw(t,e){e.classHierarchy.push("vtkActor");const r={...t};t.getActors=()=>[t],t.getIsOpaque=()=>{if(e.forceOpaque)return!0;if(e.forceTranslucent)return!1;e.property||t.getProperty();let n=e.property.getOpacity()>=1;return n=n&&(!e.texture||!e.texture.isTranslucent()),n=n&&(!e.mapper||e.mapper.getIsOpaque()),n},t.hasTranslucentPolygonalGeometry=()=>e.mapper===null?!1:(e.property===null&&t.setProperty(t.makeProperty()),!t.getIsOpaque()),t.makeProperty=Ra.newInstance,t.getProperty=()=>(e.property===null&&(e.property=t.makeProperty()),e.property),t.getBounds=()=>{if(e.mapper===null)return e.bounds;const n=e.mapper.getBounds();if(!n||n.length!==6)return n;if(n[0]>n[1])return e.mapperBounds=n.concat(),e.bounds=[1,-1,1,-1,1,-1],e.boundsMTime.modified(),n;if(!e.mapperBounds||n[0]!==e.mapperBounds[0]||n[1]!==e.mapperBounds[1]||n[2]!==e.mapperBounds[2]||n[3]!==e.mapperBounds[3]||n[4]!==e.mapperBounds[4]||n[5]!==e.mapperBounds[5]||t.getMTime()>e.boundsMTime.getMTime()){_w("Recomputing bounds..."),e.mapperBounds=n.concat();const a=[];K.getCorners(n,a),t.computeMatrix();const i=new Float64Array(16);se(i,e.matrix),a.forEach(s=>q(s,s,i)),e.bounds[0]=e.bounds[2]=e.bounds[4]=Number.MAX_VALUE,e.bounds[1]=e.bounds[3]=e.bounds[5]=-Number.MAX_VALUE,e.bounds=e.bounds.map((s,o)=>o%2===0?a.reduce((c,u)=>c>u[o/2]?u[o/2]:c,s):a.reduce((c,u)=>c<u[(o-1)/2]?u[(o-1)/2]:c,s)),e.boundsMTime.modified()}return e.bounds},t.getMTime=()=>{let n=r.getMTime();if(e.property!==null){const a=e.property.getMTime();n=a>n?a:n}if(e.backfaceProperty!==null){const a=e.backfaceProperty.getMTime();n=a>n?a:n}return n},t.getRedrawMTime=()=>{let n=e.mtime;if(e.mapper!==null){let a=e.mapper.getMTime();n=a>n?a:n,e.mapper.getInput()!==null&&(e.mapper.getInputAlgorithm().update(),a=e.mapper.getInput().getMTime(),n=a>n?a:n)}return n},t.getSupportsSelection=()=>e.mapper?e.mapper.getSupportsSelection():!1,t.processSelectorPixelBuffers=(n,a)=>{e.mapper&&e.mapper.processSelectorPixelBuffers&&e.mapper.processSelectorPixelBuffers(n,a)}}const Uw={mapper:null,property:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1,bounds:[1,-1,1,-1,1,-1]};function Rg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Uw,r),vs.extend(t,e,r),e.boundsMTime={},y.obj(e.boundsMTime),y.set(t,e,["property"]),y.setGet(t,e,["backfaceProperty","forceOpaque","forceTranslucent","mapper"]),Gw(t,e)}const Bw=y.newInstance(Rg,"vtkActor");var dr={newInstance:Bw,extend:Rg};function Mg(t,e,r){let n=-1,a=-1,i=0,s=1;for(let f=0;f<3;f++)for(let l=0;l<2;l++){const p=2*f+l,d=(t[p]-e[f])*(1-2*l),h=(t[p]-r[f])*(1-2*l);if(d>0&&h>0)return;if(d>0||h>0){let T=0;if(d!==0&&(T=d/(d-h)),d>0?T>=i&&(i=T,n=p):T<=s&&(s=T,a=p),i>s&&(n<0||a<0))return}}function o(f,l){const p=[0,0,0];for(let d=0;d<2;d++)for(let h=0;h<3;h++)f===2*h||f===2*h+1?p[h]=t[f]:(p[h]=e[h]*(1-l)+r[h]*l,p[h]<t[2*h]&&(p[h]=t[2*h]),p[h]>t[2*h+1]&&(p[h]=t[2*h+1]));return p}const c=o(n,i),u=o(a,s);return{t1:i,t2:s,x1:c,x2:u}}const Ww={};function $w(t,e){e.classHierarchy.push("vtkBox"),t.setBounds=function(){let r=[];for(var n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];if(Array.isArray(a[0]))r=a[0];else for(let s=0;s<a.length;s++)r.push(a[s]);if(r.length!==6){console.log("vtkBox.setBounds",r,a);return}K.setBounds(e.bbox,r)},t.getBounds=()=>e.bbox,t.evaluateFunction=(r,n,a)=>{const i=Array.isArray(r)?r:[r,n,a];let s,o,c,u=-Number.MAX_VALUE,g=0;const f=K.getMinPoint(e.bbox),l=K.getMaxPoint(e.bbox);let p=1;for(let d=0;d<3;d++)s=K.getLength(e.bbox,d),s!==0?(c=(i[d]-f[d])/s,c<0?(p=0,o=f[d]-i[d]):c>1?(p=0,o=i[d]-l[d]):(c<=.5?o=f[d]-i[d]:o=i[d]-l[d],o>u&&(u=o))):(o=Math.abs(i[d]-f[d]),o>0&&(p=0)),o>0&&(g+=o*o);return g=Math.sqrt(g),p?u:g},t.addBounds=function(){let r=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))r=arguments.length<=0?void 0:arguments[0];else for(let n=0;n<arguments.length;n++)r.push(n<0||arguments.length<=n?void 0:arguments[n]);r.length===6&&(K.addBounds(e.bbox,...r),t.modified())},t.addBox=r=>t.addBounds(r.getBounds()),t.intersectWithLine=(r,n)=>Mg(e.bbox,r,n)}const zw={bbox:[...K.INIT_BOUNDS]};function Og(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,zw,r),jc.extend(t,e,r),$w(t,e)}const Hw=y.newInstance(Og,"vtkBox");var jw={newInstance:Hw,extend:Og,intersectWithLine:Mg,...Ww};const{vtkWarningMacro:bw}=y,Kw=1e-6;function Xw(t,e){e.classHierarchy.push("vtkPlaneSource"),t.requestData=(r,n)=>{if(e.deleted)return;const a=n[0],i=a?a.getPoints().getDataType():e.pointType,s=Be.newInstance(),o=[],c=[];if(re(e.point1,e.origin,o),re(e.point2,e.origin,c),!t.updatePlane(o,c)){bw("Bad plane definition");return}const u=e.xResolution,g=e.yResolution,f=(u+1)*(g+1),l=u*g,p=y.newTypedArray(i,f*3);s.getPoints().setData(p,3);const d=new Uint32Array(5*l);s.getPolys().setData(d,1);const h=new Float32Array(f*3),T=A.newInstance({numberOfComponents:3,values:h,name:"Normals"});s.getPointData().setNormals(T);const v=new Float32Array(f*2),C=A.newInstance({numberOfComponents:2,values:v,name:"TextureCoordinates"});s.getPointData().setTCoords(C);const S=new Float32Array(2);let x=0;for(let R=0;R<g+1;R++){S[1]=R/g;for(let O=0;O<u+1;O++)S[0]=O/u,p[x*3]=e.origin[0]+S[0]*o[0]+S[1]*c[0],p[x*3+1]=e.origin[1]+S[0]*o[1]+S[1]*c[1],p[x*3+2]=e.origin[2]+S[0]*o[2]+S[1]*c[2],v[x*2]=S[0],v[x*2+1]=S[1],h[x*3]=e.normal[0],h[x*3+1]=e.normal[1],h[x*3+2]=e.normal[2],x++}x=0;for(let R=0;R<g;R++)for(let O=0;O<u;O++)d[x*5+0]=4,d[x*5+1]=O+R*(u+1),d[x*5+2]=d[x*5+1]+1,d[x*5+3]=d[x*5+1]+u+2,d[x*5+4]=d[x*5+1]+u+1,x++;n[0]=s},t.setNormal=function(){let r=[];if(arguments.length===1||Array.isArray(arguments.length<=0?void 0:arguments[0])?r=[...arguments.length<=0?void 0:arguments[0]]:arguments.length===3&&(r=[arguments.length<=0?void 0:arguments[0],arguments.length<=1?void 0:arguments[1],arguments.length<=2?void 0:arguments[2]]),pe(r)!==0){const n=b(e.normal,r);let a=0;const i=[];n<1&&(n<=-1?(a=fe(180),re(e.point1,e.origin,i)):(Te(e.normal,r,i),a=Math.acos(n)),t.rotate(a,i))}},t.rotate=(r,n)=>{if(Math.abs(r)<Kw)return;const a=X(new Float64Array(16)),i=[];$l(i,e.center),ge(a,a,e.center),Fe(a,a,r,n),ge(a,a,i),q(e.origin,e.origin,a),q(e.point1,e.point1,a),q(e.point2,e.point2,a),ot.buildFromRadian().rotate(r,n).apply(e.normal),t.modified()},t.setCenter=function(){let r=[];if(arguments.length===1||Array.isArray(arguments.length<=0?void 0:arguments[0])?r=[...arguments.length<=0?void 0:arguments[0]]:arguments.length===3&&(r=[arguments.length<=0?void 0:arguments[0],arguments.length<=1?void 0:arguments[1],arguments.length<=2?void 0:arguments[2]]),!Hn(r,e.center)){const n=[];re(e.point1,e.origin,n);const a=[];re(e.point2,e.origin,a);for(let i=0;i<3;i++)e.center[i]=r[i],e.origin[i]=e.center[i]-.5*(n[i]+a[i]),e.point1[i]=e.origin[i]+n[i],e.point2[i]=e.origin[i]+a[i];t.modified()}},t.setPoint1=function(){let r=[];if(arguments.length===1||Array.isArray(arguments.length<=0?void 0:arguments[0])?r=[...arguments.length<=0?void 0:arguments[0]]:arguments.length===3&&(r=[arguments.length<=0?void 0:arguments[0],arguments.length<=1?void 0:arguments[1],arguments.length<=2?void 0:arguments[2]]),!Hn(r,e.point1)){const n=[],a=[];e.point1=[...r],re(e.point1,e.origin,n),re(e.point2,e.origin,a),t.updatePlane(n,a),t.modified()}},t.setPoint2=function(){let r=[];if(arguments.length===1||Array.isArray(arguments.length<=0?void 0:arguments[0])?r=[...arguments.length<=0?void 0:arguments[0]]:arguments.length===3&&(r=[arguments.length<=0?void 0:arguments[0],arguments.length<=1?void 0:arguments[1],arguments.length<=2?void 0:arguments[2]]),!Hn(r,e.point2)){const n=[],a=[];e.point2=[...r],re(e.point1,e.origin,n),re(e.point2,e.origin,a),t.updatePlane(n,a),t.modified()}},t.updatePlane=(r,n)=>{for(let a=0;a<3;a++)e.center[a]=e.origin[a]+.5*(r[a]+n[a]);return Te(r,n,e.normal),pe(e.normal)!==0}}const Aw={xResolution:10,yResolution:10,origin:[0,0,0],point1:[1,0,0],point2:[0,1,0],pointType:"Float64Array"};function mg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Aw,r),e.normal=[0,0,1],e.center=[0,0,0],y.obj(t,e),y.setGet(t,e,["xResolution","yResolution"]),y.setGetArray(t,e,["origin"],3),y.getArray(t,e,["point1","point2","normal","center"],3),y.algo(t,e,0,1),Xw(t,e),t.setPoint1(e.point1),t.setPoint2(e.point2)}const Yw=y.newInstance(mg,"vtkPlaneSource");var Co={newInstance:Yw,extend:mg};const Eg={DIRECTION:0,ROTATION:1,MATRIX:2},qw={SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2};var Dg={OrientationModes:Eg,ScaleModes:qw};const{OrientationModes:Ft,ScaleModes:ht}=Dg,{vtkErrorMacro:Zw}=y;function Pw(t,e){e.classHierarchy.push("vtkGlyph3DMapper"),t.getOrientationModeAsString=()=>y.enumToString(Ft,e.orientationMode),t.setOrientationModeToDirection=()=>t.setOrientationMode(Ft.DIRECTION),t.setOrientationModeToRotation=()=>t.setOrientationMode(Ft.ROTATION),t.setOrientationModeToMatrix=()=>t.setOrientationMode(Ft.MATRIX),t.getOrientationArrayData=()=>{const r=t.getInputData(0);return!r||!r.getPointData()?null:e.orientationArray?r.getPointData().getArray(e.orientationArray):r.getPointData().getVectors()},t.getScaleModeAsString=()=>y.enumToString(ht,e.scaleMode),t.setScaleModeToScaleByMagnitude=()=>t.setScaleMode(ht.SCALE_BY_MAGNITUDE),t.setScaleModeToScaleByComponents=()=>t.setScaleMode(ht.SCALE_BY_COMPONENTS),t.setScaleModeToScaleByConstant=()=>t.setScaleMode(ht.SCALE_BY_CONSTANT),t.getScaleArrayData=()=>{const r=t.getInputData(0);return!r||!r.getPointData()?null:e.scaleArray?r.getPointData().getArray(e.scaleArray):r.getPointData().getScalars()},t.getBounds=()=>{const r=t.getInputData(0),n=t.getInputData(1);return!r||!n?xt():(t.buildArrays(),e.bounds)},t.buildArrays=()=>{const r=t.getInputData(0),n=t.getInputData(1);if(e.buildTime.getMTime()<n.getMTime()||e.buildTime.getMTime()<r.getMTime()||e.buildTime.getMTime()<t.getMTime()){const a=r.getPoints().getData();let i=t.getScaleArrayData(),s=null,o=0;i&&(s=i.getData(),o=i.getNumberOfComponents()),e.scaling&&i&&e.scaleMode===ht.SCALE_BY_COMPONENTS&&i.getNumberOfComponents()!==3&&(Zw("Cannot scale by components since scale array does not have 3 components."),i=null);const c=n.getBounds(),u=[];K.getCorners(c,u),e.bounds[0]=K.INIT_BOUNDS[0],e.bounds[1]=K.INIT_BOUNDS[1],e.bounds[2]=K.INIT_BOUNDS[2],e.bounds[3]=K.INIT_BOUNDS[3],e.bounds[4]=K.INIT_BOUNDS[4],e.bounds[5]=K.INIT_BOUNDS[5];const g=new Float64Array(3),f=t.getOrientationArrayData(),l=X(new Float64Array(16)),p=[],d=[],h=a.length/3;e.matrixArray=new Float32Array(16*h);const T=e.matrixArray.buffer;e.normalArray=new Float32Array(9*h);const v=e.normalArray.buffer,C=[],S=[];for(let O=0;O<h;++O){const w=new Float32Array(T,O*64,16);if(p[0]=a[O*3],p[1]=a[O*3+1],p[2]=a[O*3+2],ge(w,l,p),f)switch(f.getTuple(O,S),e.orientationMode){case Ft.MATRIX:{const E=[...S.slice(0,3),0,...S.slice(3,6),0,...S.slice(6,9),0,0,0,0,1];ae(w,w,E);break}case Ft.ROTATION:Di(w,w,S[2]),Ei(w,w,S[0]),Zr(w,w,S[1]);break;case Ft.DIRECTION:if(S[1]===0&&S[2]===0)S[0]<0&&Zr(w,w,3.1415926);else{const E=Pe(S),M=[];M[0]=(S[0]+E)/2,M[1]=S[1]/2,M[2]=S[2]/2,Fe(w,w,3.1415926,M)}break}if(e.scaling){if(d[0]=e.scaleFactor,d[1]=e.scaleFactor,d[2]=e.scaleFactor,i)switch(e.scaleMode){case ht.SCALE_BY_MAGNITUDE:for(let E=0;E<o;++E)C[E]=s[O*o+E];d[0]*=Pe(C,o),d[1]=d[0],d[2]=d[0];break;case ht.SCALE_BY_COMPONENTS:for(let E=0;E<o;++E)C[E]=s[O*o+E];d[0]*=C[0],d[1]*=C[1],d[2]*=C[2];break;case ht.SCALE_BY_CONSTANT:}d[0]===0&&(d[0]=1e-10),d[1]===0&&(d[1]=1e-10),d[2]===0&&(d[2]=1e-10),nn(w,w,d)}for(let E=0;E<8;++E)q(g,u[E],w),g[0]<e.bounds[0]&&(e.bounds[0]=g[0]),g[1]<e.bounds[2]&&(e.bounds[2]=g[1]),g[2]<e.bounds[4]&&(e.bounds[4]=g[2]),g[0]>e.bounds[1]&&(e.bounds[1]=g[0]),g[1]>e.bounds[3]&&(e.bounds[3]=g[1]),g[2]>e.bounds[5]&&(e.bounds[5]=g[2]);const m=new Float32Array(v,O*36,9);pa(m,w),nr(m,m),mi(m,m)}const x=t.getAbstractScalars(r,e.scalarMode,e.arrayAccessMode,e.arrayId,e.colorByArrayName).scalars;e.useLookupTableScalarRange||t.getLookupTable().setRange(e.scalarRange[0],e.scalarRange[1]),e.colorArray=null;const R=t.getLookupTable();R&&x&&(R.build(),e.colorArray=R.mapScalars(x,e.colorMode,0)),e.buildTime.modified()}},t.getPrimitiveCount=()=>{const r=t.getInputData(1),n=t.getInputData().getPoints().getNumberOfValues()/3;return{points:n*r.getPoints().getNumberOfValues()/3,verts:n*(r.getVerts().getNumberOfValues()-r.getVerts().getNumberOfCells()),lines:n*(r.getLines().getNumberOfValues()-2*r.getLines().getNumberOfCells()),triangles:n*(r.getPolys().getNumberOfValues()-3*r.getLines().getNumberOfCells())}},t.setSourceConnection=r=>t.setInputConnection(r,1)}const Jw={orient:!0,orientationMode:Ft.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:ht.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function Vg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,Jw,r),lr.extend(t,e,r),y.algo(t,e,2,0),e.buildTime={},y.obj(e.buildTime,{mtime:0}),e.boundsTime={},y.obj(e.boundsTime,{mtime:0}),y.setGet(t,e,["orient","orientationMode","orientationArray","scaleArray","scaleFactor","scaleMode","scaling"]),y.get(t,e,["colorArray","matrixArray","normalArray","buildTime"]),Pw(t,e)}const Qw=y.newInstance(Vg,"vtkGlyph3DMapper");var Lg={newInstance:Qw,extend:Vg,...Dg};function Iw(t,e){e.classHierarchy.push("vtkHandleRepresentation")}const e2={behavior:Sn.HANDLE,pickable:!0,dragable:!0,scaleInPixels:!0};function t2(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};const n={...e2,...r};gs.extend(t,e,n),Iw(t,e)}var n2={extend:t2};function r2(t,e){e.classHierarchy.push("vtkSphereSource"),t.requestData=(r,n)=>{if(e.deleted)return;let a=n[0];const i=a?a.getPoints().getDataType():e.pointType;a=Be.newInstance();let s=0,{thetaResolution:o}=e,c=e.startTheta<e.endTheta?e.startTheta:e.endTheta;c*=Math.PI/180;let u=e.endTheta>e.startTheta?e.endTheta:e.startTheta;u*=Math.PI/180;let g=e.startPhi<e.endPhi?e.startPhi:e.endPhi;g*=Math.PI/180;let f=e.endPhi>e.startPhi?e.endPhi:e.startPhi;f*=Math.PI/180,Math.abs(c-u)<2*Math.PI&&++o;const l=(u-c)/e.thetaResolution,p=e.startPhi<=0?1:0,d=e.phiResolution+(e.endPhi>=180?-1:0),h=e.phiResolution*o+2,T=e.phiResolution*2*e.thetaResolution;let v=0,C=y.newTypedArray(i,h*3),S=new Float32Array(h*3),x=0,R=new Uint32Array(T*5);e.startPhi<=0&&(C[v*3+0]=e.center[0],C[v*3+1]=e.center[1],C[v*3+2]=e.center[2]+e.radius,S[v*3+0]=0,S[v*3+1]=0,S[v*3+2]=1,v++,s++),e.endPhi>=180&&(C[v*3+0]=e.center[0],C[v*3+1]=e.center[1],C[v*3+2]=e.center[2]-e.radius,S[v*3+0]=0,S[v*3+1]=0,S[v*3+2]=-1,v++,s++);const O=e.phiResolution-s,w=(f-g)/(e.phiResolution-1);for(let M=0;M<o;M++){const D=c+M*l;for(let N=p;N<d;N++){const G=g+N*w,_=e.radius*Math.sin(G);S[v*3+0]=_*Math.cos(D),S[v*3+1]=_*Math.sin(D),S[v*3+2]=e.radius*Math.cos(G),C[v*3+0]=S[v*3+0]+e.center[0],C[v*3+1]=S[v*3+1]+e.center[1],C[v*3+2]=S[v*3+2]+e.center[2];let B=Math.sqrt(S[v*3+0]*S[v*3+0]+S[v*3+1]*S[v*3+1]+S[v*3+2]*S[v*3+2]);B=B===0?1:B,S[v*3+0]/=B,S[v*3+1]/=B,S[v*3+2]/=B,v++}}const m=O*o;if(Math.abs(c-u)<2*Math.PI&&--o,e.startPhi<=0)for(let M=0;M<o;M++)R[x++]=3,R[x++]=O*M+s,R[x++]=O*(M+1)%m+s,R[x++]=0;if(e.endPhi>=180){const M=O-1+s;for(let D=0;D<o;D++)R[x++]=3,R[x++]=O*D+M,R[x++]=s-1,R[x++]=O*(D+1)%m+M}for(let M=0;M<o;M++)for(let D=0;D<O-1;D++){const N=O*M+D+s,G=N+1,_=(O*(M+1)+D)%m+s+1;e.latLongTessellation?(R[x++]=4,R[x++]=N,R[x++]=G,R[x++]=_,R[x++]=_-1):(R[x++]=3,R[x++]=N,R[x++]=G,R[x++]=_,R[x++]=3,R[x++]=N,R[x++]=_,R[x++]=_-1)}C=C.subarray(0,v*3),a.getPoints().setData(C,3),S=S.subarray(0,v*3);const E=A.newInstance({name:"Normals",values:S,numberOfComponents:3});a.getPointData().setNormals(E),R=R.subarray(0,x),a.getPolys().setData(R,1),n[0]=a}}const a2={radius:.5,latLongTessellation:!1,thetaResolution:8,startTheta:0,endTheta:360,phiResolution:8,startPhi:0,endPhi:180,center:[0,0,0],pointType:"Float64Array"};function Fg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,a2,r),y.obj(t,e),y.setGet(t,e,["radius","latLongTessellation","thetaResolution","startTheta","endTheta","phiResolution","startPhi","endPhi"]),y.setGetArray(t,e,["center"],3),y.algo(t,e,0,1),r2(t,e)}const i2=y.newInstance(Fg,"vtkSphereSource");var s2={newInstance:i2,extend:Fg};function kg(t,e){return(r,n)=>{const a=Rt(r,"points",n.length).getData();let i=0;for(let s=0;s<n.length;++s){const o=n[s].getOrigin(e.scaleInPixels&&e.displayScaleParams);a[i++]=o[0],a[i++]=o[1],a[i++]=o[2]}}}function o2(t,e){return(r,n)=>{Rt(r,"points",0)}}function c2(t,e){return(r,n)=>{e._pipeline.mapper.setColorByArrayName("color");const a=Rt(r,"color",n.length,"Uint8Array",4),i=a.getData();let s=0;for(let o=0;o<n.length;++o){let c=n[o].getColor3();n[o].getActive()&&e.useActiveColor&&(c=e.activeColor),i[s++]=c[0],i[s++]=c[1],i[s++]=c[2],i[s++]=n[o].getOpacity()}a.dataChange()}}function u2(t,e){return(r,n)=>{e._pipeline.mapper.setColorByArrayName("color");const a=Rt(r,"color",n.length).getData();for(let i=0;i<n.length;++i){let s=n[i].getColor();n[i].getActive()&&e.useActiveColor&&(s=e.activeColor),a[i]=s}}}function f2(t,e){return(r,n)=>{e._pipeline.mapper.setColorByArrayName(null)}}function g2(t,e){return(r,n)=>{var s;e._pipeline.mapper.setScaleArray("scale"),e._pipeline.mapper.setScaleFactor(1),e._pipeline.mapper.setScaling(!0),e._pipeline.mapper.setScaleMode(Lg.ScaleModes.SCALE_BY_COMPONENTS);const a=Rt(r,"scale",n.length,"Float32Array",3).getData();let i=0;for(let o=0;o<n.length;++o){const c=n[o];let u=c.getActive()?e.activeScaleFactor:1;t.getScaleInPixels()&&(u*=hr(c.getOrigin(),e.displayScaleParams));const g=((s=c.getScale3)==null?void 0:s.call(c))??e.defaultScale;a[i++]=u*g[0],a[i++]=u*g[1],a[i++]=u*g[2]}}}function l2(t,e){return(r,n)=>{var i;e._pipeline.mapper.setScaleArray("scale"),e._pipeline.mapper.setScaleFactor(1),e._pipeline.mapper.setScaling(!0);const a=Rt(r,"scale",n.length).getData();for(let s=0;s<n.length;++s){const o=n[s];let c=o.getActive()?e.activeScaleFactor:1;t.getScaleInPixels()&&(c*=hr(o.getOrigin(),e.displayScaleParams));const u=((i=o.getScale1)==null?void 0:i.call(o))??e.defaultScale;a[s]=c*u}}}function p2(t,e){return(r,n)=>{e._pipeline.mapper.setScaleArray(null),e._pipeline.mapper.setScaleFactor(e.defaultScale),e._pipeline.mapper.setScaling(e.defaultScale!==1)}}function h2(t,e){return(r,n)=>{e._pipeline.mapper.setOrientationArray("orientation"),e._pipeline.mapper.setOrientationMode(Eg.MATRIX);const a=Rt(r,"orientation",n.length,"Float64Array",9).getData();for(let i=0;i<n.length;++i){const s=n[i],o=s.getRight?s.getRight():[1,0,0],c=s.getUp?s.getUp():[0,1,0],u=s.getDirection?s.getDirection():[0,0,1];a.set(o,9*i),a.set(c,9*i+3),a.set(u,9*i+6)}}}function d2(t,e){return(r,n)=>{e._pipeline.mapper.setOrientationArray(null)}}function T2(t,e){e.classHierarchy.push("vtkGlyphRepresentation");const r={...t},n=Be.newInstance({mtime:0});function a(i){for(var s=arguments.length,o=new Array(s>1?s-1:0),c=1;c<s;c++)o[c-1]=arguments[c];return o.every(u=>{var g,f;return((f=(g=i[0])==null?void 0:g[`get${y.capitalize(u)}`])==null?void 0:f.call(g))!=null})}t.getRepresentationStates=function(){let i=arguments.length>0&&arguments[0]!==void 0?arguments[0]:e.inputData[0];return r.getRepresentationStates(i).filter(s=>{var o,c;return((o=s.getOrigin)==null?void 0:o.call(s))&&(((c=s.isVisible)==null?void 0:c.call(s))??!0)})},t.getMixins=i=>{const s={};return a(i,"origin")?s.position=e.applyMixin.origin:s.position=e.applyMixin.noPosition,a(i,"color3")?s.color=e.applyMixin.color3:a(i,"color")?s.color=e.applyMixin.color:s.color=e.applyMixin.noColor,a(i,"scale3")?s.scale=e.applyMixin.scale3:a(i,"scale1")?s.scale=e.applyMixin.scale1:s.scale=e.applyMixin.noScale,a(i,"direction")?s.orientation=e.applyMixin.direction:s.orientation=e.applyMixin.noOrientation,s},t.requestData=(i,s)=>{const o=t.getRepresentationStates(i[0]);s[0]=n;const c=t.getMixins(o);Object.values(c).forEach(u=>u(n,o)),n.getPoints().modified(),n.modified()},gs.connectPipeline(e._pipeline),t.addActor(e._pipeline.actor)}function So(t,e,r){var n,a,i,s,o,c,u,g,f,l,p,d,h,T;return{defaultScale:1,...r,_pipeline:{source:((n=r._pipeline)==null?void 0:n.source)??t,glyph:((a=r._pipeline)==null?void 0:a.glyph)??s2.newInstance({phiResolution:8,thetaResolution:8}),mapper:((i=r._pipeline)==null?void 0:i.mapper)??Lg.newInstance({scalarMode:Du.USE_POINT_FIELD_DATA}),actor:((s=r._pipeline)==null?void 0:s.actor)??dr.newInstance({parentProp:t}),...r._pipeline},applyMixin:{origin:((o=r.applyMixin)==null?void 0:o.origin)??kg(t,e),noPosition:((c=r.applyMixin)==null?void 0:c.noPosition)??o2(),color3:((u=r.applyMixin)==null?void 0:u.color3)??c2(t,e),color:((g=r.applyMixin)==null?void 0:g.color)??u2(t,e),noColor:((f=r.applyMixin)==null?void 0:f.noColor)??f2(t,e),scale3:((l=r.applyMixin)==null?void 0:l.scale3)??g2(t,e),scale1:((p=r.applyMixin)==null?void 0:p.scale1)??l2(t,e),noScale:((d=r.applyMixin)==null?void 0:d.noScale)??p2(t,e),direction:((h=r.applyMixin)==null?void 0:h.direction)??h2(t,e),noOrientation:((T=r.applyMixin)==null?void 0:T.noOrientation)??d2(t,e),...r.applyMixin}}}function Ng(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};r.behavior===Sn.CONTEXT?Jf.extend(t,e,So(t,e,r)):n2.extend(t,e,So(t,e,r)),"lighting"in r&&e._pipeline.actor.getProperty().setLighting(r.lighting),y.setGet(t,e._pipeline,["defaultScale"]),y.get(t,e._pipeline,["glyph","mapper","actor"]),y.setGet(t,e.applyMixin,Object.keys(e.applyMixin)),T2(t,e)}const v2=y.newInstance(Ng,"vtkGlyphRepresentation");var _g={newInstance:v2,extend:Ng};function y2(t,e){e.classHierarchy.push("vtkPixelSpaceCallbackMapper"),e.callback||(e.callback=()=>{}),t.invokeCallback=(r,n,a,i,s)=>{if(!e.callback)return;const o=n.getCompositeProjectionMatrix(a,-1,1);se(o,o);const c=r.getPoints(),u=new Float64Array(3),g=i.usize,f=i.vsize,l=g/2,p=f/2,d=[];for(let h=0;h<c.getNumberOfPoints();h+=1){const T=c.getPoint(h);q(u,T,o);const v=[u[0]*l+l,u[1]*p+p,u[2],0];if(s){const S=(Math.floor(v[1])*g+Math.floor(v[0]))*4,x=s[S]/255,R=s[S+1]/255,O=(x*256+R)/257;v[3]=O*2-1}d.push(v)}e.callback(d,n,a,s,[g,f])}}const C2={callback:null,useZValues:!1};function Gg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,C2,r),lr.extend(t,e,r),y.setGet(t,e,["callback","useZValues"]),y2(t,e)}const S2=y.newInstance(Gg,"vtkPixelSpaceCallbackMapper");var Ug={newInstance:S2,extend:Gg};function x2(t,e){e.classHierarchy.push("vtkCylinderSource");function r(n,a){if(e.deleted)return;let i=a[0];const s=2*Math.PI/e.resolution;let o=2*e.resolution,c=5*e.resolution;e.capping&&(o=4*e.resolution,c=7*e.resolution+2);const u=y.newTypedArray(e.pointType,o*3);let g=0;const f=new Uint32Array(c),l=new Float32Array(o*3),p=A.newInstance({numberOfComponents:3,values:l,name:"Normals"}),d=new Float32Array(o*2),h=A.newInstance({numberOfComponents:2,values:d,name:"TCoords"}),T=[0,0,0],v=[0,0,0],C=[0,0,0],S=[0,0,0],x=[0,0],R=[0,0],O=e.otherRadius==null?e.radius:e.otherRadius;for(let w=0;w<e.resolution;w++){T[0]=Math.cos(w*s+e.initAngle),v[0]=T[0],C[0]=e.radius*T[0]+e.center[0],S[0]=C[0],x[0]=Math.abs(2*w/e.resolution-1),R[0]=x[0],C[1]=.5*e.height+e.center[1],S[1]=-.5*e.height+e.center[1],x[1]=0,R[1]=1,T[2]=-Math.sin(w*s+e.initAngle),v[2]=T[2],C[2]=O*T[2]+e.center[2],S[2]=C[2];const m=2*w;for(let E=0;E<3;E++)l[m*3+E]=T[E],l[(m+1)*3+E]=v[E],u[m*3+E]=C[E],u[(m+1)*3+E]=S[E],E<2&&(d[m*2+E]=x[E],d[(m+1)*2+E]=R[E])}for(let w=0;w<e.resolution;w++){f[g++]=4,f[g++]=2*w,f[g++]=2*w+1;const m=(2*w+3)%(2*e.resolution);f[g++]=m,f[g++]=m-1}if(e.capping){for(let w=0;w<e.resolution;w++){C[0]=e.radius*Math.cos(w*s+e.initAngle),S[0]=C[0],x[0]=C[0],R[0]=C[0],C[0]+=e.center[0],S[0]+=e.center[0],T[1]=1,v[1]=-1,C[1]=.5*e.height+e.center[1],S[1]=-.5*e.height+e.center[1],C[2]=-O*Math.sin(w*s+e.initAngle),S[2]=C[2],x[1]=C[2],R[1]=C[2],C[2]+=e.center[2],S[2]+=e.center[2];const m=2*e.resolution+w,E=3*e.resolution+e.resolution-w-1;for(let M=0;M<3;M++)l[3*m+M]=T[M],l[3*E+M]=v[M],u[3*m+M]=C[M],u[3*E+M]=S[M],M<2&&(d[2*m+M]=x[M],d[2*E+M]=R[M])}f[g++]=e.resolution;for(let w=0;w<e.resolution;w++)f[g++]=2*e.resolution+w;f[g++]=e.resolution;for(let w=0;w<e.resolution;w++)f[g++]=3*e.resolution+w}ot.buildFromRadian().translate(...e.center).rotateFromDirections([0,1,0],e.direction).translate(...e.center.map(w=>w*-1)).apply(u),i=Be.newInstance(),i.getPoints().setData(u,3),i.getPolys().setData(f,1),i.getPointData().setNormals(p),i.getPointData().setTCoords(h),a[0]=i}t.requestData=r}const w2={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:"Float64Array"};function Bg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,w2,r),y.obj(t,e),y.setGet(t,e,["height","initAngle","otherRadius","radius","resolution","capping"]),y.setGetArray(t,e,["center","direction"],3),y.algo(t,e,0,1),x2(t,e)}const R2=y.newInstance(Bg,"vtkCylinderSource");var M2={newInstance:R2,extend:Bg};const O2=1e5;function m2(t,e){e.classHierarchy.push("vtkLineHandleRepresentation"),e.displayMapper=Ug.newInstance(),e.displayActor=dr.newInstance({parentProp:t}),e.displayActor.setMapper(e.displayMapper),e.displayMapper.setInputConnection(t.getOutputPort()),t.addActor(e.displayActor),e.alwaysVisibleActors=[e.displayActor],t.setGlyphResolution=y.chain(t.setGlyphResolution,e._pipeline.glyph.setThetaResolution,e._pipeline.glyph.setPhiResolution);function r(i){if(e.displayCallback){const s=[],o=t.getRepresentationStates();for(let c=0;c<o.length;c++)o[c].getActive()&&s.push(i[c]);if(s.length){e.displayCallback(s);return}}e.displayCallback()}t.setDisplayCallback=i=>{e.displayCallback=i,e.displayMapper.setCallback(i?r:null)};const n={...t};t.requestData=(i,s)=>{if(n.requestData(i,s),!e.holeWidth)return;const o=s[0],c=o.getPoints(),u=o.getPointData().getArrays();[c,...u].forEach(T=>{const v=T.getNumberOfValues();T.resize(2*T.getNumberOfTuples());const C=T.getData();for(let S=0;S<v;++S)C[S+v]=C[S]});const f=t.getRepresentationStates(i[0]).length,l=o.getPointData().getArrayByName("scale"),p=o.getPointData().getArrayByName("orientation"),d=[1,1,1],h=[1,0,0,0,1,0,0,0,1];for(let T=0;T<f;++T){const v=T+f,C=(l==null?void 0:l.getTuple(T))??d,S=(p==null?void 0:p.getTuple(T))??h,x=c.getTuple(T);C[2]*=.5,l==null||l.setTuple(T,C),l==null||l.setTuple(v,C);let R=e.holeWidth;t.getScaleInPixels()&&(R*=hr(x,e.displayScaleParams));const O=zl(0,0,.5*C[2]+R);bn(O,O,S),c.setTuple(T,Hl(Ia(),x,O)),c.setTuple(v,Qa(Ia(),x,O))}},t.getSelectedState=(i,s)=>{const o=t.getRepresentationStates();return o[s%o.length]};const a=t.getScale3();t.setScale3((i,s)=>{if(a(i,s),e.infiniteLine){const o=Rt(i,"scale",s.length,"Float32Array",3).getData();for(let c=0;c<s.length;++c)o[3*c+2]=O2}})}function E2(t){return{infiniteLine:!0,glyphResolution:4,holeWidth:0,_pipeline:{glyph:M2.newInstance({resolution:t.glyphResolution??4,initAngle:t.glyphAngle??Math.PI/4,direction:[0,0,1]})},...t}}function Wg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};_g.extend(t,e,E2(r)),y.setGet(t,e,["infiniteLine","glyphResolution","holeWidth"]),m2(t,e)}const D2=y.newInstance(Wg,"vtkLineHandleRepresentation");var V2={newInstance:D2,extend:Wg};function L2(t,e){e.classHierarchy.push("vtkSphereHandleRepresentation"),e.displayMapper=Ug.newInstance(),e.displayActor=dr.newInstance({parentProp:t}),e.displayActor.setMapper(e.displayMapper),e.displayMapper.setInputConnection(t.getOutputPort()),t.addActor(e.displayActor),e.alwaysVisibleActors=[e.displayActor],t.getGlyphResolution=()=>e._pipeline.glyph.getPhiResolution(),t.setGlyphResolution=n=>e._pipeline.glyph.setPhiResolution(n)||e._pipeline.glyph.setThetaResolution(n);function r(n){if(e.displayCallback){const a=[],i=t.getRepresentationStates();for(let s=0;s<i.length;s++)i[s].getActive()&&a.push(n[s]);if(a.length){e.displayCallback(a);return}}e.displayCallback()}t.setDisplayCallback=n=>{e.displayCallback=n,e.displayMapper.setCallback(n?r:null)}}function $g(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};_g.extend(t,e,r),L2(t,e)}const F2=y.newInstance($g,"vtkSphereHandleRepresentation");var Oi={newInstance:F2,extend:$g};const ln={MIDDLE_MOUSE_BUTTON:0,LEFT_MOUSE_BUTTON:1,RIGHT_MOUSE_BUTTON:2},Ge={TranslateAxis:"translateAxis",RotateLine:"rotateLine",TranslateCenter:"translateCenter",TranslateCenterAndUpdatePlanes:"translateCenterAndUpdatePlanes"};P.YZ_PLANE+"",P.XZ_PLANE+"",P.XY_PLANE+"";P.YZ_PLANE,P.XZ_PLANE,P.XY_PLANE;P.YZ_PLANE+"",P.XZ_PLANE+"",P.XY_PLANE+"";const zg=["X","Y","Z"],tr={[P.YZ_PLANE]:"X",[P.XZ_PLANE]:"Y",[P.XY_PLANE]:"Z"},it={X:P.YZ_PLANE,Y:P.XZ_PLANE,Z:P.XY_PLANE},k2=1e-6;function N2(t,e,r,n){const a=[];re(r,e,a),pe(a);const i=[];re(n,e,i),pe(i);const s=[0,0,1];Te(a,i,s),pe(s);const o=[...t],c=[...s];St(c,k2),K.addBounds(o,t[0]+c[0],t[1]+c[0],t[2]+c[1],t[3]+c[1],t[4]+c[2],t[5]+c[2]),K.addBounds(o,t[0]-c[0],t[1]-c[0],t[2]-c[1],t[3]-c[1],t[4]-c[2],t[5]-c[2]);const u=be.newInstance();u.setOrigin(...e),u.setNormal(...s);const g=rs.newInstance();g.setBounds(o);const f=cf.newInstance();f.setCutFunction(u),f.setInputConnection(g.getOutputPort());const l=f.getOutputData();if(l.getNumberOfPoints()===0)return!1;const p=Tu.computeLocalBounds(l.getPoints(),a,i,s);for(let d=0;d<3;d+=1)e[d]=p[0]*a[d]+p[2]*i[d]+p[4]*s[d],r[d]=p[1]*a[d]+p[2]*i[d]+p[4]*s[d],n[d]=p[0]*a[d]+p[3]*i[d]+p[4]*s[d];return!0}function _2(t,e,r){const n=[0,0,0];re(e,t,n);const a=[0,0,0],i=[0,0,0];return K.intersectBox(r,t,n,a,i),a}function xo(t,e,r){const n=[...t];return ot.buildFromRadian().rotate(r,e).apply(n),n}function G2(t){return Object.keys(t.getPlanes()).map(e=>tr[e])}function la(t){return t[0]}function ys(t){return t[3]}function Hg(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:zg;const e=[];return t.forEach(r=>{t.forEach(n=>{r!==n&&e.push(`${r}in${n}`)})}),e}function U2(t){const e=Object.keys(t.getPlanes()).map(r=>tr[r]);return Hg(e)}function wo(t,e){const r=la(e),n=ys(e);return`${G2(t).find(i=>i!==r&&i!==n)}in${n}`}function Ro(t,e,r,n){return St([...t],e*(n?1:r)/2)}function Pt(t,e,r){const n=Object.keys(t.getPlanes()).map(c=>tr[c]),a=n.reduce((c,u)=>(n.filter(g=>u!==g).forEach(g=>{const f=Te(t.getPlanes()[it[u]].normal,t.getPlanes()[it[g]].normal,[]);c[`${u}${g}`]=f,c[`${g}${u}`]=f}),c),{}),i=t.getImage().getBounds(),s=t.getCenter(),o=K.getDiagonalLength(i);t.getCenterHandle().setOrigin(s),Hg(n).forEach(c=>{var h,T,v,C,S,x;const u=la(c),g=ys(c),f=a[`${u}${g}`];t[`getRotationHandle${c}0`]().setOrigin(s),(h=t[`getRotationHandle${c}0`]().getManipulator())==null||h.setHandleOrigin(s),(T=t[`getRotationHandle${c}0`]().getManipulator())==null||T.setHandleNormal(t.getPlanes()[it[u]].normal),t[`getRotationHandle${c}0`]().setOffset(Ro(f,r,o,e)),t[`getRotationHandle${c}1`]().setOrigin(s),(v=t[`getRotationHandle${c}1`]().getManipulator())==null||v.setHandleOrigin(s),(C=t[`getRotationHandle${c}1`]().getManipulator())==null||C.setHandleNormal(t.getPlanes()[it[u]].normal),t[`getRotationHandle${c}1`]().setOffset(Ro(f,-r,o,e));const l=t[`getAxis${c}`]();l.setOrigin(s),(S=l.getManipulator())==null||S.setHandleOrigin(s),(x=l.getManipulator())==null||x.setHandleNormal(t.getPlanes()[it[u]].normal),pe(f);const p=t.getPlanes()[it[g]].normal,d=Te(f,p,[]);l.setRight(p),l.setUp(d),l.setDirection(f)})}function B2(t,e,r,n){t.setNormal(r);const a=re(t.getPoint2(),t.getOrigin(),[]),i=Rc(a,n,r);t.rotate(i,r),t.setCenter(e)}function W2(t,e){e._isDragging=!1;let r=!1,n;y.setGet(t,e,["keepOrthogonality",{type:"object",name:"cursorStyles"}]),t.setCursorStyles({[Ge.TranslateCenter]:"move",[Ge.RotateLine]:"alias",[Ge.TranslateAxis]:"pointer",default:"default"}),t.setEnableTranslation=a=>{e.representations[0].setPickable(a),e.representations[2].setPickable(a)},t.setEnableRotation=a=>{e.representations[1].setPickable(a)},t.getActiveInteraction=()=>e.widgetState.getStatesWithLabel("rotation").includes(e.activeState)?Ge.RotateLine:e.widgetState.getStatesWithLabel("line").includes(e.activeState)?Ge.TranslateAxis:e.widgetState.getStatesWithLabel("center").includes(e.activeState)?Ge.TranslateCenter:null,t.getActiveLineName=()=>U2(e.widgetState).find(a=>e.widgetState.getStatesWithLabel(a).includes(e.activeState)),t.getActiveLineHandle=()=>{var a,i;return(i=(a=e.widgetState)[`getAxis${t.getActiveLineName()}`])==null?void 0:i.call(a)},t.getOtherLineHandle=a=>{var i,s;return(s=(i=e.widgetState)[`getAxis${wo(e.widgetState,a)}`])==null?void 0:s.call(i)},t.getActiveRotationPointName=()=>e.widgetState.getStatesWithLabel("point0").includes(e.activeState)?"point0":e.widgetState.getStatesWithLabel("point1").includes(e.activeState)?"point1":null,t.startScrolling=a=>{a&&(n=a),r=!0,t.startInteraction()},t.endScrolling=()=>{r=!1,t.endInteraction()},t.updateCursor=()=>{const a=t.getCursorStyles();if(a)switch(t.getActiveInteraction()){case Ge.TranslateCenter:e._apiSpecificRenderWindow.setCursor(a.translateCenter);break;case Ge.RotateLine:e._apiSpecificRenderWindow.setCursor(a.rotateLine);break;case Ge.TranslateAxis:e._apiSpecificRenderWindow.setCursor(a.translateAxis);break;default:e._apiSpecificRenderWindow.setCursor(a.default);break}},t.handleLeftButtonPress=a=>{var i,s;if(e.activeState&&e.activeState.getActive()){e._isDragging=!0;const o=e.viewType,c=e.widgetState.getPlanes()[o].normal,u=((s=(i=e.activeState)==null?void 0:i.getManipulator)==null?void 0:s.call(i))??e.manipulator;u.setWidgetOrigin(e.widgetState.getCenter()),u.setWidgetNormal(c);const{worldCoords:g}=u.handleEvent(a,e._apiSpecificRenderWindow);n=g,t.startInteraction()}else if(e.widgetState.getScrollingMethod()===ln.LEFT_MOUSE_BUTTON)t.startScrolling(a.position);else return y.VOID;return y.EVENT_ABORT},t.handleMouseMove=a=>{if(e._isDragging)return t.handleEvent(a);if(r&&n.y!==a.position.y){const i=n.y-a.position.y;t.translateCenterOnPlaneDirection(i),n=a.position,t.invokeInteractionEvent(t.getActiveInteraction())}return y.VOID},t.handleLeftButtonRelease=()=>{(e._isDragging||r)&&t.endScrolling(),e._isDragging=!1,e.widgetState.deactivate()},t.handleRightButtonPress=a=>{e.widgetState.getScrollingMethod()===ln.RIGHT_MOUSE_BUTTON&&t.startScrolling(a.position)},t.handleRightButtonRelease=()=>{e.widgetState.getScrollingMethod()===ln.RIGHT_MOUSE_BUTTON&&t.endScrolling()},t.handleStartMouseWheel=()=>{t.startInteraction()},t.handleMouseWheel=a=>{const i=a.spinY;return r=!0,t.translateCenterOnPlaneDirection(i),t.invokeInteractionEvent(Ge.TranslateCenter),r=!1,y.EVENT_ABORT},t.handleEndMouseWheel=()=>{t.endScrolling()},t.handleMiddleButtonPress=a=>{e.widgetState.getScrollingMethod()===ln.MIDDLE_MOUSE_BUTTON&&t.startScrolling(a.position)},t.handleMiddleButtonRelease=()=>{e.widgetState.getScrollingMethod()===ln.MIDDLE_MOUSE_BUTTON&&t.endScrolling()},t.handleEvent=a=>{if(e.activeState.getActive()){const i=t.getActiveInteraction();return t[i](a),t.invokeInteractionEvent(i),y.EVENT_ABORT}return y.VOID},t.startInteraction=()=>{t.invokeStartInteractionEvent(),t.getViewWidgets().forEach(a=>{a.getInteractor().requestAnimation(t)})},t.endInteraction=()=>{t.invokeEndInteractionEvent(),t.getViewWidgets().forEach(a=>{a.getInteractor().cancelAnimation(t)})},t.translateCenterOnPlaneDirection=a=>{const i=e.widgetState.getPlanes()[e.viewType].normal,s=e.widgetState.getCenter(),c=e.widgetState.getImage().getSpacing(),u=i.map(p=>Math.abs(p)),g=u.indexOf(Math.max(...u)),f=a*c[g]/Math.abs(i[g]);let l=[s[0]+f*i[0],s[1]+f*i[1],s[2]+f*i[2]];l=t.getBoundedCenter(l),e.widgetState.setCenter(l),Pt(e.widgetState,e._factory.getScaleInPixels(),e._factory.getRotationHandlePosition())},t[Ge.TranslateAxis]=a=>{var d,h,T,v;const i=t.getActiveLineHandle(),s=t.getActiveLineName(),o=Qe(i.getOrigin(),i.getDirection(),[]),c=i.getDirection();pe(c);const u=t.getOtherLineHandle(s),g=e.widgetState.getCenter(),f=((h=(d=e.activeState)==null?void 0:d.getManipulator)==null?void 0:h.call(d))??e.manipulator;let l=null,p=[];if((v=(T=e.activeState)==null?void 0:T.getManipulator)!=null&&v.call(T)){l=f.handleEvent(a,e._apiSpecificRenderWindow).worldCoords;const C=re(l,n,[]);Qe(g,C,p)}else if(u){const C=u.getDirection();pe(C);const S=C,x=b(c,C);(x===1||x===-1)&&Te(c,f.getWidgetNormal(),S);const R=[];l=f.handleEvent(a,e._apiSpecificRenderWindow).worldCoords,Ue.distanceToLine(l,i.getOrigin(),o,R);const O=re(l,R,[]),w=b(O,S);p=Tt(g,S,w,p)}p=t.getBoundedCenter(p),e.widgetState.setCenter(p),Pt(e.widgetState,e._factory.getScaleInPixels(),e._factory.getRotationHandlePosition()),n=l},t.getBoundedCenter=a=>{const i=e.widgetState.getCenter(),s=e.widgetState.getImage().getBounds();return K.containsPoint(s,...a)?a:_2(a,i,s)},t[Ge.TranslateCenter]=a=>{var u,g;const i=((g=(u=e.activeState)==null?void 0:u.getManipulator)==null?void 0:g.call(u))??e.manipulator,{worldCoords:s}=i.handleEvent(a,e._apiSpecificRenderWindow),o=re(s,n,[]);n=s;let c=Qe(e.widgetState.getCenter(),o,[]);c=t.getBoundedCenter(c),e.widgetState.setCenter(c),Pt(e.widgetState,e._factory.getScaleInPixels(),e._factory.getRotationHandlePosition())},t[Ge.RotateLine]=a=>{var d,h;const i=t.getActiveLineHandle(),s=((h=(d=e.activeState)==null?void 0:d.getManipulator)==null?void 0:h.call(d))??e.manipulator,o=s.getWidgetNormal(),{worldCoords:c}=s.handleEvent(a,e._apiSpecificRenderWindow);if(!c||!c.length)return;const u=e.widgetState.getCenter(),g=[0,0,0];re(c,u,g),pe(g);const f=i.getDirection();pe(f);const l=t.getActiveRotationPointName();(l==="point1"||!l&&b(g,f)<0)&&St(f,-1);const p=Rc(f,g,o);t.rotateLineInView(t.getActiveLineName(),p)},t.rotateLineInView=(a,i)=>{const s=it[la(a)],o=it[ys(a)],c=e.widgetState.getPlanes()[o].normal;if(t.rotatePlane(s,i,c),t.getKeepOrthogonality()){const u=wo(e.widgetState,a),g=la(u);t.rotatePlane(it[g],i,c)}Pt(e.widgetState,e._factory.getScaleInPixels(),e._factory.getRotationHandlePosition())},t.rotatePlane=(a,i,s)=>{const{normal:o,viewUp:c}=e.widgetState.getPlanes()[a],u=xo(o,s,i),g=xo(c,s,i);e.widgetState.getPlanes()[a]={normal:u,viewUp:g}},t.setViewPlane=(a,i,s)=>{let o=s;o==null&&(o=e.widgetState.getPlanes()[a].viewUp),e.widgetState.getPlanes()[a]={normal:i,viewUp:o},Pt(e.widgetState,e._factory.getScaleInPixels(),e._factory.getRotationHandlePosition())}}const Mo={X:{normal:[1,0,0],viewUp:[0,0,1],color3:[255,0,0]},Y:{normal:[0,-1,0],viewUp:[0,0,1],color3:[0,255,0]},Z:{normal:[0,0,-1],viewUp:[0,-1,0],color3:[0,0,255]}},Oo={X:[255,0,0],Y:[0,255,0],Z:[0,0,255]};function $2(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:zg;const e=wi.createBuilder().addField({name:"center",initialValue:[0,0,0]}).addField({name:"image",initialValue:null}).addField({name:"activeViewType",initialValue:null}).addField({name:"planes",initialValue:t.reduce((r,n)=>({...r,[it[n]]:{normal:Mo[n].normal,viewUp:Mo[n].viewUp}}),{})}).addField({name:"scrollingMethod",initialValue:ln.MIDDLE_MOUSE_BUTTON}).addField({name:"cameraOffsets",initialValue:{}}).addField({name:"viewUpFromViewType",initialValue:{}}).addStateFromMixin({labels:["handles","sphere","center"],mixins:["origin","color3","scale1","visible","manipulator"],name:"centerHandle",initialValues:{scale1:30,color3:[255,255,255]}});return t.reduce((r,n)=>t.filter(a=>a!==n).reduce((a,i)=>{a.addStateFromMixin({labels:["handles","line",`lineIn${n}`,`${i}in${n}`],mixins:["origin","color3","scale3","orientation","visible","manipulator"],name:`axis${i}in${n}`,initialValues:{scale3:[4,4,4],color3:Oo[i]}});for(let s=0;s<2;++s)a.addStateFromMixin({labels:["handles","sphere","rotation",`rotationIn${n}`,`${i}in${n}`,`point${s}`],mixins:["origin","color3","scale1","visible","manipulator"],name:`rotationHandle${i}in${n}${s}`,initialValues:{scale1:30,color3:Oo[i]}});return a},r),e),e.build()}const z2=2147483647,{vtkErrorMacro:mo}=y;function H2(t,e){e.classHierarchy.push("vtkResliceCursorWidget"),e.methodsToLink=["scaleInPixels","holeWidth","infiniteLine"];function r(o){const c=e.widgetState.getImage().getBounds(),u=t.getWidgetState().getCenter(),g=e.widgetState.getImage().getCenter(),f=[];for(let p=0;p<3;p++)f[p]=-Math.abs(u[p]-g[p]),f[p]*=2;const l=Co.newInstance();return o===P.XZ_PLANE?(l.setOrigin(c[0]+f[0],u[1],c[4]+f[2]),l.setPoint1(c[1]-f[0],u[1],c[4]+f[2]),l.setPoint2(c[0]+f[0],u[1],c[5]-f[2])):o===P.XY_PLANE?(l.setOrigin(c[0]+f[0],c[2]+f[1],u[2]),l.setPoint1(c[1]-f[0],c[2]+f[1],u[2]),l.setPoint2(c[0]+f[0],c[3]-f[1],u[2])):o===P.YZ_PLANE&&(l.setOrigin(u[0],c[2]+f[1],c[4]+f[2]),l.setPoint1(u[0],c[3]-f[1],c[4]+f[2]),l.setPoint2(u[0],c[2]+f[1],c[5]-f[2])),l}function n(o,c){const u=c.getActiveCamera().getFocalPoint(),g=e.widgetState.getCenter(),l=c.getRenderWindow().getViews()[0].getViewportSize(c),p=l[0]/l[1],d=c.worldToNormalizedDisplay(...u,p),h=c.worldToNormalizedDisplay(...g,p),T=re(d,h,[0,0,0]),v=e.widgetState.getCameraOffsets();v[o]=T,e.widgetState.setCameraOffsets(v)}function a(o,c,u,g,f){const l=o.getActiveCamera().getFocalPoint(),p=o.getActiveCamera().getDistance(),d=Tt(l,c,p,[0,0,0]);let h=l;if(g&&(h=be.intersectWithLine(l,d,e.widgetState.getCenter(),c).x),f){const C=e.widgetState.getCenter(),x=o.getRenderWindow().getViews()[0].getViewportSize(o),R=x[0]/x[1],O=o.worldToNormalizedDisplay(...C,R),w=e.widgetState.getCameraOffsets()[u],m=Qe(O,w,[0,0,0]),E=o.normalizedDisplayToWorld(...m,R),M=be.intersectWithLine(E,d,C,c);h[0]=M.x[0],h[1]=M.x[1],h[2]=M.x[2]}o.getActiveCamera().setFocalPoint(h[0],h[1],h[2]);const T=Tt(h,c,p,[0,0,0]);o.getActiveCamera().setPosition(T[0],T[1],T[2]);const v=e.widgetState.getImage().getBounds();g&&o.resetCamera(v),o.resetCameraClippingRange(v)}function i(o){return t.getViewIds().map(c=>t.getWidgetForView({viewId:c})).find(c=>c.getViewType()===o)}function s(o){const c=i(o);return c?c.getRepresentations():[]}t.getRepresentationsForViewType=o=>{switch(o){case P.XY_PLANE:case P.XZ_PLANE:case P.YZ_PLANE:return[{builder:V2,labels:[`lineIn${tr[o]}`],initialValues:{useActiveColor:!1,scaleInPixels:e.scaleInPixels}},{builder:Oi,labels:[`rotationIn${tr[o]}`],initialValues:{useActiveColor:!1,scaleInPixels:e.scaleInPixels,lighting:!1}},{builder:Oi,labels:["center"],initialValues:{useActiveColor:!1,scaleInPixels:e.scaleInPixels,lighting:!1}}];case P.DEFAULT:case P.GEOMETRY:case P.SLICE:case P.VOLUME:default:return[]}},t.setImage=o=>{e.widgetState.setImage(o);const c=o.getCenter();t.setCenter(c)},t.setCenter=o=>{e.widgetState.setCenter(o),Pt(e.widgetState,e.scaleInPixels,e.rotationHandlePosition),t.modified()},t.updateCameraPoints=(o,c,u,g)=>{t.resetCamera(o,c,u,!g),g&&n(c,o)},t.resetCamera=(o,c,u,g)=>{const f=e.widgetState.getImage().getCenter(),l=o.getActiveCamera().getFocalPoint(),p=o.getActiveCamera().getPosition(),d=Math.sqrt(Ye(p,l)),h=t.getPlaneNormalFromViewType(c),T=u?f:l,v=Tt(T,h,d,[0,0,0]);o.getActiveCamera().setFocalPoint(...T),o.getActiveCamera().setPosition(...v),o.getActiveCamera().setViewUp(e.widgetState.getPlanes()[c].viewUp),a(o,h,c,u,g)},t.getPlaneSource=o=>{const c=r(o),{normal:u,viewUp:g}=e.widgetState.getPlanes()[o];B2(c,e.widgetState.getCenter(),u,g);const f=[...c.getOrigin()],l=[...c.getPoint1()],p=[...c.getPoint2()];return N2(e.widgetState.getImage().getBounds(),f,l,p),c.setOrigin(...f),c.setPoint1(...l),c.setPoint2(...p),c},t.getResliceAxes=o=>{const c=t.getPlaneSource(o),{normal:u}=e.widgetState.getPlanes()[o],g=c.getOrigin(),f=c.getPoint1(),l=[];re(f,g,l),pe(l);const p=c.getPoint2(),d=[];re(p,g,d),pe(d);const h=X(new Float64Array(16));for(let T=0;T<3;T++)h[T]=l[T],h[4+T]=d[T],h[8+T]=u[T],h[12+T]=g[T];return h},t.updateReslicePlane=(o,c)=>{const u=e.widgetState.getImage().getSpacing(),g=t.getPlaneSource(c),f=t.getResliceAxes(c),l=g.getOrigin(),p=g.getPoint1(),d=re(p,l,[]),h=pe(d),T=g.getPoint2(),v=re(T,l,[]),C=pe(v),S=Math.abs(d[0]*u[0])+Math.abs(d[1]*u[1])+Math.abs(d[2]*u[2]),x=Math.abs(v[0]*u[0])+Math.abs(v[1]*u[1])+Math.abs(v[2]*u[2]);let R=0,O=0;const w=S===0?Number.MAX_SAFE_INTEGER:h/S,m=z2>>1;if(w>m)mo("Invalid X extent: ",w," on view type : ",c),R=0;else for(R=1;R<w;)R<<=1;const E=x===0?Number.MAX_SAFE_INTEGER:C/x;if(E>m)mo("Invalid Y extent:",E," on view type : ",c),O=0;else for(O=1;O<E;)O<<=1;const M=R===0?1:h/R,D=O===0?1:C/O;let N=o.setResliceAxes(f);return N=o.setOutputSpacing([M,D,1])||N,N=o.setOutputOrigin([.5*M,.5*D,0])||N,N=o.setOutputExtent([0,R-1,0,O-1,0,0])||N,N},t.getPlaneSourceFromViewType=o=>{const c=Co.newInstance(),u=t.getWidgetState().getCenter(),g=t.getPlaneNormalFromViewType(o);return c.setNormal(g),c.setOrigin(u),c},t.getPlaneNormalFromViewType=o=>t.getWidgetState().getPlanes()[o].normal,t.getOtherPlaneNormals=o=>[P.YZ_PLANE,P.XZ_PLANE,P.XY_PLANE].filter(c=>c!==o).map(c=>t.getPlaneNormalFromViewType(c)),t.getResliceMatrix=()=>{const o=X(new Float64Array(16));for(let g=0;g<3;g++)o[4*g+0]=t.getPlaneNormalFromViewType(P.YZ_PLANE)[g],o[4*g+1]=t.getPlaneNormalFromViewType(P.XZ_PLANE)[g],o[4*g+2]=t.getPlaneNormalFromViewType(P.XY_PLANE)[g];const c=t.getWidgetState().getCenter();return ot.buildFromRadian().translate(...c).multiply(o).translate(...St([...c],-1)).getMatrix()},t.getDisplayScaleParams=()=>[P.YZ_PLANE,P.XZ_PLANE,P.XY_PLANE].reduce((o,c)=>{var u,g;return o[c]=(g=(u=s(c)[0])==null?void 0:u.getDisplayScaleParams)==null?void 0:g.call(u),o},{}),t.setScaleInPixels=y.chain(t.setScaleInPixels,o=>{t.getViewWidgets().forEach(c=>c.setScaleInPixels(o)),Pt(e.widgetState,e.scaleInPixels,e.rotationHandlePosition)}),t.getPlaneExtremities=o=>{const c=t.getWidgetState().getPlanes()[o].normal,u=K.getDiagonalLength(t.getWidgetState().getImage().getBounds()),g=Tt(t.getWidgetState().getCenter(),c,-u,[]),f=Tt(t.getWidgetState().getCenter(),c,u,[]),l=jw.intersectWithLine(t.getWidgetState().getImage().getBounds(),g,f);return[l.x1,l.x2]}}const j2=t=>({behavior:W2,widgetState:$2(t.planes),rotationHandlePosition:.5,scaleInPixels:!0,manipulator:Ci.newInstance(),...t});function jg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,j2(r)),bf.extend(t,e,r),y.setGet(t,e,["scaleInPixels","rotationHandlePosition","manipulator"]),H2(t,e)}const b2=y.newInstance(jg,"vtkResliceCursorWidget");var LM={newInstance:b2,extend:jg};function K2(t,e){e.classHierarchy.push("vtkMouseRangeManipulator");const r=new Map;function n(i,s){return s*((i.max-i.min)/(i.step+1))}function a(i,s){const o=i.getValue();let c=i.exponentialScroll?i.scale**Math.log2(Math.abs(e.interactionNetDelta)+2):i.scale;c=Math.abs(c)*Math.sign(i.scale);const u=s*c+r.get(i),g=Math.floor(Math.abs(u/i.step));let f=o+i.step*g*Math.sign(u);f=Math.max(f,i.min),f=Math.min(f,i.max),f!==o?(i.setValue(f),r.set(i,0)):f===i.min&&u<0||f===i.max&&u>0?r.set(i,0):r.set(i,u)}t.setHorizontalListener=function(i,s,o,c,u){let g=arguments.length>5&&arguments[5]!==void 0?arguments[5]:1,f=arguments.length>6&&arguments[6]!==void 0?arguments[6]:!1;const l=Number.isFinite(c)?()=>c:c;e.horizontalListener={min:i,max:s,step:o,getValue:l,setValue:u,scale:g,exponentialScroll:f},r.set(e.horizontalListener,0),t.modified()},t.setVerticalListener=function(i,s,o,c,u){let g=arguments.length>5&&arguments[5]!==void 0?arguments[5]:1,f=arguments.length>6&&arguments[6]!==void 0?arguments[6]:!1;const l=Number.isFinite(c)?()=>c:c;e.verticalListener={min:i,max:s,step:o,getValue:l,setValue:u,scale:g,exponentialScroll:f},r.set(e.verticalListener,0),t.modified()},t.setScrollListener=function(i,s,o,c,u){let g=arguments.length>5&&arguments[5]!==void 0?arguments[5]:1,f=arguments.length>6&&arguments[6]!==void 0?arguments[6]:!1;o<0&&rr("Value of step cannot be negative. If you want to invert the scrolling direction, use a negative scale value instead.");const l=Math.abs(o),p=Number.isFinite(c)?()=>c:c;e.scrollListener={min:i,max:s,step:l,getValue:p,setValue:u,scale:g,exponentialScroll:f},r.set(e.scrollListener,0),t.modified()},t.removeHorizontalListener=()=>{e.horizontalListener&&(r.delete(e.horizontalListener),delete e.horizontalListener,t.modified())},t.removeVerticalListener=()=>{e.verticalListener&&(r.delete(e.verticalListener),delete e.verticalListener,t.modified())},t.removeScrollListener=()=>{e.scrollListener&&(r.delete(e.scrollListener),delete e.scrollListener,t.modified())},t.removeAllListeners=()=>{t.removeHorizontalListener(),t.removeVerticalListener(),t.removeScrollListener()},t.onButtonDown=(i,s,o)=>{e.previousPosition=o,e.interactionNetDelta=0;const c=i.getView(),u=c.getContainerSize()[0]/c.getSize()[0],g=c.getViewportSize(s);e.containerSize=g.map(f=>f*u)},t.onButtonUp=i=>{i.exitPointerLock()},t.startPointerLockEvent=(i,s)=>{const o=g=>{t.onPointerLockMove(i,s,g)};document.addEventListener("mousemove",o);let c=null;const u=()=>{document.removeEventListener("mousemove",o),c==null||c.unsubscribe()};c=i==null?void 0:i.onEndPointerLock(u)},t.onPointerLockMove=(i,s,o)=>{i.isPointerLocked()&&e.previousPosition!=null&&(e.previousPosition.x+=o.movementX,e.previousPosition.y+=o.movementY,t.onMouseMove(i,s,e.previousPosition))},t.onMouseMove=(i,s,o)=>{if(!(!e.verticalListener&&!e.horizontalListener)&&(e.usePointerLock&&!i.isPointerLocked()&&(i.requestPointerLock(),t.startPointerLockEvent(i,s)),!!o)){if(e.horizontalListener){const c=(o.x-e.previousPosition.x)/e.containerSize[0],u=n(e.horizontalListener,c);e.interactionNetDelta+=u,a(e.horizontalListener,u)}if(e.verticalListener){const c=(o.y-e.previousPosition.y)/e.containerSize[1],u=n(e.verticalListener,c);e.interactionNetDelta+=u,a(e.verticalListener,u)}e.previousPosition=o}},t.onScroll=(i,s,o)=>{!e.scrollListener||!o||(e.interactionNetDelta+=o*e.scrollListener.step,a(e.scrollListener,o*e.scrollListener.step))},t.onStartScroll=()=>{e.interactionNetDelta=0}}const X2={horizontalListener:null,verticalListener:null,scrollListener:null};function bg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,X2,r),y.obj(t,e),Oa.extend(t,e,r),y.setGet(t,e,["usePointerLock"]),K2(t,e)}const A2=y.newInstance(bg,"vtkMouseRangeManipulator");var FM={newInstance:A2,extend:bg};function Y2(t,e){e.classHierarchy.push("vtkMouseCameraTrackballZoomToMouseManipulator");const r=t.onButtonDown;t.onButtonDown=(n,a,i)=>{r(n,a,i),e.zoomPosition=i},t.onMouseMove=(n,a,i)=>{if(!i)return;const o=(e.previousPosition.y-i.y)*e.zoomScale;go.dollyToPosition(1-o,e.zoomPosition,a,n),n.getLightFollowCamera()&&a.updateLightsGeometryToFollowCamera(),e.previousPosition=i},t.onScroll=(n,a,i,s)=>{if(!i||!s)return;const o=1-i*.1;go.dollyToPosition(o,s,a,n),n.getLightFollowCamera()&&a.updateLightsGeometryToFollowCamera()}}const q2={zoomPosition:null};function Kg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,q2,r),IS.extend(t,e,r),Y2(t,e)}const Z2=y.newInstance(Kg,"vtkMouseCameraTrackballZoomToMouseManipulator");var kM={newInstance:Z2,extend:Kg};function Xg(t,e,r){const n=r.getCurrentImage(),a=n.getExtent(),i=[a[0],a[2],a[4]],{ijkMode:s}=r.getClosestIJKAxis();let o=r.isA("vtkImageArrayMapper")?r.getSubSlice():r.getSlice();s!==r.getSlicingMode()&&(o=r.getSliceAtPosition(o)),i[s]+=o;const c=[0,0,0];n.indexToWorld(i,c),i[s]+=1;const u=[0,0,0];n.indexToWorld(i,u),u[0]-=c[0],u[1]-=c[1],u[2]-=c[2],Ct(u,u);const g=be.intersectWithLine(t,e,c,u);if(g.intersection){const f=g.x,l=[0,0,0];return n.worldToIndex(f,l),{t:g.t,absoluteIJK:l}}return null}function P2(t,e,r){const n=Xg(t,e,r);if(n){const i=r.getCurrentImage().getExtent(),s=[Math.round(n.absoluteIJK[0]),Math.round(n.absoluteIJK[1]),Math.round(n.absoluteIJK[2])];return s[0]<i[0]||s[0]>i[1]||s[1]<i[2]||s[1]>i[3]||s[2]<i[4]||s[2]>i[5]?null:{t:n.t,ijk:s}}return null}function J2(t,e,r){const n=Xg(t,e,r);if(n){const i=r.getCurrentImage().getExtent(),s=n.absoluteIJK,o=[Math.floor(s[0]),Math.floor(s[1]),Math.floor(s[2])];if(o[0]<i[0]||o[0]>i[1]-1||o[1]<i[2]||o[1]>i[3]-1||o[2]<i[4]||o[2]>(i[5]?i[5]-1:i[5]))return null;const c=[s[0]-o[0],s[1]-o[1],s[2]-o[2]];return{t:n.t,ijk:o,pCoords:c}}return null}const{staticOffsetAPI:Q2,otherStaticMethods:I2}=Rn,{SlicingMode:I}=ss;function eR(t,e){e.classHierarchy.push("vtkImageMapper"),t.getSliceAtPosition=n=>{const a=t.getCurrentImage();let i;if(n.length===3)i=n;else if(Number.isFinite(n)){const g=a.getBounds();switch(e.slicingMode){case I.X:i=[n,(g[3]+g[2])/2,(g[5]+g[4])/2];break;case I.Y:i=[(g[1]+g[0])/2,n,(g[5]+g[4])/2];break;case I.Z:i=[(g[1]+g[0])/2,(g[3]+g[2])/2,n];break}}const s=[0,0,0];a.worldToIndex(i,s);const o=a.getExtent(),{ijkMode:c}=t.getClosestIJKAxis();let u=0;switch(c){case I.I:u=Je(s[0],o[0],o[1]);break;case I.J:u=Je(s[1],o[2],o[3]);break;case I.K:u=Je(s[2],o[4],o[5]);break;default:return 0}return u},t.setSliceFromCamera=n=>{const a=n.getFocalPoint();switch(e.slicingMode){case I.I:case I.J:case I.K:{const i=t.getSliceAtPosition(a);t.setSlice(i)}break;case I.X:t.setSlice(a[0]);break;case I.Y:t.setSlice(a[1]);break;case I.Z:t.setSlice(a[2]);break}},t.setXSlice=n=>{t.setSlicingMode(I.X),t.setSlice(n)},t.setYSlice=n=>{t.setSlicingMode(I.Y),t.setSlice(n)},t.setZSlice=n=>{t.setSlicingMode(I.Z),t.setSlice(n)},t.setISlice=n=>{t.setSlicingMode(I.I),t.setSlice(n)},t.setJSlice=n=>{t.setSlicingMode(I.J),t.setSlice(n)},t.setKSlice=n=>{t.setSlicingMode(I.K),t.setSlice(n)},t.getSlicingModeNormal=()=>{const n=[0,0,0],a=t.getCurrentImage().getDirection();switch(e.slicingMode){case I.X:n[0]=1;break;case I.Y:n[1]=1;break;case I.Z:n[2]=1;break;case I.I:$r(a,[1,0,0],n);break;case I.J:$r(a,[0,1,0],n);break;case I.K:$r(a,[0,0,1],n);break}return n};function r(){let n;switch(e.slicingMode){case I.X:n=0;break;case I.Y:n=1;break;case I.Z:n=2;break;default:e.closestIJKAxis={ijkMode:e.slicingMode,flip:!1};return}const a=t.getCurrentImage().getDirection(),i=$c(a);let s=0;for(;s<3&&i[n+3*s]===0;++s);const o=i[n+3*s]<0;e.closestIJKAxis={ijkMode:s,flip:o}}t.setSlicingMode=n=>{e.slicingMode!==n&&(e.slicingMode=n,t.getCurrentImage()&&r(),t.modified())},t.getClosestIJKAxis=()=>((e.closestIJKAxis===void 0||e.closestIJKAxis.ijkMode===I.NONE)&&t.getCurrentImage()&&r(),e.closestIJKAxis),t.getBounds=()=>{const n=t.getCurrentImage();if(!n)return xt();if(!e.useCustomExtents)return n.getBounds();const a=e.customDisplayExtent.slice(),{ijkMode:i}=t.getClosestIJKAxis();let s=e.slice;switch(i!==e.slicingMode&&(s=t.getSliceAtPosition(e.slice)),i){case I.I:a[0]=s,a[1]=s;break;case I.J:a[2]=s,a[3]=s;break;case I.K:a[4]=s,a[5]=s;break}return n.extentToBounds(a)},t.getBoundsForSlice=function(){let n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:e.slice,a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0;const i=t.getCurrentImage();if(!i)return xt();const s=i.getSpatialExtent(),{ijkMode:o}=t.getClosestIJKAxis();let c=n;switch(o!==e.slicingMode&&(c=t.getSliceAtPosition(n)),o){case I.I:s[0]=c-a,s[1]=c+a;break;case I.J:s[2]=c-a,s[3]=c+a;break;case I.K:s[4]=c-a,s[5]=c+a;break}return i.extentToBounds(s)},t.intersectWithLineForPointPicking=(n,a)=>P2(n,a,t),t.intersectWithLineForCellPicking=(n,a)=>J2(n,a,t),t.getCurrentImage=()=>t.getInputData()}const tR={slicingMode:I.NONE,closestIJKAxis:{ijkMode:I.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function Ag(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,tR,r),xg.extend(t,e,r),y.get(t,e,["slicingMode"]),y.setGet(t,e,["closestIJKAxis","renderToRectangle","sliceAtFocalPoint","preferSizeOverAccuracy"]),Rn.implementCoincidentTopologyMethods(t,e),eR(t,e)}const nR=y.newInstance(Ag,"vtkImageMapper");var NM={newInstance:nR,extend:Ag,...Q2,...I2,...ss};const rR={RGB:0,HSV:1,LAB:2,DIVERGING:3},aR={LINEAR:0,LOG10:1};var Yg={ColorSpace:rR,Scale:aR};const{ColorSpace:He,Scale:Cs}=Yg,{ScalarMappingTarget:Ur}=Ii,{vtkDebugMacro:iR,vtkErrorMacro:lt,vtkWarningMacro:sR}=y;function Eo(t,e){const r=t[0],n=t[1],a=t[2],i=Math.sqrt(r*r+n*n+a*a),s=i>.001?Math.acos(r/i):0,o=s>.001?Math.atan2(a,n):0;e[0]=i,e[1]=s,e[2]=o}function oR(t,e){const r=t[0],n=t[1],a=t[2];e[0]=r*Math.cos(n),e[1]=r*Math.sin(n)*Math.cos(a),e[2]=r*Math.sin(n)*Math.sin(a)}function Do(t,e){if(t[0]>=e-.1)return t[2];const r=t[1]*Math.sqrt(e*e-t[0]*t[0])/(t[0]*Math.sin(t[1]));return t[2]>-.3*Math.PI?t[2]+r:t[2]-r}function cR(t,e){let r=t-e;for(r<0&&(r=-r);r>=2*Math.PI;)r-=2*Math.PI;return r>Math.PI&&(r=2*Math.PI-r),r}function Vo(t,e,r,n){const a=[],i=[];It(e,a),It(r,i);const s=[],o=[];Eo(a,s),Eo(i,o);let c=t;if(s[1]>.05&&o[1]>.05&&cR(s[2],o[2])>.33*Math.PI){let f=Math.max(s[0],o[0]);f=Math.max(88,f),t<.5?(o[0]=f,o[1]=0,o[2]=0,c*=2):(s[0]=f,s[1]=0,s[2]=0,c=2*c-1)}s[1]<.05&&o[1]>.05?s[2]=Do(o,s[0]):o[1]<.05&&s[1]>.05&&(o[2]=Do(s,o[0]));const u=[];u[0]=(1-c)*s[0]+c*o[0],u[1]=(1-c)*s[1]+c*o[1],u[2]=(1-c)*s[2]+c*o[2];const g=[];oR(u,g),Qr(g,n)}function uR(t,e){e.classHierarchy.push("vtkColorTransferFunction"),t.getSize=()=>e.nodes.length,t.addRGBPoint=(r,n,a,i)=>t.addRGBPointLong(r,n,a,i,.5,0),t.addRGBPointLong=function(r,n,a,i){let s=arguments.length>4&&arguments[4]!==void 0?arguments[4]:.5,o=arguments.length>5&&arguments[5]!==void 0?arguments[5]:0;if(s<0||s>1)return lt("Midpoint outside range [0.0, 1.0]"),-1;if(o<0||o>1)return lt("Sharpness outside range [0.0, 1.0]"),-1;e.allowDuplicateScalars||t.removePoint(r);const c={x:r,r:n,g:a,b:i,midpoint:s,sharpness:o};e.nodes.push(c),t.sortAndUpdateRange();let u=0;for(;u<e.nodes.length&&e.nodes[u].x!==r;u++);return u<e.nodes.length?u:-1},t.addHSVPoint=(r,n,a,i)=>t.addHSVPointLong(r,n,a,i,.5,0),t.addHSVPointLong=function(r,n,a,i){let s=arguments.length>4&&arguments[4]!==void 0?arguments[4]:.5,o=arguments.length>5&&arguments[5]!==void 0?arguments[5]:0;const c=[];return Yt([n,a,i],c),t.addRGBPoint(r,c[0],c[1],c[2],s,o)},t.setNodes=r=>{if(e.nodes!==r){const n=JSON.stringify(e.nodes);e.nodes=r;const a=JSON.stringify(e.nodes);if(t.sortAndUpdateRange()||n!==a)return t.modified(),!0}return!1},t.sortAndUpdateRange=()=>{const r=JSON.stringify(e.nodes);e.nodes.sort((i,s)=>i.x-s.x);const n=JSON.stringify(e.nodes),a=t.updateRange();return!a&&r!==n?(t.modified(),!0):a},t.updateRange=()=>{const r=[2];r[0]=e.mappingRange[0],r[1]=e.mappingRange[1];const n=e.nodes.length;return n?(e.mappingRange[0]=e.nodes[0].x,e.mappingRange[1]=e.nodes[n-1].x):(e.mappingRange[0]=0,e.mappingRange[1]=0),r[0]===e.mappingRange[0]&&r[1]===e.mappingRange[1]?!1:(t.modified(),!0)},t.removePoint=r=>{let n=0;for(;n<e.nodes.length&&e.nodes[n].x!==r;n++);const a=n;if(n>=e.nodes.length)return-1;let i=!1;return e.nodes.splice(n,1),(n===0||n===e.nodes.length)&&(i=t.updateRange()),i||t.modified(),a},t.movePoint=(r,n)=>{if(r!==n){t.removePoint(n);for(let a=0;a<e.nodes.length;a++)if(e.nodes[a].x===r){e.nodes[a].x=n,t.sortAndUpdateRange();break}}},t.removeAllPoints=()=>{e.nodes=[],t.sortAndUpdateRange()},t.addRGBSegment=(r,n,a,i,s,o,c,u)=>{t.sortAndUpdateRange();for(let g=0;g<e.nodes.length;)e.nodes[g].x>=r&&e.nodes[g].x<=s?e.nodes.splice(g,1):g++;t.addRGBPointLong(r,n,a,i,.5,0),t.addRGBPointLong(s,o,c,u,.5,0),t.modified()},t.addHSVSegment=(r,n,a,i,s,o,c,u)=>{const g=[n,a,i],f=[o,c,u],l=[],p=[];Yt(g,l),Yt(f,p),t.addRGBSegment(r,l[0],l[1],l[2],s,p[0],p[1],p[2])},t.mapValue=r=>{const n=[];return t.getColor(r,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},t.getColor=(r,n)=>{if(e.indexedLookup){const a=t.getSize(),i=t.getAnnotatedValueIndexInternal(r);if(i<0||a===0){const s=t.getNanColorByReference();n[0]=s[0],n[1]=s[1],n[2]=s[2]}else{const s=[];t.getNodeValue(i%a,s),n[0]=s[1],n[1]=s[2],n[2]=s[3]}return}t.getTable(r,r,1,n)},t.getRedValue=r=>{const n=[];return t.getColor(r,n),n[0]},t.getGreenValue=r=>{const n=[];return t.getColor(r,n),n[1]},t.getBlueValue=r=>{const n=[];return t.getColor(r,n),n[2]},t.getTable=(r,n,a,i)=>{const s=Number(r),o=Number(n);if(Ir(s)||Ir(o)){for(let E=0;E<a;E++)i[E*3+0]=e.nanColor[0],i[E*3+1]=e.nanColor[1],i[E*3+2]=e.nanColor[2];return}let c=0;const u=e.nodes.length;let g=0,f=0,l=0;u!==0&&(g=e.nodes[u-1].r,f=e.nodes[u-1].g,l=e.nodes[u-1].b);let p=0,d=0,h=0;const T=[0,0,0],v=[0,0,0];let C=0,S=0;const x=[];let R=e.scale===Cs.LOG10;R&&(R=e.mappingRange[0]>0);let O=0,w=0,m=0;R&&(O=Math.log10(s),w=Math.log10(o));for(let E=0;E<a;E++){const M=3*E;if(a>1?R?(m=O+E/(a-1)*(w-O),p=10**m):p=s+E/(a-1)*(o-s):R?(m=.5*(O+w),p=10**m):p=.5*(s+o),e.discretize){const D=e.mappingRange;if(p>=D[0]&&p<=D[1]){const N=e.numberOfValues,G=D[1]-D[0];if(N<=1)p=D[0]+G/2;else{const _=(p-D[0])/G,B=Qn(N*_);p=D[0]+B/(N-1)*G}}}for(;c<u&&p>e.nodes[c].x;)c++,c<u&&(d=e.nodes[c-1].x,h=e.nodes[c].x,R&&(d=Math.log10(d),h=Math.log10(h)),T[0]=e.nodes[c-1].r,v[0]=e.nodes[c].r,T[1]=e.nodes[c-1].g,v[1]=e.nodes[c].g,T[2]=e.nodes[c-1].b,v[2]=e.nodes[c].b,C=e.nodes[c-1].midpoint,S=e.nodes[c-1].sharpness,C<1e-5&&(C=1e-5),C>.99999&&(C=.99999));if(p>e.mappingRange[1])i[M]=0,i[M+1]=0,i[M+2]=0,e.clamping&&(t.getUseAboveRangeColor()?(i[M]=e.aboveRangeColor[0],i[M+1]=e.aboveRangeColor[1],i[M+2]=e.aboveRangeColor[2]):(i[M]=g,i[M+1]=f,i[M+2]=l));else if(p<e.mappingRange[0]||Wc(p)&&p<0)i[M]=0,i[M+1]=0,i[M+2]=0,e.clamping&&(t.getUseBelowRangeColor()?(i[M]=e.belowRangeColor[0],i[M+1]=e.belowRangeColor[1],i[M+2]=e.belowRangeColor[2]):u>0&&(i[M]=e.nodes[0].r,i[M+1]=e.nodes[0].g,i[M+2]=e.nodes[0].b));else if(c===0&&(Math.abs(p-s)<1e-6||e.discretize))u>0?(i[M]=e.nodes[0].r,i[M+1]=e.nodes[0].g,i[M+2]=e.nodes[0].b):(i[M]=0,i[M+1]=0,i[M+2]=0);else{let D=0;if(R?D=(m-d)/(h-d):D=(p-d)/(h-d),D<C?D=.5*D/C:D=.5+.5*(D-C)/(1-C),S>.99)if(D<.5){i[M]=T[0],i[M+1]=T[1],i[M+2]=T[2];continue}else{i[M]=v[0],i[M+1]=v[1],i[M+2]=v[2];continue}if(S<.01){if(e.colorSpace===He.RGB)i[M]=(1-D)*T[0]+D*v[0],i[M+1]=(1-D)*T[1]+D*v[1],i[M+2]=(1-D)*T[2]+D*v[2];else if(e.colorSpace===He.HSV){const L=[],W=[];_n(T,L),_n(v,W),e.hSVWrap&&(L[0]-W[0]>.5||W[0]-L[0]>.5)&&(L[0]>W[0]?L[0]-=1:W[0]-=1);const H=[];H[0]=(1-D)*L[0]+D*W[0],H[0]<0&&(H[0]+=1),H[1]=(1-D)*L[1]+D*W[1],H[2]=(1-D)*L[2]+D*W[2],Yt(H,x),i[M]=x[0],i[M+1]=x[1],i[M+2]=x[2]}else if(e.colorSpace===He.LAB){const L=[],W=[];It(T,L),It(v,W);const H=[];H[0]=(1-D)*L[0]+D*W[0],H[1]=(1-D)*L[1]+D*W[1],H[2]=(1-D)*L[2]+D*W[2],Qr(H,x),i[M]=x[0],i[M+1]=x[1],i[M+2]=x[2]}else e.colorSpace===He.DIVERGING?(Vo(D,T,v,x),i[M]=x[0],i[M+1]=x[1],i[M+2]=x[2]):lt("ColorSpace set to invalid value.",e.colorSpace);continue}D<.5?D=.5*(D*2)**(1+10*S):D>.5&&(D=1-.5*((1-D)*2)**(1+10*S));const N=D*D,G=N*D,_=2*G-3*N+1,B=-2*G+3*N,F=G-2*N+D,z=G-N;let U,k;if(e.colorSpace===He.RGB)for(let L=0;L<3;L++)U=v[L]-T[L],k=(1-S)*U,i[M+L]=_*T[L]+B*v[L]+F*k+z*k;else if(e.colorSpace===He.HSV){const L=[],W=[];_n(T,L),_n(v,W),e.hSVWrap&&(L[0]-W[0]>.5||W[0]-L[0]>.5)&&(L[0]>W[0]?L[0]-=1:W[0]-=1);const H=[];for(let $=0;$<3;$++)U=W[$]-L[$],k=(1-S)*U,H[$]=_*L[$]+B*W[$]+F*k+z*k,$===0&&H[$]<0&&(H[$]+=1);Yt(H,x),i[M]=x[0],i[M+1]=x[1],i[M+2]=x[2]}else if(e.colorSpace===He.LAB){const L=[],W=[];It(T,L),It(v,W);const H=[];for(let $=0;$<3;$++)U=W[$]-L[$],k=(1-S)*U,H[$]=_*L[$]+B*W[$]+F*k+z*k;Qr(H,x),i[M]=x[0],i[M+1]=x[1],i[M+2]=x[2]}else e.colorSpace===He.DIVERGING?(Vo(D,T,v,x),i[M]=x[0],i[M+1]=x[1],i[M+2]=x[2]):lt("ColorSpace set to invalid value.");for(let L=0;L<3;L++)i[M+L]=i[M+L]<0?0:i[M+L],i[M+L]=i[M+L]>1?1:i[M+L]}}},t.getUint8Table=function(r,n,a){let i=arguments.length>3&&arguments[3]!==void 0?arguments[3]:!1;if(t.getMTime()<=e.buildTime&&e.tableSize===a&&e.tableWithAlpha!==i)return e.table;if(e.nodes.length===0)return lt("Attempting to lookup a value with no points in the function"),e.table;const s=i?4:3;(e.tableSize!==a||e.tableWithAlpha!==i)&&(e.table=new Uint8Array(a*s),e.tableSize=a,e.tableWithAlpha=i);const o=[];t.getTable(r,n,a,o);for(let c=0;c<a;c++)e.table[c*s+0]=Math.floor(o[c*3+0]*255+.5),e.table[c*s+1]=Math.floor(o[c*3+1]*255+.5),e.table[c*s+2]=Math.floor(o[c*3+2]*255+.5),i&&(e.table[c*s+3]=255);return e.buildTime.modified(),e.table},t.buildFunctionFromArray=r=>{t.removeAllPoints();const n=r.getNumberOfComponents();for(let a=0;a<r.getNumberOfTuples();a++)switch(n){case 3:{e.nodes.push({x:a,r:r.getComponent(a,0),g:r.getComponent(a,1),b:r.getComponent(a,2),midpoint:.5,sharpness:0});break}case 4:{e.nodes.push({x:r.getComponent(a,0),r:r.getComponent(a,1),g:r.getComponent(a,2),b:r.getComponent(a,3),midpoint:.5,sharpness:0});break}case 5:{e.nodes.push({x:a,r:r.getComponent(a,0),g:r.getComponent(a,1),b:r.getComponent(a,2),midpoint:r.getComponent(a,4),sharpness:r.getComponent(a,5)});break}case 6:{e.nodes.push({x:r.getComponent(a,0),r:r.getComponent(a,1),g:r.getComponent(a,2),b:r.getComponent(a,3),midpoint:r.getComponent(a,4),sharpness:r.getComponent(a,5)});break}}t.sortAndUpdateRange()},t.buildFunctionFromTable=(r,n,a,i)=>{let s=0;t.removeAllPoints(),a>1&&(s=(n-r)/(a-1));for(let o=0;o<a;o++){const c={x:r+s*o,r:i[o*3],g:i[o*3+1],b:i[o*3+2],sharpness:0,midpoint:.5};e.nodes.push(c)}t.sortAndUpdateRange()},t.getNodeValue=(r,n)=>r<0||r>=e.nodes.length?(lt("Index out of range!"),-1):(n[0]=e.nodes[r].x,n[1]=e.nodes[r].r,n[2]=e.nodes[r].g,n[3]=e.nodes[r].b,n[4]=e.nodes[r].midpoint,n[5]=e.nodes[r].sharpness,1),t.setNodeValue=(r,n)=>{if(r<0||r>=e.nodes.length)return lt("Index out of range!"),-1;const a=e.nodes[r].x;return e.nodes[r].x=n[0],e.nodes[r].r=n[1],e.nodes[r].g=n[2],e.nodes[r].b=n[3],e.nodes[r].midpoint=n[4],e.nodes[r].sharpness=n[5],a!==n[0]?t.sortAndUpdateRange():t.modified(),1},t.getNumberOfAvailableColors=()=>{var n;if(e.indexedLookup&&t.getSize())return t.getSize();if(e.tableSize)return e.tableSize;const r=((n=e.nodes)==null?void 0:n.length)??0;return Math.max(4094,r)},t.getIndexedColor=(r,n)=>{const a=t.getSize();if(a>0&&r>=0){const s=[];t.getNodeValue(r%a,s);for(let o=0;o<3;++o)n[o]=s[o+1];n[3]=1;return}const i=t.getNanColorByReference();n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=1},t.fillFromDataPointer=(r,n)=>{if(!(r<=0||!n)){t.removeAllPoints();for(let a=0;a<r;a++)t.addRGBPoint(n[a*4],n[a*4+1],n[a*4+2],n[a*4+3])}},t.setMappingRange=(r,n)=>{const a=[r,n],i=t.getRange();if(i[1]===a[1]&&i[0]===a[0])return;if(a[1]===a[0]){lt("attempt to set zero width color range");return}const s=(a[1]-a[0])/(i[1]-i[0]),o=a[0]-i[0]*s;for(let c=0;c<e.nodes.length;++c)e.nodes[c].x=e.nodes[c].x*s+o;e.mappingRange[0]=a[0],e.mappingRange[1]=a[1],t.modified()},t.adjustRange=r=>{const n=t.getRange(),a=[];n[0]<r[0]?(t.getColor(r[0],a),t.addRGBPoint(r[0],a[0],a[1],a[2])):(t.getColor(n[0],a),t.addRGBPoint(r[0],a[0],a[1],a[2])),n[1]>r[1]?(t.getColor(r[1],a),t.addRGBPoint(r[1],a[0],a[1],a[2])):(t.getColor(n[1],a),t.addRGBPoint(r[1],a[0],a[1],a[2])),t.sortAndUpdateRange();for(let i=0;i<e.nodes.length;)e.nodes[i].x>=r[0]&&e.nodes[i].x<=r[1]?e.nodes.splice(i,1):++i;return 1},t.estimateMinNumberOfSamples=(r,n)=>{const a=t.findMinimumXDistance();return Math.ceil((n-r)/a)},t.findMinimumXDistance=()=>{if(e.nodes.length<2)return-1;let r=Number.MAX_VALUE;for(let n=0;n<e.nodes.length-1;n++){const a=e.nodes[n+1].x-e.nodes[n].x;a<r&&(r=a)}return r},t.mapScalarsThroughTable=(r,n,a,i)=>{if(t.getSize()===0){iR("Transfer Function Has No Points!");return}e.indexedLookup?t.mapDataIndexed(r,n,a,i):t.mapData(r,n,a,i)},t.mapData=(r,n,a,i)=>{if(t.getSize()===0){sR("Transfer Function Has No Points!");return}const s=Math.floor(t.getAlpha()*255+.5),o=r.getNumberOfTuples(),c=r.getNumberOfComponents(),u=n.getData(),g=r.getData(),f=[];if(a===Ur.RGBA)for(let l=0;l<o;l++){const p=g[l*c+i];t.getColor(p,f),u[l*4]=Math.floor(f[0]*255+.5),u[l*4+1]=Math.floor(f[1]*255+.5),u[l*4+2]=Math.floor(f[2]*255+.5),u[l*4+3]=s}if(a===Ur.RGB)for(let l=0;l<o;l++){const p=g[l*c+i];t.getColor(p,f),u[l*3]=Math.floor(f[0]*255+.5),u[l*3+1]=Math.floor(f[1]*255+.5),u[l*3+2]=Math.floor(f[2]*255+.5)}if(a===Ur.LUMINANCE)for(let l=0;l<o;l++){const p=g[l*c+i];t.getColor(p,f),u[l]=Math.floor(f[0]*76.5+f[1]*150.45+f[2]*28.05+.5)}if(a===Ur.LUMINANCE_ALPHA)for(let l=0;l<o;l++){const p=g[l*c+i];t.getColor(p,f),u[l*2]=Math.floor(f[0]*76.5+f[1]*150.45+f[2]*28.05+.5),u[l*2+1]=s}},t.applyColorMap=r=>{const n=JSON.stringify(e.colorSpace);r.ColorSpace&&(e.colorSpace=He[r.ColorSpace.toUpperCase()],e.colorSpace===void 0&&(lt(`ColorSpace ${r.ColorSpace} not supported, using RGB instead`),e.colorSpace=He.RGB));let a=n!==JSON.stringify(e.colorSpace);const i=a||JSON.stringify(e.nanColor);if(r.NanColor)for(e.nanColor=[].concat(r.NanColor);e.nanColor.length<4;)e.nanColor.push(1);a=a||i!==JSON.stringify(e.nanColor);const s=a||JSON.stringify(e.nodes);if(r.RGBPoints){const u=r.RGBPoints.length;e.nodes=[];const g=.5,f=0;for(let l=0;l<u;l+=4)e.nodes.push({x:r.RGBPoints[l],r:r.RGBPoints[l+1],g:r.RGBPoints[l+2],b:r.RGBPoints[l+3],midpoint:g,sharpness:f})}const o=t.sortAndUpdateRange(),c=!o&&(a||s!==JSON.stringify(e.nodes));return c&&t.modified(),o||c}}const fR={clamping:!0,colorSpace:He.RGB,hSVWrap:!0,scale:Cs.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function qg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,fR,r),Ii.extend(t,e,r),e.table=[],e.nodes=[],e.nanColor=[.5,0,0,1],e.belowRangeColor=[0,0,0,1],e.aboveRangeColor=[1,1,1,1],e.buildTime={},y.obj(e.buildTime),y.get(t,e,["buildTime","mappingRange"]),y.setGet(t,e,["useAboveRangeColor","useBelowRangeColor","discretize","numberOfValues",{type:"enum",name:"colorSpace",enum:He},{type:"enum",name:"scale",enum:Cs}]),y.setArray(t,e,["nanColor","belowRangeColor","aboveRangeColor"],4),y.getArray(t,e,["nanColor","belowRangeColor","aboveRangeColor"]),uR(t,e)}const gR=y.newInstance(qg,"vtkColorTransferFunction");var Zg={newInstance:gR,extend:qg,...Yg};function Pg(t,e,r,n,a,i){if(1-Math.abs(b(a.getActiveCamera().getViewPlaneNormal(),n))<Ta)return[];const o=i.displayToWorld(t,e,0,a),c=i.displayToWorld(t,e,1,a),u=[0,0,0];re(c,o,u);const g=[0,0,0];Te(n,u,g),Te(g,u,g);const f=b([o[0]-r[0],o[1]-r[1],o[2]-r[2]],g),l=b(g,n),p=n.slice();return l===0?St(p,0):St(p,f/l),Qe(r,p,p),p}function lR(t,e){e.classHierarchy.push("vtkLineManipulator"),t.handleEvent=(r,n)=>e._addWorldDeltas({worldCoords:Pg(r.position.x,r.position.y,t.getOrigin(r),t.getNormal(r),r.pokedRenderer,n)})}function pR(t){return{...t}}function Jg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Lf.extend(t,e,pR(r)),lR(t,e)}const hR=y.newInstance(Jg,"vtkLineManipulator");var dR={projectDisplayToLine:Pg,extend:Jg,newInstance:hR};const{vtkErrorMacro:TR}=y,Lo=[2,0,1,2,0,2,2,0,4,2,1,3,2,1,5,2,2,3,2,2,6,2,3,7,2,4,5,2,4,6,2,5,7,2,6,7];function vR(t,e){e.classHierarchy.push("vtkCroppingOutlineRepresentation"),e.internalPolyData=Be.newInstance({mtime:0}),Rt(e.internalPolyData,"lines",Lo.length).getData().set(Lo);const r=kg(t,e);e.mapper=lr.newInstance({scalarVisibility:!1}),e.actor=dr.newInstance({parentProp:t}),e.actor.getProperty().setEdgeColor(...e.edgeColor),e.mapper.setInputConnection(t.getOutputPort()),e.actor.setMapper(e.mapper),t.addActor(e.actor),t.requestData=(n,a)=>{const i=t.getRepresentationStates(n[0]).filter(s=>s.getOrigin&&s.getOrigin());i.length===8?(r(e.internalPolyData,i),e.internalPolyData.getPoints().modified(),e.internalPolyData.modified(),a[0]=e.internalPolyData):TR("CroppingOutlineRepresentation did not get 8 states")}}const yR={edgeColor:[1,1,1]};function Qg(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,yR,r),Jf.extend(t,e,r),y.setGetArray(t,e,["edgeColor"],3),y.get(t,e,["mapper","actor"]),vR(t,e)}const CR=y.newInstance(Qg,"vtkCroppingOutlineRepresentation");var SR={newInstance:CR,extend:Qg};const tn=["-","=","+"];function Ss(t,e){const r=new Float64Array(3);return q(r,t,e),r}function Ig(t){const[e,r,n]=t.split("").map(a=>tn.indexOf(a)-1);return e*r*n!==0?"corners":e*r!==0||r*n!==0||n*e!==0?"edges":"faces"}function Fo(t,e){const r=[(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2];return Ss(r,e)}function ko(t,e){const r=Ia();return Pa(r,t,e),Ct(r,r),r}function xR(t,e){e._isDragging=!1,t.setDisplayCallback=r=>e.representations[0].setDisplayCallback(r),t.handleLeftButtonPress=r=>!e.activeState||!e.activeState.getActive()||!e.pickable?y.VOID:(e.dragable&&(e.activeState.getManipulator().handleEvent(r,e._apiSpecificRenderWindow),e._isDragging=!0,e._apiSpecificRenderWindow.setCursor("grabbing"),e._interactor.requestAnimation(t)),y.EVENT_ABORT),t.handleMouseMove=r=>e._isDragging?t.handleEvent(r):y.VOID,t.handleLeftButtonRelease=()=>!e.activeState||!e.activeState.getActive()||!e.pickable?y.VOID:(e._isDragging&&(e._isDragging=!1,e._interactor.cancelAnimation(t),e.widgetState.deactivate()),y.EVENT_ABORT),t.handleEvent=r=>{if(e.pickable&&e.activeState&&e.activeState.getActive()){const n=e.activeState.getManipulator();if(n){const a=e.activeState.getName(),i=Ig(a),s=a.split("").map(f=>tn.indexOf(f)),o=e.widgetState.getCroppingPlanes().getPlanes(),c=e.widgetState.getIndexToWorldT();let u=[],g=[];if(i==="corners"&&({worldCoords:u,worldDelta:g}=n.handleEvent(r,e._apiSpecificRenderWindow)),i==="faces"){const f=Fo(o,c);n.setHandleOrigin(f),n.setHandleNormal(ko(e.activeState.getOrigin(),f)),{worldCoords:u,worldDelta:g}=n.handleEvent(r,e._apiSpecificRenderWindow)}if(i==="edges"){const l=s.map(h=>h===1?h:0).map(h=>tn[h+1]).join(""),p=e.widgetState.getStatesWithLabel(l)[0],d=Fo(o,c);n.setHandleNormal(ko(p.getOrigin(),d)),{worldCoords:u,worldDelta:g}=n.handleEvent(r,e._apiSpecificRenderWindow)}if(u.length&&g.length){const f=e.widgetState.getWorldToIndexT(),l=Ss(u,f);for(let p=0;p<3;p++)s[p]===0?o[p*2]=l[p]:s[p]===2&&(o[p*2+1]=l[p]);return e.activeState.setOrigin(Qe(e.activeState.getOrigin(),g,[])),e.widgetState.getCroppingPlanes().setPlanes(...o),y.EVENT_ABORT}}}return y.VOID},e._camera=e._renderer.getActiveCamera(),e.classHierarchy.push("vtkImageCroppingWidgetProp")}function wR(){const t=wi.createBuilder();t.addField({name:"indexToWorldT",initialValue:Array(16).fill(0)}).addField({name:"worldToIndexT",initialValue:Array(16).fill(0)});const e=wi.createBuilder().addField({name:"planes",initialValue:[0,1,0,1,0,1]}).build();t.addStateFromInstance({labels:["croppingPlanes"],name:"croppingPlanes",instance:e});for(let r=-1;r<2;r++)for(let n=-1;n<2;n++)for(let a=-1;a<2;a++)if(r!==0||n!==0||a!==0){const i=tn[r+1]+tn[n+1]+tn[a+1],s=Ig(i);t.addStateFromMixin({labels:["handles",i,s],mixins:["name","origin","color","scale1","visible","manipulator"],name:i,initialValues:{scale1:30,origin:[r,n,a],visible:!0,name:i}})}return t.build()}function RR(t,e){e.classHierarchy.push("vtkImageCroppingWidget");const r={...t};let n=null;function a(i,s){e.widgetState.getStatesWithLabel(i).forEach(o=>{o.setVisible(s)})}t.setFaceHandlesEnabled=i=>a("faces",i),t.setEdgeHandlesEnabled=i=>a("edges",i),t.setCornerHandlesEnabled=i=>a("corners",i),t.copyImageDataDescription=i=>{e.widgetState.setIndexToWorldT(...i.getIndexToWorld()),e.widgetState.setWorldToIndexT(...i.getWorldToIndex());const s=i.getDimensions();e.widgetState.getCroppingPlanes().setPlanes([0,s[0],0,s[1],0,s[2]]),t.modified()},t.updateHandles=()=>{const i=e.widgetState.getCroppingPlanes().getPlanes(),s=[(i[0]+i[1])/2,(i[2]+i[3])/2,(i[4]+i[5])/2],o=[i[0],s[0],i[1]],c=[i[2],s[1],i[3]],u=[i[4],s[2],i[5]],g=e.widgetState.getIndexToWorldT(),f=l=>tn[l];for(let l=0;l<3;l++)for(let p=0;p<3;p++)for(let d=0;d<3;d++)if(l!==1||p!==1||d!==1){const h=[l,p,d].map(f).join(""),T=Ss([o[l],c[p],u[d]],g),[v]=e.widgetState.getStatesWithLabel(h);v.setOrigin(...T)}},t.delete=y.chain(t.delete,()=>{n&&n.unsubscribe()}),e.methodsToLink=["scaleInPixels"],t.getRepresentationsForViewType=i=>{switch(i){case P.DEFAULT:case P.GEOMETRY:case P.SLICE:case P.VOLUME:default:return[{builder:Oi,labels:["handles"]},{builder:SR,labels:["corners"]}]}},n=e.widgetState.getCroppingPlanes().onModified(t.updateHandles),t.setCornerManipulator=i=>{r.setCornerManipulator(i),e.widgetState.getStatesWithLabel("corners").forEach(s=>s.setManipulator(i))},t.setEdgeManipulator=i=>{r.setEdgeManipulator(i),e.widgetState.getStatesWithLabel("edges").forEach(s=>s.setManipulator(i))},t.setFaceManipulator=i=>{r.setFaceManipulator(i),e.widgetState.getStatesWithLabel("faces").forEach(s=>s.setManipulator(i))},t.setCornerManipulator(Ci.newInstance({useCameraNormal:!0})),t.setEdgeManipulator(Ci.newInstance()),t.setFaceManipulator(dR.newInstance())}const MR=t=>({behavior:xR,widgetState:wR(),...t});function el(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,MR(r)),bf.extend(t,e,r),y.setGet(t,e,["cornerManipulator","edgeManipulator","faceManipulator"]),RR(t,e)}const OR=y.newInstance(el,"vtkImageCroppingWidget");var _M={newInstance:OR,extend:el};const{InterpolationType:$n,OpacityMode:mR}=df,{vtkErrorMacro:Aa}=y,qr=4;function ER(t,e){e.classHierarchy.push("vtkVolumeProperty"),t.getMTime=()=>{let a=e.mtime,i;for(let s=0;s<qr;s++)e.componentData[s].colorChannels===1?e.componentData[s].grayTransferFunction&&(i=e.componentData[s].grayTransferFunction.getMTime(),a=a>i?a:i):e.componentData[s].colorChannels===3&&e.componentData[s].rGBTransferFunction&&(i=e.componentData[s].rGBTransferFunction.getMTime(),a=a>i?a:i),e.componentData[s].scalarOpacity&&(i=e.componentData[s].scalarOpacity.getMTime(),a=a>i?a:i),e.componentData[s].gradientOpacity&&(e.componentData[s].disableGradientOpacity||(i=e.componentData[s].gradientOpacity.getMTime(),a=a>i?a:i));return a},t.getColorChannels=a=>a<0||a>3?(Aa("Bad index - must be between 0 and 3"),0):e.componentData[a].colorChannels,t.setGrayTransferFunction=function(){let a=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0,i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:null,s=!1;return e.componentData[a].grayTransferFunction!==i&&(e.componentData[a].grayTransferFunction=i,s=!0),e.componentData[a].colorChannels!==1&&(e.componentData[a].colorChannels=1,s=!0),s&&t.modified(),s},t.getGrayTransferFunction=function(){let a=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;return e.componentData[a].grayTransferFunction===null&&(e.componentData[a].grayTransferFunction=ca.newInstance(),e.componentData[a].grayTransferFunction.addPoint(0,0),e.componentData[a].grayTransferFunction.addPoint(1024,1),e.componentData[a].colorChannels!==1&&(e.componentData[a].colorChannels=1),t.modified()),e.componentData[a].grayTransferFunction},t.setRGBTransferFunction=function(){let a=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0,i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:null,s=!1;return e.componentData[a].rGBTransferFunction!==i&&(e.componentData[a].rGBTransferFunction=i,s=!0),e.componentData[a].colorChannels!==3&&(e.componentData[a].colorChannels=3,s=!0),s&&t.modified(),s},t.getRGBTransferFunction=function(){let a=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;return e.componentData[a].rGBTransferFunction===null&&(e.componentData[a].rGBTransferFunction=Zg.newInstance(),e.componentData[a].rGBTransferFunction.addRGBPoint(0,0,0,0),e.componentData[a].rGBTransferFunction.addRGBPoint(1024,1,1,1),e.componentData[a].colorChannels!==3&&(e.componentData[a].colorChannels=3),t.modified()),e.componentData[a].rGBTransferFunction},t.setScalarOpacity=function(){let a=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0,i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:null;return e.componentData[a].scalarOpacity!==i?(e.componentData[a].scalarOpacity=i,t.modified(),!0):!1},t.getScalarOpacity=function(){let a=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;return e.componentData[a].scalarOpacity===null&&(e.componentData[a].scalarOpacity=ca.newInstance(),e.componentData[a].scalarOpacity.addPoint(0,1),e.componentData[a].scalarOpacity.addPoint(1024,1),t.modified()),e.componentData[a].scalarOpacity},t.setComponentWeight=function(){let a=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0,i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:1;if(a<0||a>=qr)return Aa("Invalid index"),!1;const s=Math.min(1,Math.max(0,i));return e.componentData[a].componentWeight!==s?(e.componentData[a].componentWeight=s,t.modified(),!0):!1},t.getComponentWeight=function(){let a=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;return a<0||a>=qr?(Aa("Invalid index"),0):e.componentData[a].componentWeight},t.setInterpolationTypeToNearest=()=>t.setInterpolationType($n.NEAREST),t.setInterpolationTypeToLinear=()=>t.setInterpolationType($n.LINEAR),t.setInterpolationTypeToFastLinear=()=>t.setInterpolationType($n.FAST_LINEAR),t.getInterpolationTypeAsString=()=>y.enumToString($n,e.interpolationType),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach(a=>{const i=y.capitalize(a);t[`set${i}`]=(s,o)=>e.componentData[s][`${a}`]!==o?(e.componentData[s][`${a}`]=o,t.modified(),!0):!1}),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach(a=>{const i=y.capitalize(a);t[`get${i}`]=s=>e.componentData[s][`${a}`]})}const DR={colorMixPreset:null,independentComponents:!0,interpolationType:$n.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function tl(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};if(Object.assign(e,DR,r),y.obj(t,e),!e.componentData){e.componentData=[];for(let n=0;n<qr;++n)e.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:mR.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1,forceNearestInterpolation:!1})}y.setGet(t,e,["colorMixPreset","independentComponents","interpolationType","shade","ambient","diffuse","specular","specularPower","useLabelOutline","labelOutlineOpacity"]),y.setGetArray(t,e,["labelOutlineThickness"]),ER(t,e)}const VR=y.newInstance(tl,"vtkVolumeProperty");var LR={newInstance:VR,extend:tl,...df};const{vtkDebugMacro:FR}=y;function kR(t,e){e.classHierarchy.push("vtkVolume"),t.getVolumes=()=>t,t.makeProperty=LR.newInstance,t.getProperty=()=>(e.property===null&&(e.property=t.makeProperty()),e.property),t.getBounds=()=>{if(e.mapper===null)return e.bounds;const r=e.mapper.getBounds();if(!r||r.length!==6)return r;if(r[0]>r[1])return e.mapperBounds=r.concat(),e.bounds=[1,-1,1,-1,1,-1],e.boundsMTime.modified(),r;const n=a=>a[0].map((i,s)=>a.map(o=>o[s]));if(!e.mapperBounds||!n([r,e.mapperBounds]).reduce((a,i)=>a&&i[0]===i[1],!0)||t.getMTime()>e.boundsMTime.getMTime()){FR("Recomputing bounds..."),e.mapperBounds=r.map(s=>s);const a=[];K.getCorners(r,a),t.computeMatrix();const i=new Float64Array(16);se(i,e.matrix),a.forEach(s=>q(s,s,i)),e.bounds[0]=e.bounds[2]=e.bounds[4]=Number.MAX_VALUE,e.bounds[1]=e.bounds[3]=e.bounds[5]=-Number.MAX_VALUE,e.bounds=e.bounds.map((s,o)=>o%2===0?a.reduce((c,u)=>c>u[o/2]?u[o/2]:c,s):a.reduce((c,u)=>c<u[(o-1)/2]?u[(o-1)/2]:c,s)),e.boundsMTime.modified()}return e.bounds},t.getMTime=()=>{let r=e.mtime;if(e.property!==null){const n=e.property.getMTime();r=n>r?n:r}return r},t.getRedrawMTime=()=>{let r=e.mtime;if(e.mapper!==null){let n=e.mapper.getMTime();r=n>r?n:r,e.mapper.getInput()!==null&&(e.mapper.getInputAlgorithm().update(),n=e.mapper.getInput().getMTime(),r=n>r?n:r)}return r}}const NR={mapper:null,property:null,bounds:[1,-1,1,-1,1,-1]};function nl(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,NR,r),vs.extend(t,e,r),e.boundsMTime={},y.obj(e.boundsMTime),y.set(t,e,["property"]),y.setGet(t,e,["mapper"]),y.getArray(t,e,["bounds"],6),kR(t,e)}const _R=y.newInstance(nl,"vtkVolume");var GM={newInstance:_R,extend:nl};const{BlendMode:kt,FilterMode:zn}=fy;function GR(t,e,r,n,a){let i=null;return a?(i=a,i.removeAllPoints()):i=ca.newInstance(),i.addPointLong(-1024,0,1,1),i.addPoint(t,e),i.addPoint(r,n),i}const UR={createRadonTransferFunction:GR};function BR(t,e){e.classHierarchy.push("vtkVolumeMapper");const r={...t};t.getBounds=()=>{const n=t.getInputData();return n?(e.static||t.update(),e.bounds=n.getBounds()):e.bounds=xt(),e.bounds},t.update=()=>{t.getInputData()},t.setBlendModeToComposite=()=>{t.setBlendMode(kt.COMPOSITE_BLEND)},t.setBlendModeToMaximumIntensity=()=>{t.setBlendMode(kt.MAXIMUM_INTENSITY_BLEND)},t.setBlendModeToMinimumIntensity=()=>{t.setBlendMode(kt.MINIMUM_INTENSITY_BLEND)},t.setBlendModeToAverageIntensity=()=>{t.setBlendMode(kt.AVERAGE_INTENSITY_BLEND)},t.setBlendModeToAdditiveIntensity=()=>{t.setBlendMode(kt.ADDITIVE_INTENSITY_BLEND)},t.setBlendModeToRadonTransform=()=>{t.setBlendMode(kt.RADON_TRANSFORM_BLEND)},t.getBlendModeAsString=()=>y.enumToString(kt,e.blendMode),t.setAverageIPScalarRange=(n,a)=>{console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange"),t.setIpScalarRange(n,a)},t.getFilterModeAsString=()=>y.enumToString(zn,e.filterMode),t.setFilterModeToOff=()=>{t.setFilterMode(zn.OFF)},t.setFilterModeToNormalized=()=>{t.setFilterMode(zn.NORMALIZED)},t.setFilterModeToRaw=()=>{t.setFilterMode(zn.RAW)},t.setGlobalIlluminationReach=n=>r.setGlobalIlluminationReach(Je(n,0,1)),t.setVolumetricScatteringBlending=n=>r.setVolumetricScatteringBlending(Je(n,0,1)),t.setVolumeShadowSamplingDistFactor=n=>r.setVolumeShadowSamplingDistFactor(n>=1?n:1),t.setAnisotropy=n=>r.setAnisotropy(Je(n,-.99,.99)),t.setLAOKernelSize=n=>r.setLAOKernelSize(Qn(Je(n,1,32))),t.setLAOKernelRadius=n=>r.setLAOKernelRadius(n>=1?n:1)}const WR={bounds:[1,-1,1,-1,1,-1],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:kt.COMPOSITE_BLEND,ipScalarRange:[-1e6,1e6],filterMode:zn.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,volumeShadowSamplingDistFactor:5,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7};function rl(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,WR,r),Zi.extend(t,e,r),y.setGet(t,e,["sampleDistance","imageSampleDistance","maximumSamplesPerRay","autoAdjustSampleDistances","initialInteractionScale","interactionSampleDistanceFactor","blendMode","filterMode","preferSizeOverAccuracy","computeNormalFromOpacity","volumetricScatteringBlending","globalIlluminationReach","volumeShadowSamplingDistFactor","anisotropy","localAmbientOcclusion","LAOKernelSize","LAOKernelRadius"]),y.setGetArray(t,e,["ipScalarRange"],2),y.event(t,e,"lightingActivated"),BR(t,e)}const $R=y.newInstance(rl,"vtkVolumeMapper");var UM={newInstance:$R,extend:rl,...UR};const zR={TOP_LEFT:"TOP_LEFT",TOP_RIGHT:"TOP_RIGHT",BOTTOM_LEFT:"BOTTOM_LEFT",BOTTOM_RIGHT:"BOTTOM_RIGHT"};var xs={Corners:zR};const{vtkErrorMacro:Ya}=y,{Corners:Br}=xs;function HR(t,e){e.classHierarchy.push("vtkOrientationMarkerWidget");const r={...t},n=[],a=ug.newInstance(),i=new ResizeObserver(l=>{t.updateViewport()});let s=null,o=null,c=null,u=null,g=null;function f(){e._interactor.isAnimating()||t.updateMarkerOrientation()}e._onParentRendererChanged=()=>t.updateViewport(),t.computeViewport=()=>{const l=e.parentRenderer||e._interactor.getCurrentRenderer(),[p,d,h,T]=l.getViewport(),v=e._interactor.getView(),C=v.getSize(),[S,x]=v.getViewportSize(l),R=Math.min(S,x);let O=e.viewportSize*R;O=Math.max(Math.min(e.minPixelSize,R),Math.min(e.maxPixelSize,O));const w=O/C[0],m=O/C[1];switch(e.viewportCorner){case Br.TOP_LEFT:return[p,T-m,p+w,T];case Br.TOP_RIGHT:return[h-w,T-m,h,T];case Br.BOTTOM_LEFT:return[p,d,p+w,d+m];case Br.BOTTOM_RIGHT:return[h-w,d,h,d+m];default:return Ya("Invalid widget corner"),null}},t.updateViewport=()=>{e.enabled&&(a.setViewport(...t.computeViewport()),e._interactor.render())},t.updateMarkerOrientation=()=>{const p=(e.parentRenderer||e._interactor.getCurrentRenderer()).getActiveCamera();if(!p)return;const d=p.getReferenceByName("position"),h=p.getReferenceByName("focalPoint"),T=p.getReferenceByName("viewUp");if(n[0]!==d[0]||n[1]!==d[1]||n[2]!==d[2]||n[3]!==h[0]||n[4]!==h[1]||n[5]!==h[2]||n[6]!==T[0]||n[7]!==T[1]||n[8]!==T[2]){n[0]=d[0],n[1]=d[1],n[2]=d[2],n[3]=h[0],n[4]=h[1],n[5]=h[2],n[6]=T[0],n[7]=T[1],n[8]=T[2];const v=a.getActiveCamera();v.setPosition(d[0],d[1],d[2]),v.setFocalPoint(h[0],h[1],h[2]),v.setViewUp(T[0],T[1],T[2]),a.resetCamera()}},t.setEnabled=l=>{var p,d;if(l){if(e.enabled)return;if(!e.actor){Ya("Must set actor before enabling orientation marker.");return}if(!e._interactor){Ya("Must set interactor before enabling orientation marker.");return}const h=e.parentRenderer||e._interactor.getCurrentRenderer(),T=h.getRenderWindow();T.addRenderer(a),T.getNumberOfLayers()<2&&T.setNumberOfLayers(2),a.setLayer(T.getNumberOfLayers()-1),a.setInteractive(e.interactiveRenderer),a.addViewProp(e.actor),e.actor.setVisibility(!0),s=h.onEvent(v=>{v.type==="ActiveCameraEvent"&&(o&&o.unsubscribe(),o=v.camera.onModified(f))}),o=h.getActiveCamera().onModified(f),c=e._interactor.onAnimation(t.updateMarkerOrientation),u=e._interactor.onEndAnimation(t.updateMarkerOrientation),i.observe(e._interactor.getView().getCanvas()),t.updateViewport(),t.updateMarkerOrientation(),e.enabled=!0}else{if(!e.enabled)return;e.enabled=!1,i.disconnect(),s.unsubscribe(),s=null,o.unsubscribe(),o=null,c.unsubscribe(),c=null,u.unsubscribe(),u=null,e.actor.setVisibility(!1),a.removeViewProp(e.actor);const h=(d=(p=e._interactor)==null?void 0:p.findPokedRenderer())==null?void 0:d.getRenderWindow();h&&h.removeRenderer(a)}t.modified()},t.setViewportCorner=l=>{l!==e.viewportCorner&&(e.viewportCorner=l,t.updateViewport())},t.setViewportSize=l=>{const p=Math.min(1,Math.max(0,l));p!==e.viewportSize&&(e.viewportSize=p,t.updateViewport())},t.setActor=l=>{const p=e.enabled;t.setEnabled(!1),e.actor=l,t.setEnabled(p)},t.getRenderer=()=>a,t.delete=()=>{r.delete(),g&&(g.unsubscribe(),g=null),s&&(s.unsubscribe(),s=null),o&&(o.unsubscribe(),o=null),c&&(c.unsubscribe(),c=null),u&&(u.unsubscribe(),u=null),i.disconnect()},g=t.onModified(t.updateViewport)}const jR={viewportCorner:xs.Corners.BOTTOM_LEFT,viewportSize:.2,minPixelSize:50,maxPixelSize:200,parentRenderer:null,interactiveRenderer:!1};function al(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,jR,r),y.obj(t,e),y.get(t,e,["enabled","viewportCorner","viewportSize","interactiveRenderer"]),y.setGet(t,e,["_interactor","minPixelSize","maxPixelSize","parentRenderer"]),y.get(t,e,["actor"]),y.moveToProtected(t,e,["interactor"]),HR(t,e)}const bR=y.newInstance(al,"vtkOrientationMarkerWidget");var BM={newInstance:bR,extend:al,...xs};function KR(t,e){e.classHierarchy.push("vtkTexture"),t.imageLoaded=()=>{e.image.removeEventListener("load",t.imageLoaded),e.imageLoaded=!0,t.modified()},t.setJsImageData=r=>{e.jsImageData!==r&&(r!==null&&(t.setInputData(null),t.setInputConnection(null),e.image=null,e.canvas=null),e.jsImageData=r,e.imageLoaded=!0,t.modified())},t.setCanvas=r=>{e.canvas!==r&&(r!==null&&(t.setInputData(null),t.setInputConnection(null),e.image=null,e.jsImageData=null),e.canvas=r,t.modified())},t.setImage=r=>{e.image!==r&&(r!==null&&(t.setInputData(null),t.setInputConnection(null),e.canvas=null,e.jsImageData=null),e.image=r,e.imageLoaded=!1,r.complete?t.imageLoaded():r.addEventListener("load",t.imageLoaded),t.modified())},t.getDimensionality=()=>{let r=0,n=0,a=1;if(t.getInputData()){const s=t.getInputData();r=s.getDimensions()[0],n=s.getDimensions()[1],a=s.getDimensions()[2]}return e.jsImageData&&(r=e.jsImageData.width,n=e.jsImageData.height),e.canvas&&(r=e.canvas.width,n=e.canvas.height),e.image&&(r=e.image.width,n=e.image.height),(r>1)+(n>1)+(a>1)},t.getInputAsJsImageData=()=>{if(!e.imageLoaded||t.getInputData())return null;if(e.jsImageData)return e.jsImageData();if(e.canvas)return e.canvas.getContext("2d").getImageData(0,0,e.canvas.width,e.canvas.height);if(e.image){const r=document.createElement("canvas");r.width=e.image.width,r.height=e.image.height;const n=r.getContext("2d");return n.translate(0,r.height),n.scale(1,-1),n.drawImage(e.image,0,0,e.image.width,e.image.height),n.getImageData(0,0,r.width,r.height)}return null}}const XR=(t,e,r,n)=>{const a=[1,2,1],i=4,s=a,o=i,c=t.length/(e*r);let u=e,g=r,f=t;const l=[f];for(let p=0;p<n;p++){const d=[...f];u/=2,g/=2,f=new Uint8ClampedArray(u*g*c);const h=c*u;let T=0;for(let C=0;C<f.length;C+=c){C%h===0&&(T+=2*c*u);for(let S=0;S<c;S++){let x=d[T+S];x+=d[T+c+S],x+=d[T-2*h+S],x+=d[T-2*h+c+S],x/=4,f[C+S]=x}T+=2*c}let v=[...f];for(let C=0;C<f.length;C+=c)for(let S=0;S<c;S++){let x=-(s.length-1)/2,R=o,O=0;for(let w=0;w<s.length;w++){let m=C+S+x*c;const E=m%h-(C+S)%h;E>c&&(m+=h),E<-c&&(m-=h),v[m]?O+=v[m]*s[w]:R-=s[w],x+=1}f[C+S]=O/R}v=[...f];for(let C=0;C<f.length;C+=c)for(let S=0;S<c;S++){let x=-(s.length-1)/2,R=o,O=0;for(let w=0;w<s.length;w++){const m=C+S+x*h;v[m]?O+=v[m]*s[w]:R-=s[w],x+=1}f[C+S]=O/R}l.push(f)}return l},AR={image:null,canvas:null,jsImageData:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function il(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,AR,r),y.obj(t,e),y.algo(t,e,6,0),y.get(t,e,["canvas","image","jsImageData","imageLoaded","resizable"]),y.setGet(t,e,["repeat","edgeClamp","interpolate","mipLevel"]),KR(t,e)}const YR=y.newInstance(il,"vtkTexture"),qR={generateMipmaps:XR};var ZR={newInstance:YR,extend:il,...qR};function sl(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[0,0,0,0];const[r,n,a,i]=e,o=t.getContext("2d").getImageData(r,n,a||t.width,i||t.height),c=Ji.newInstance({type:"vtkImageData"});c.setOrigin(0,0,0),c.setSpacing(1,1,1),c.setExtent(0,(a||t.width)-1,0,(i||t.height)-1,0,0);const u=A.newInstance({numberOfComponents:4,values:new Uint8Array(o.data.buffer)});return u.setName("scalars"),c.getPointData().setScalars(u),c}function PR(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{flipX:!1,flipY:!1,rotate:0};const r=document.createElement("canvas");r.width=t.width,r.height=t.height;const n=r.getContext("2d"),{flipX:a,flipY:i,rotate:s}=e;return n.translate(r.width/2,r.height/2),n.scale(a?-1:1,i?-1:1),n.rotate(s*Math.PI/180),n.drawImage(t,-t.width/2,-t.height/2),sl(r)}var JR={canvasToImageData:sl,imageToImageData:PR};const ol={default:{defaultStyle:{fontStyle:"bold",fontFamily:"Arial",fontColor:"black",fontSizeScale:t=>t/2,faceColor:"white",edgeThickness:.1,edgeColor:"black",resolution:400},xMinusFaceProperty:{text:"X-",faceColor:"yellow"},xPlusFaceProperty:{text:"X+",faceColor:"yellow"},yMinusFaceProperty:{text:"Y-",faceColor:"red"},yPlusFaceProperty:{text:"Y+",faceColor:"red"},zMinusFaceProperty:{text:"Z-",faceColor:"#008000"},zPlusFaceProperty:{text:"Z+",faceColor:"#008000"}},lps:{xMinusFaceProperty:{text:"R",faceRotation:-90},xPlusFaceProperty:{text:"L",faceRotation:90},yMinusFaceProperty:{text:"A",faceRotation:0},yPlusFaceProperty:{text:"P",faceRotation:180},zMinusFaceProperty:{text:"I",faceRotation:180},zPlusFaceProperty:{text:"S",faceRotation:0}}};function cl(t,e){e.set(t)}function QR(t,e){return cl(ol[t],e)}function IR(t,e){ol[t]=e}var eM={applyDefinitions:cl,applyPreset:QR,registerStylePreset:IR};const tM={xPlus:0,xMinus:1,yPlus:2,yMinus:3,zPlus:4,zMinus:5};function nM(t,e){e.classHierarchy.push("vtkAnnotatedCubeActor"),e.xPlusFaceProperty={...e.xPlusFaceProperty},e.xMinusFaceProperty={...e.xMinusFaceProperty},e.yPlusFaceProperty={...e.yPlusFaceProperty},e.yMinusFaceProperty={...e.yMinusFaceProperty},e.zPlusFaceProperty={...e.zPlusFaceProperty},e.zMinusFaceProperty={...e.zMinusFaceProperty};let r=null;const n=document.createElement("canvas"),a=lr.newInstance(),i=ZR.newInstance();i.setInterpolate(!0);function s(c){let u=arguments.length>1&&arguments[1]!==void 0?arguments[1]:null;u&&Object.assign(e[`${c}FaceProperty`],u);const g={...e.defaultStyle,...e[`${c}FaceProperty`]};n.width=g.resolution,n.height=g.resolution;const f=n.getContext("2d");f.fillStyle=g.faceColor,f.fillRect(0,0,n.width,n.height),g.edgeThickness>0&&(f.strokeStyle=g.edgeColor,f.lineWidth=g.edgeThickness*n.width,f.strokeRect(0,0,n.width,n.height)),f.save(),f.translate(0,n.height),f.scale(1,-1),f.translate(n.width/2,n.height/2),f.rotate(-Math.PI*(g.faceRotation/180));const l=g.fontSizeScale(g.resolution);f.fillStyle=g.fontColor,f.textAlign="center",f.textBaseline="middle",f.font=`${g.fontStyle} ${l}px "${g.fontFamily}"`,f.fillText(g.text,0,0),f.restore();const p=JR.canvasToImageData(n);i.setInputData(p,tM[c]),t.modified()}function o(){r=rs.newInstance({generate3DTextureCoordinates:!0}),a.setInputConnection(r.getOutputPort()),s("xPlus"),s("xMinus"),s("yPlus"),s("yMinus"),s("zPlus"),s("zMinus")}t.setDefaultStyle=c=>{e.defaultStyle={...e.defaultStyle,...c},o()},t.setXPlusFaceProperty=c=>s("xPlus",c),t.setXMinusFaceProperty=c=>s("xMinus",c),t.setYPlusFaceProperty=c=>s("yPlus",c),t.setYMinusFaceProperty=c=>s("yMinus",c),t.setZPlusFaceProperty=c=>s("zPlus",c),t.setZMinusFaceProperty=c=>s("zMinus",c),o(),a.setInputConnection(r.getOutputPort()),t.setMapper(a),t.addTexture(i)}const rM={defaultStyle:{text:"",faceColor:"white",faceRotation:0,fontFamily:"Arial",fontColor:"black",fontStyle:"normal",fontSizeScale:t=>t/1.8,edgeThickness:.1,edgeColor:"black",resolution:200}};function ul(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,rM,r),dr.extend(t,e,r),y.get(t,e,["defaultStyle","xPlusFaceProperty","xMinusFaceProperty","yPlusFaceProperty","yMinusFaceProperty","zPlusFaceProperty","zMinusFaceProperty"]),nM(t,e)}const aM=y.newInstance(ul,"vtkAnnotatedCubeActor");var WM={newInstance:aM,extend:ul,Presets:eM};const iM={Preset:0,RGBPoints:1,HSVPoints:2,Nodes:3},sM={Preset:"Cool to Warm",RGBPoints:[[0,0,0,0],[1,1,1,1]],HSVPoints:[[0,0,0,0],[1,0,0,1]],Nodes:[{x:0,r:0,g:0,b:0,midpoint:.5,sharpness:0},{x:1,r:1,g:1,b:1,midpoint:.5,sharpness:0}]};var oM={Defaults:sM,Mode:iM};const{Mode:Jt,Defaults:Gt}=oM;function cM(t,e){e.classHierarchy.push("vtkLookupTableProxy"),e.lookupTable=e.lookupTable||Zg.newInstance(),e.lookupTable.setVectorModeToMagnitude(),t.setPresetName=r=>{e.presetName!==r&&(e.presetName=r,e.mode=Jt.Preset,t.applyMode())},t.setRGBPoints=r=>{e.rgbPoints!==r&&(e.rgbPoints=(r||Gt.RGBPoints).slice(),t.applyMode())},t.setHSVPoints=r=>{e.hsvPoints!==r&&(e.hsvPoints=(r||Gt.HSVPoints).slice(),t.applyMode())},t.setNodes=r=>{e.nodes!==r&&(e.nodes=(r||Gt.Nodes).slice(),t.applyMode())},t.setMode=r=>{e.mode!==r&&(e.mode=r,t.applyMode())},t.applyMode=()=>{switch(e.mode){case Jt.Preset:{const r=D1.getPresetByName(e.presetName);r&&e.lookupTable.applyColorMap(r)}break;case Jt.RGBPoints:e.lookupTable.removeAllPoints(),e.rgbPoints.forEach(r=>e.lookupTable.addRGBPointLong(...r));break;case Jt.HSVPoints:e.lookupTable.removeAllPoints(),e.hsvPoints.forEach(r=>e.lookupTable.addHSVPointLong(...r));break;case Jt.Nodes:e.lookupTable.setNodes(e.nodes);break}e.lookupTable.setMappingRange(e.dataRange[0],e.dataRange[1]),e.lookupTable.updateRange(),t.modified()},t.setDataRange=(r,n)=>{(e.dataRange[0]!==r||e.dataRange[1]!==n)&&(e.dataRange[0]=r,e.dataRange[1]=n,e.lookupTable.setMappingRange(e.dataRange[0],e.dataRange[1]),e.lookupTable.updateRange(),t.applyMode())},t.applyMode()}const uM={mode:Jt.Preset,presetName:Gt.Preset,rgbPoints:Gt.RGBPoints,hsvPoints:Gt.HSVPoints,nodes:Gt.Nodes,arrayName:"No array associated",arrayLocation:"pointData",dataRange:[0,1]};function fl(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,uM,r),y.obj(t,e),y.setGet(t,e,["arrayName"]),y.get(t,e,["mode","lookupTable","presetName","rgbPoints","hsvPoints","nodes","dataRange"]),cM(t,e),y.proxy(t,e)}const fM=y.newInstance(fl,"vtkLookupTableProxy");var $M={newInstance:fM,extend:fl,Mode:Jt,Defaults:Gt};const{States:nt}=ls;function gM(t,e){e.classHierarchy.push("vtkInteractorStyleTrackballCamera"),t.handleMouseMove=r=>{const n=r.position,a=e.getRenderer(r);switch(e.state){case nt.IS_ROTATE:t.handleMouseRotate(a,n),t.invokeInteractionEvent({type:"InteractionEvent"});break;case nt.IS_PAN:t.handleMousePan(a,n),t.invokeInteractionEvent({type:"InteractionEvent"});break;case nt.IS_DOLLY:t.handleMouseDolly(a,n),t.invokeInteractionEvent({type:"InteractionEvent"});break;case nt.IS_SPIN:t.handleMouseSpin(a,n),t.invokeInteractionEvent({type:"InteractionEvent"});break}e.previousPosition=n},t.handleButton3D=r=>{if(r&&r.pressed&&r.device===Si.RightController&&(r.input===Wn.Trigger||r.input===Wn.TrackPad)){t.startCameraPose();return}r&&!r.pressed&&r.device===Si.RightController&&(r.input===Wn.Trigger||r.input===Wn.TrackPad)&&e.state===nt.IS_CAMERA_POSE&&t.endCameraPose()},t.handleMove3D=r=>{switch(e.state){case nt.IS_CAMERA_POSE:t.updateCameraPose(r);break}},t.updateCameraPose=r=>{const n=e.getRenderer(r).getActiveCamera(),a=n.getPhysicalTranslation(),s=.5*.05*n.getPhysicalScale(),o=n.physicalOrientationToWorldDirection([r.orientation.x,r.orientation.y,r.orientation.z,r.orientation.w]);n.setPhysicalTranslation(a[0]+o[0]*s,a[1]+o[1]*s,a[2]+o[2]*s)},t.handleLeftButtonPress=r=>{const n=r.position;e.previousPosition=n,r.shiftKey?r.controlKey||r.altKey?t.startDolly():t.startPan():r.controlKey||r.altKey?t.startSpin():t.startRotate()},t.handleLeftButtonRelease=()=>{switch(e.state){case nt.IS_DOLLY:t.endDolly();break;case nt.IS_PAN:t.endPan();break;case nt.IS_SPIN:t.endSpin();break;case nt.IS_ROTATE:t.endRotate();break}},t.handleStartMouseWheel=()=>{t.startDolly()},t.handleEndMouseWheel=()=>{t.endDolly()},t.handleStartPinch=r=>{e.previousScale=r.scale,t.startDolly()},t.handleEndPinch=()=>{t.endDolly()},t.handleStartRotate=r=>{e.previousRotation=r.rotation,t.startRotate()},t.handleEndRotate=()=>{t.endRotate()},t.handleStartPan=r=>{e.previousTranslation=r.translation,t.startPan()},t.handleEndPan=()=>{t.endPan()},t.handlePinch=r=>{t.dollyByFactor(e.getRenderer(r),r.scale/e.previousScale),e.previousScale=r.scale},t.handlePan=r=>{const n=e.getRenderer(r).getActiveCamera();let a=n.getFocalPoint();a=t.computeWorldToDisplay(e.getRenderer(r),a[0],a[1],a[2]);const i=a[2],s=r.translation,o=e.previousTranslation,c=t.computeDisplayToWorld(e.getRenderer(r),a[0]+s[0]-o[0],a[1]+s[1]-o[1],i),u=t.computeDisplayToWorld(e.getRenderer(r),a[0],a[1],i),g=[];g[0]=u[0]-c[0],g[1]=u[1]-c[1],g[2]=u[2]-c[2],a=n.getFocalPoint();const f=n.getPosition();n.setFocalPoint(g[0]+a[0],g[1]+a[1],g[2]+a[2]),n.setPosition(g[0]+f[0],g[1]+f[1],g[2]+f[2]),e._interactor.getLightFollowCamera()&&e.getRenderer(r).updateLightsGeometryToFollowCamera(),n.orthogonalizeViewUp(),e.previousTranslation=r.translation},t.handleRotate=r=>{const n=e.getRenderer(r).getActiveCamera();n.roll(r.rotation-e.previousRotation),n.orthogonalizeViewUp(),e.previousRotation=r.rotation},t.handleMouseRotate=(r,n)=>{if(!e.previousPosition)return;const a=e._interactor,i=n.x-e.previousPosition.x,s=n.y-e.previousPosition.y,o=a.getView().getViewportSize(r);let c=-.1,u=-.1;o[0]&&o[1]&&(c=-20/o[1],u=-20/o[0]);const g=i*u*e.motionFactor,f=s*c*e.motionFactor,l=r.getActiveCamera();!Number.isNaN(g)&&!Number.isNaN(f)&&(l.azimuth(g),l.elevation(f),l.orthogonalizeViewUp()),e.autoAdjustCameraClippingRange&&r.resetCameraClippingRange(),a.getLightFollowCamera()&&r.updateLightsGeometryToFollowCamera()},t.handleMouseSpin=(r,n)=>{if(!e.previousPosition)return;const a=e._interactor,i=r.getActiveCamera(),s=a.getView().getViewportCenter(r),o=Tn(Math.atan2(e.previousPosition.y-s[1],e.previousPosition.x-s[0])),c=Tn(Math.atan2(n.y-s[1],n.x-s[0]))-o;Number.isNaN(c)||(i.roll(c),i.orthogonalizeViewUp())},t.handleMousePan=(r,n)=>{if(!e.previousPosition)return;const a=r.getActiveCamera();let i=a.getFocalPoint();i=t.computeWorldToDisplay(r,i[0],i[1],i[2]);const s=i[2],o=t.computeDisplayToWorld(r,n.x,n.y,s),c=t.computeDisplayToWorld(r,e.previousPosition.x,e.previousPosition.y,s),u=[];u[0]=c[0]-o[0],u[1]=c[1]-o[1],u[2]=c[2]-o[2],i=a.getFocalPoint();const g=a.getPosition();a.setFocalPoint(u[0]+i[0],u[1]+i[1],u[2]+i[2]),a.setPosition(u[0]+g[0],u[1]+g[1],u[2]+g[2]),e._interactor.getLightFollowCamera()&&r.updateLightsGeometryToFollowCamera()},t.handleMouseDolly=(r,n)=>{if(!e.previousPosition)return;const a=n.y-e.previousPosition.y,s=e._interactor.getView().getViewportCenter(r),o=e.motionFactor*a/s[1];t.dollyByFactor(r,1.1**o)},t.handleMouseWheel=r=>{const n=1-r.spinY/e.zoomFactor;t.dollyByFactor(e.getRenderer(r),n)},t.dollyByFactor=(r,n)=>{if(Number.isNaN(n))return;const a=r.getActiveCamera();a.getParallelProjection()?a.setParallelScale(a.getParallelScale()/n):(a.dolly(n),e.autoAdjustCameraClippingRange&&r.resetCameraClippingRange()),e._interactor.getLightFollowCamera()&&r.updateLightsGeometryToFollowCamera()}}const lM={motionFactor:10,zoomFactor:10};function gl(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,lM,r),ps.extend(t,e,r),y.setGet(t,e,["motionFactor","zoomFactor"]),gM(t,e)}const pM=y.newInstance(gl,"vtkInteractorStyleTrackballCamera");var hM={newInstance:pM,extend:gl};const dM=Xy.extractURLParameters();function TM(t,e){const r=t.invokeResize;delete t.invokeResize,e.renderWindow=ix.newInstance(),e.renderer=ug.newInstance(),e.renderWindow.addRenderer(e.renderer),e._apiSpecificRenderWindow=e.renderWindow.newAPISpecificView(dM.viewAPI??e.defaultViewAPI),e.renderWindow.addView(e._apiSpecificRenderWindow),e.interactor=Gf.newInstance(),e.interactor.setInteractorStyle(hM.newInstance()),e.interactor.setView(e._apiSpecificRenderWindow),e.interactor.initialize(),t.setBackground=e.renderer.setBackground,t.setBackground(...e.background),t.resize=()=>{if(e.container){const n=e.container.getBoundingClientRect(),a=window.devicePixelRatio||1;e._apiSpecificRenderWindow.setSize(Math.floor(n.width*a),Math.floor(n.height*a)),r(),e.renderWindow.render()}},t.setContainer=n=>{e.container&&e.interactor.unbindEvents(e.container),e.container=n,e._apiSpecificRenderWindow.setContainer(e.container),e.container&&e.interactor.bindEvents(e.container)},t.delete=y.chain(t.setContainer,e._apiSpecificRenderWindow.delete,()=>{window.removeEventListener("resize",t.resize)},t.delete),e.listenWindowResize&&window.addEventListener("resize",t.resize),t.resize()}const vM={background:[.32,.34,.43],listenWindowResize:!0,container:null};function ll(t,e){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};Object.assign(e,vM,r),y.obj(t,e),y.get(t,e,["renderWindow","renderer","_apiSpecificRenderWindow","interactor","container"]),y.moveToProtected(t,e,["_apiSpecificRenderWindow"]),y.event(t,e,"resize"),TM(t,e)}const yM=y.newInstance(ll);var zM={newInstance:yM,extend:ll};export{ca as $,mM as A,RM as B,Af as C,Xu as D,rr as E,da as F,go as G,OM as H,wM as I,IS as J,EM as K,DM as L,VM as M,dr as N,lr as O,Fv as P,cf as Q,me as R,Rw as S,LM as T,FM as U,P as V,kM as W,ot as X,NM as Y,jv as Z,Zg as _,Oc as a,dn as a0,f1 as a1,_M as a2,_g as a3,Sn as a4,M2 as a5,Lg as a6,Rt as a7,re as a8,pe as a9,hr as aa,Eg as ab,C0 as ac,Kf as ad,eS as ae,XC as af,Ue as ag,Xf as ah,Oi as ai,Wf as aj,GM as ak,UM as al,ou as am,di as an,zR as ao,BM as ap,WM as aq,eM as ar,zM as as,$M as at,Jt as au,S1 as av,K as b,D1 as c,Ze as d,Ji as e,A as f,be as g,wi as h,Ff as i,bf as j,Ci as k,nu as l,y as m,Jf as n,Be as o,tT as p,uo as q,MM as r,gs as s,st as t,Ye as u,xM as v,Xy as w,ug as x,ix as y,Gf as z};
//# sourceMappingURL=vtk.js-460198e0.js.map
